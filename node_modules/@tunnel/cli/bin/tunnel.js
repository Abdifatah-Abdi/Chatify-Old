#!/usr/bin/env node
var $dAk3n$fs = require("fs");
var $dAk3n$util = require("util");
var $dAk3n$assert = require("assert");
var $dAk3n$constants = require("constants");
var $dAk3n$stream = require("stream");
var $dAk3n$path = require("path");
var $dAk3n$url = require("url");
var $dAk3n$events = require("events");
var $dAk3n$buffer = require("buffer");
var $dAk3n$string_decoder = require("string_decoder");
var $dAk3n$nodefs = require("node:fs");
var $dAk3n$nodebuffer = require("node:buffer");
var $dAk3n$nodepath = require("node:path");
var $dAk3n$nodechild_process = require("node:child_process");
var $dAk3n$nodeprocess = require("node:process");
var $dAk3n$child_process = require("child_process");
var $dAk3n$nodeurl = require("node:url");
var $dAk3n$nodeos = require("node:os");
var $dAk3n$nodetimerspromises = require("node:timers/promises");
var $dAk3n$nodeutil = require("node:util");
var $dAk3n$nodehttp = require("node:http");
var $dAk3n$nodehttps = require("node:https");
var $dAk3n$nodeevents = require("node:events");
var $dAk3n$nodestream = require("node:stream");
var $dAk3n$nodecrypto = require("node:crypto");
var $dAk3n$zlib = require("zlib");
var $dAk3n$nodenet = require("node:net");
var $dAk3n$nodetls = require("node:tls");
var $dAk3n$nodedns = require("node:dns");
var $dAk3n$http2 = require("http2");
var $dAk3n$tls = require("tls");
var $dAk3n$http = require("http");
var $dAk3n$https = require("https");
var $dAk3n$net = require("net");
var $dAk3n$module = require("module");
var $dAk3n$os = require("os");
var $dAk3n$nodetty = require("node:tty");
var $dAk3n$nodereadline = require("node:readline");

var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire7722"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire7722"] = parcelRequire;
}
parcelRequire.register("ijniW", function(module, exports) {
module.exports = $d54c14232ad0c801$var$isexe;
$d54c14232ad0c801$var$isexe.sync = $d54c14232ad0c801$var$sync;

function $d54c14232ad0c801$var$checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) return true;
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) return true;
    for(var i = 0; i < pathext.length; i++){
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) return true;
    }
    return false;
}
function $d54c14232ad0c801$var$checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) return false;
    return $d54c14232ad0c801$var$checkPathExt(path, options);
}
function $d54c14232ad0c801$var$isexe(path, options, cb) {
    $dAk3n$fs.stat(path, function(er, stat) {
        cb(er, er ? false : $d54c14232ad0c801$var$checkStat(stat, path, options));
    });
}
function $d54c14232ad0c801$var$sync(path, options) {
    return $d54c14232ad0c801$var$checkStat($dAk3n$fs.statSync(path), path, options);
}

});

parcelRequire.register("1dBIs", function(module, exports) {
module.exports = $0e3442f61d65db1f$var$isexe;
$0e3442f61d65db1f$var$isexe.sync = $0e3442f61d65db1f$var$sync;

function $0e3442f61d65db1f$var$isexe(path, options, cb) {
    $dAk3n$fs.stat(path, function(er, stat) {
        cb(er, er ? false : $0e3442f61d65db1f$var$checkStat(stat, options));
    });
}
function $0e3442f61d65db1f$var$sync(path, options) {
    return $0e3442f61d65db1f$var$checkStat($dAk3n$fs.statSync(path), options);
}
function $0e3442f61d65db1f$var$checkStat(stat, options) {
    return stat.isFile() && $0e3442f61d65db1f$var$checkMode(stat, options);
}
function $0e3442f61d65db1f$var$checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
}

});

parcelRequire.register("a0xT4", function(module, exports) {
"use strict";
function $749430c11a60a571$var$hasKey(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key) {
        o = o[key] || {};
    });
    var key = keys[keys.length - 1];
    return key in o;
}
function $749430c11a60a571$var$isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
function $749430c11a60a571$var$isConstructorOrProto(obj, key) {
    return key === "constructor" && typeof obj[key] === "function" || key === "__proto__";
}
module.exports = function(args, opts) {
    if (!opts) opts = {};
    var flags = {
        bools: {},
        strings: {},
        unknownFn: null
    };
    if (typeof opts.unknown === "function") flags.unknownFn = opts.unknown;
    if (typeof opts.boolean === "boolean" && opts.boolean) flags.allBools = true;
    else [].concat(opts.boolean).filter(Boolean).forEach(function(key) {
        flags.bools[key] = true;
    });
    var aliases = {};
    function aliasIsBoolean(key) {
        return aliases[key].some(function(x) {
            return flags.bools[x];
        });
    }
    Object.keys(opts.alias || {}).forEach(function(key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function(x) {
            aliases[x] = [
                key
            ].concat(aliases[key].filter(function(y) {
                return x !== y;
            }));
        });
    });
    [].concat(opts.string).filter(Boolean).forEach(function(key) {
        flags.strings[key] = true;
        if (aliases[key]) [].concat(aliases[key]).forEach(function(k) {
            flags.strings[k] = true;
        });
    });
    var defaults = opts.default || {};
    var argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || flags.strings[key] || flags.bools[key] || aliases[key];
    }
    function setKey(obj, keys, value) {
        var o = obj;
        for(var i = 0; i < keys.length - 1; i++){
            var key = keys[i];
            if ($749430c11a60a571$var$isConstructorOrProto(o, key)) return;
            if (o[key] === undefined) o[key] = {};
            if (o[key] === Object.prototype || o[key] === Number.prototype || o[key] === String.prototype) o[key] = {};
            if (o[key] === Array.prototype) o[key] = [];
            o = o[key];
        }
        var lastKey = keys[keys.length - 1];
        if ($749430c11a60a571$var$isConstructorOrProto(o, lastKey)) return;
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[lastKey] === undefined || flags.bools[lastKey] || typeof o[lastKey] === "boolean") o[lastKey] = value;
        else if (Array.isArray(o[lastKey])) o[lastKey].push(value);
        else o[lastKey] = [
            o[lastKey],
            value
        ];
    }
    function setArg(key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }
        var value = !flags.strings[key] && $749430c11a60a571$var$isNumber(val) ? Number(val) : val;
        setKey(argv, key.split("."), value);
        (aliases[key] || []).forEach(function(x) {
            setKey(argv, x.split("."), value);
        });
    }
    Object.keys(flags.bools).forEach(function(key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    var notFlags = [];
    if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(var i = 0; i < args.length; i++){
        var arg = args[i];
        var key;
        var next;
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            key = m[1];
            var value = m[2];
            if (flags.bools[key]) value = value !== "false";
            setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
            key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
            key = arg.match(/^--(.+)/)[1];
            next = args[i + 1];
            if (next !== undefined && !/^(-|--)[^-]/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i += 1;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i += 1;
            } else setArg(key, flags.strings[key] ? "" : true, arg);
        } else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1, -1).split("");
            var broken = false;
            for(var j = 0; j < letters.length; j++){
                next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
                    setArg(letters[j], next.slice(1), arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i + 1], arg);
                    i += 1;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key, args[i + 1] === "true", arg);
                    i += 1;
                } else setArg(key, flags.strings[key] ? "" : true, arg);
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) argv._.push(flags.strings._ || !$749430c11a60a571$var$isNumber(arg) ? arg : Number(arg));
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    Object.keys(defaults).forEach(function(k) {
        if (!$749430c11a60a571$var$hasKey(argv, k.split("."))) {
            setKey(argv, k.split("."), defaults[k]);
            (aliases[k] || []).forEach(function(x) {
                setKey(argv, x.split("."), defaults[k]);
            });
        }
    });
    if (opts["--"]) argv["--"] = notFlags.slice();
    else notFlags.forEach(function(k) {
        argv._.push(k);
    });
    return argv;
};

});

parcelRequire.register("h2kFo", function(module, exports) {
"use strict";
var $c672a78c7c94be71$var$__importDefault = module.exports && module.exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
module.exports.readCAFileSync = void 0;

const $c672a78c7c94be71$var$graceful_fs_1 = $c672a78c7c94be71$var$__importDefault((parcelRequire("kYHHE")));
function $c672a78c7c94be71$var$readCAFileSync(filePath) {
    try {
        const contents = $c672a78c7c94be71$var$graceful_fs_1.default.readFileSync(filePath, "utf8");
        const delim = "-----END CERTIFICATE-----";
        const output = contents.split(delim).filter((ca)=>Boolean(ca.trim())).map((ca)=>`${ca.trimLeft()}${delim}`);
        return output;
    } catch (err) {
        if (err.code === "ENOENT") return undefined;
        throw err;
    }
}
module.exports.readCAFileSync = $c672a78c7c94be71$var$readCAFileSync;

});
parcelRequire.register("kYHHE", function(module, exports) {


var $2p8xp = parcelRequire("2p8xp");

var $aM15X = parcelRequire("aM15X");

var $9mVhl = parcelRequire("9mVhl");

/* istanbul ignore next - node 0.x polyfill */ var $f45b4fc573dd81a5$var$gracefulQueue;
var $f45b4fc573dd81a5$var$previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    $f45b4fc573dd81a5$var$gracefulQueue = Symbol.for("graceful-fs.queue");
    // This is used in testing by future versions
    $f45b4fc573dd81a5$var$previousSymbol = Symbol.for("graceful-fs.previous");
} else {
    $f45b4fc573dd81a5$var$gracefulQueue = "___graceful-fs.queue";
    $f45b4fc573dd81a5$var$previousSymbol = "___graceful-fs.previous";
}
function $f45b4fc573dd81a5$var$noop() {}
function $f45b4fc573dd81a5$var$publishQueue(context, queue) {
    Object.defineProperty(context, $f45b4fc573dd81a5$var$gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var $f45b4fc573dd81a5$var$debug = $f45b4fc573dd81a5$var$noop;
if ($dAk3n$util.debuglog) $f45b4fc573dd81a5$var$debug = $dAk3n$util.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) $f45b4fc573dd81a5$var$debug = function() {
    var m = $dAk3n$util.format.apply($dAk3n$util, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
};

// Once time initialization
if (!$dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var $f45b4fc573dd81a5$var$queue = $parcel$global[$f45b4fc573dd81a5$var$gracefulQueue] || [];
    $f45b4fc573dd81a5$var$publishQueue($dAk3n$fs, $f45b4fc573dd81a5$var$queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    $dAk3n$fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call($dAk3n$fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) $f45b4fc573dd81a5$var$resetQueue();
                if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, $f45b4fc573dd81a5$var$previousSymbol, {
            value: fs$close
        });
        return close;
    }($dAk3n$fs.close);
    $dAk3n$fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply($dAk3n$fs, arguments);
            $f45b4fc573dd81a5$var$resetQueue();
        }
        Object.defineProperty(closeSync, $f45b4fc573dd81a5$var$previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }($dAk3n$fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
        $f45b4fc573dd81a5$var$debug($dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue]);
        $dAk3n$assert.equal($dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue].length, 0);
    });
}
if (!$parcel$global[$f45b4fc573dd81a5$var$gracefulQueue]) $f45b4fc573dd81a5$var$publishQueue($parcel$global, $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue]);
module.exports = $f45b4fc573dd81a5$var$patch($9mVhl($dAk3n$fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !$dAk3n$fs.__patched) {
    module.exports = $f45b4fc573dd81a5$var$patch($dAk3n$fs);
    $dAk3n$fs.__patched = true;
}
function $f45b4fc573dd81a5$var$patch(fs) {
    // Everything that references the open() function needs to be in here
    $2p8xp(fs);
    fs.gracefulify = $f45b4fc573dd81a5$var$patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $f45b4fc573dd81a5$var$enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $f45b4fc573dd81a5$var$enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $f45b4fc573dd81a5$var$enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $f45b4fc573dd81a5$var$enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $f45b4fc573dd81a5$var$enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === "function") cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = $aM15X(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, "ReadStream", {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, "WriteStream", {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, "FileReadStream", {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, "FileWriteStream", {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit("error", err);
            } else {
                that.fd = fd;
                that.emit("open", fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit("error", err);
            } else {
                that.fd = fd;
                that.emit("open", fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === "function") cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $f45b4fc573dd81a5$var$enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    return fs;
}
function $f45b4fc573dd81a5$var$enqueue(elem) {
    $f45b4fc573dd81a5$var$debug("ENQUEUE", elem[0].name, elem[1]);
    $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue].push(elem);
    $f45b4fc573dd81a5$var$retry();
}
// keep track of the timeout between retry() calls
var $f45b4fc573dd81a5$var$retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function $f45b4fc573dd81a5$var$resetQueue() {
    var now = Date.now();
    for(var i = 0; i < $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue].length; ++i)// entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if ($dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue][i].length > 2) {
        $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue][i][3] = now // startTime
        ;
        $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue][i][4] = now // lastTime
        ;
    }
    // call retry to make sure we're actively processing the queue
    $f45b4fc573dd81a5$var$retry();
}
function $f45b4fc573dd81a5$var$retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout($f45b4fc573dd81a5$var$retryTimer);
    $f45b4fc573dd81a5$var$retryTimer = undefined;
    if ($dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue].length === 0) return;
    var elem = $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        $f45b4fc573dd81a5$var$debug("RETRY", fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        $f45b4fc573dd81a5$var$debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function") cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            $f45b4fc573dd81a5$var$debug("RETRY", fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else // if we can't do this job yet, push it to the end of the queue
        // and let the next iteration check again
        $dAk3n$fs[$f45b4fc573dd81a5$var$gracefulQueue].push(elem);
    }
    // schedule our next run if one isn't already scheduled
    if ($f45b4fc573dd81a5$var$retryTimer === undefined) $f45b4fc573dd81a5$var$retryTimer = setTimeout($f45b4fc573dd81a5$var$retry, 0);
}

});
parcelRequire.register("2p8xp", function(module, exports) {

var $1c0489fc597fcdd7$var$origCwd = process.cwd;
var $1c0489fc597fcdd7$var$cwd = null;
var $1c0489fc597fcdd7$var$platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!$1c0489fc597fcdd7$var$cwd) $1c0489fc597fcdd7$var$cwd = $1c0489fc597fcdd7$var$origCwd.call(process);
    return $1c0489fc597fcdd7$var$cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === "function") {
    var $1c0489fc597fcdd7$var$chdir = process.chdir;
    process.chdir = function(d) {
        $1c0489fc597fcdd7$var$cwd = null;
        $1c0489fc597fcdd7$var$chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, $1c0489fc597fcdd7$var$chdir);
}
module.exports = $1c0489fc597fcdd7$var$patch;
function $1c0489fc597fcdd7$var$patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if ($dAk3n$constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs);
    // lutimes implementation, or no-op
    if (!fs.lutimes) patchLutimes(fs);
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if ($1c0489fc597fcdd7$var$platform === "win32") fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
                if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
                    setTimeout(function() {
                        fs.stat(to, function(stater, st) {
                            if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                            else cb(er);
                        });
                    }, backoff);
                    if (backoff < 100) backoff += 10;
                    return;
                }
                if (cb) cb(er);
            });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
    }(fs.rename);
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === "function") {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true)try {
                return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
                if (er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    continue;
                }
                throw er;
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, $dAk3n$constants.O_WRONLY | $dAk3n$constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, $dAk3n$constants.O_WRONLY | $dAk3n$constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) try {
                    fs.closeSync(fd);
                } catch (er) {}
                else fs.closeSync(fd);
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if ($dAk3n$constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, $dAk3n$constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, $dAk3n$constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) try {
                        fs.closeSync(fd);
                    } catch (er) {}
                    else fs.closeSync(fd);
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === "function") {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}

});

parcelRequire.register("aM15X", function(module, exports) {

var $7d7f3c854a35a06c$require$Stream = $dAk3n$stream.Stream;
module.exports = $7d7f3c854a35a06c$var$legacy;
function $7d7f3c854a35a06c$var$legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        $7d7f3c854a35a06c$require$Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 65536;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) throw TypeError("start must be a Number");
            if (this.end === undefined) this.end = Infinity;
            else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
            if (this.start > this.end) throw new Error("start must be <= end");
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit("error", err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit("open", fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        $7d7f3c854a35a06c$require$Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) throw TypeError("start must be a Number");
            if (this.start < 0) throw new Error("start must be >= zero");
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}

});

parcelRequire.register("9mVhl", function(module, exports) {
"use strict";
module.exports = $6d229979749ef1e6$var$clone;
var $6d229979749ef1e6$var$getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function $6d229979749ef1e6$var$clone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (obj instanceof Object) var copy = {
        __proto__: $6d229979749ef1e6$var$getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}

});



parcelRequire.register("4Dih0", function(module, exports) {

$parcel$export(module.exports, "types", () => $35f8faa04b2c5136$export$b14ad400b1d09e0f, (v) => $35f8faa04b2c5136$export$b14ad400b1d09e0f = v);
// Generated with `lib/make.js`
var $35f8faa04b2c5136$export$b14ad400b1d09e0f;
"use strict";


var $35f8faa04b2c5136$require$Stream = $dAk3n$stream.Stream;

const $35f8faa04b2c5136$var$Umask = ()=>{};
const $35f8faa04b2c5136$var$getLocalAddresses = ()=>[];
const $35f8faa04b2c5136$var$semver = ()=>{};
$35f8faa04b2c5136$export$b14ad400b1d09e0f = {
    access: [
        null,
        "restricted",
        "public"
    ],
    "allow-same-version": Boolean,
    "always-auth": Boolean,
    also: [
        null,
        "dev",
        "development"
    ],
    audit: Boolean,
    "auth-type": [
        "legacy",
        "sso",
        "saml",
        "oauth"
    ],
    "bin-links": Boolean,
    browser: [
        null,
        String
    ],
    ca: [
        null,
        String,
        Array
    ],
    cafile: $dAk3n$path,
    cache: $dAk3n$path,
    "cache-lock-stale": Number,
    "cache-lock-retries": Number,
    "cache-lock-wait": Number,
    "cache-max": Number,
    "cache-min": Number,
    cert: [
        null,
        String
    ],
    cidr: [
        null,
        String,
        Array
    ],
    color: [
        "always",
        Boolean
    ],
    depth: Number,
    description: Boolean,
    dev: Boolean,
    "dry-run": Boolean,
    editor: String,
    "engine-strict": Boolean,
    force: Boolean,
    "fetch-retries": Number,
    "fetch-retry-factor": Number,
    "fetch-retry-mintimeout": Number,
    "fetch-retry-maxtimeout": Number,
    git: String,
    "git-tag-version": Boolean,
    "commit-hooks": Boolean,
    global: Boolean,
    globalconfig: $dAk3n$path,
    "global-style": Boolean,
    group: [
        Number,
        String
    ],
    "https-proxy": [
        null,
        $dAk3n$url
    ],
    "user-agent": String,
    "ham-it-up": Boolean,
    "heading": String,
    "if-present": Boolean,
    "ignore-prepublish": Boolean,
    "ignore-scripts": Boolean,
    "init-module": $dAk3n$path,
    "init-author-name": String,
    "init-author-email": String,
    "init-author-url": [
        "",
        $dAk3n$url
    ],
    "init-license": String,
    "init-version": $35f8faa04b2c5136$var$semver,
    json: Boolean,
    key: [
        null,
        String
    ],
    "legacy-bundling": Boolean,
    link: Boolean,
    // local-address must be listed as an IP for a local network interface
    // must be IPv4 due to node bug
    "local-address": $35f8faa04b2c5136$var$getLocalAddresses(),
    loglevel: [
        "silent",
        "error",
        "warn",
        "notice",
        "http",
        "timing",
        "info",
        "verbose",
        "silly"
    ],
    logstream: $35f8faa04b2c5136$require$Stream,
    "logs-max": Number,
    long: Boolean,
    maxsockets: Number,
    message: String,
    "metrics-registry": [
        null,
        String
    ],
    "node-options": [
        null,
        String
    ],
    "node-version": [
        null,
        $35f8faa04b2c5136$var$semver
    ],
    "no-proxy": [
        null,
        String,
        Array
    ],
    offline: Boolean,
    "onload-script": [
        null,
        String
    ],
    only: [
        null,
        "dev",
        "development",
        "prod",
        "production"
    ],
    optional: Boolean,
    "package-lock": Boolean,
    otp: [
        null,
        String
    ],
    "package-lock-only": Boolean,
    parseable: Boolean,
    "prefer-offline": Boolean,
    "prefer-online": Boolean,
    prefix: $dAk3n$path,
    production: Boolean,
    progress: Boolean,
    proxy: [
        null,
        false,
        $dAk3n$url
    ],
    provenance: Boolean,
    // allow proxy to be disabled explicitly
    "read-only": Boolean,
    "rebuild-bundle": Boolean,
    registry: [
        null,
        $dAk3n$url
    ],
    rollback: Boolean,
    save: Boolean,
    "save-bundle": Boolean,
    "save-dev": Boolean,
    "save-exact": Boolean,
    "save-optional": Boolean,
    "save-prefix": String,
    "save-prod": Boolean,
    scope: String,
    "script-shell": [
        null,
        String
    ],
    "scripts-prepend-node-path": [
        false,
        true,
        "auto",
        "warn-only"
    ],
    searchopts: String,
    searchexclude: [
        null,
        String
    ],
    searchlimit: Number,
    searchstaleness: Number,
    "send-metrics": Boolean,
    shell: String,
    shrinkwrap: Boolean,
    "sign-git-tag": Boolean,
    "sso-poll-frequency": Number,
    "sso-type": [
        null,
        "oauth",
        "saml"
    ],
    "strict-ssl": Boolean,
    tag: String,
    timing: Boolean,
    tmp: $dAk3n$path,
    unicode: Boolean,
    "unsafe-perm": Boolean,
    usage: Boolean,
    user: [
        Number,
        String
    ],
    userconfig: $dAk3n$path,
    umask: $35f8faa04b2c5136$var$Umask,
    version: Boolean,
    "tag-version-prefix": String,
    versions: Boolean,
    viewer: String,
    _exit: Boolean
};

});

parcelRequire.register("b95lY", function(module, exports) {

var $kRlLP = parcelRequire("kRlLP");
var $81d4b00b8021e87f$require$MAX_SAFE_COMPONENT_LENGTH = $kRlLP.MAX_SAFE_COMPONENT_LENGTH;
var $81d4b00b8021e87f$require$MAX_SAFE_BUILD_LENGTH = $kRlLP.MAX_SAFE_BUILD_LENGTH;

var $kAJmv = parcelRequire("kAJmv");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        "\\s",
        1
    ],
    [
        "\\d",
        $81d4b00b8021e87f$require$MAX_SAFE_COMPONENT_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        $81d4b00b8021e87f$require$MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements)value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    $kAJmv(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken("FULL", `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
createToken("GTLT", "((?:<|>)?=?)");
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${$81d4b00b8021e87f$require$MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${$81d4b00b8021e87f$require$MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${$81d4b00b8021e87f$require$MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
createToken("COERCERTL", src[t.COERCE], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken("LONETILDE", "(?:~>?)");
createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = "$1~";
createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken("LONECARET", "(?:\\^)");
createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = "$1^";
createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = "$1$2$3";
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken("STAR", "(<|>)?=?\\s*\\*");
// >=0.0.0 is like a star
createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");

});
parcelRequire.register("kRlLP", function(module, exports) {
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const $f2f9a5104ea85de4$var$SEMVER_SPEC_VERSION = "2.0.0";
const $f2f9a5104ea85de4$var$MAX_LENGTH = 256;
const $f2f9a5104ea85de4$var$MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const $f2f9a5104ea85de4$var$MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const $f2f9a5104ea85de4$var$MAX_SAFE_BUILD_LENGTH = $f2f9a5104ea85de4$var$MAX_LENGTH - 6;
const $f2f9a5104ea85de4$var$RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
];
module.exports = {
    MAX_LENGTH: $f2f9a5104ea85de4$var$MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH: $f2f9a5104ea85de4$var$MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH: $f2f9a5104ea85de4$var$MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER: $f2f9a5104ea85de4$var$MAX_SAFE_INTEGER,
    RELEASE_TYPES: $f2f9a5104ea85de4$var$RELEASE_TYPES,
    SEMVER_SPEC_VERSION: $f2f9a5104ea85de4$var$SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
};

});

parcelRequire.register("kAJmv", function(module, exports) {
const $efda5b656fe55b32$var$debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error("SEMVER", ...args) : ()=>{};
module.exports = $efda5b656fe55b32$var$debug;

});


parcelRequire.register("TLw5d", function(module, exports) {
"use strict";
module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next)yield walker.value;
    };
};

});

parcelRequire.register("39RQR", function(module, exports) {


var $ap0j4 = parcelRequire("ap0j4");

var $exhnm = parcelRequire("exhnm");

var $jUc0O = parcelRequire("jUc0O");

var $hDoeW = parcelRequire("hDoeW");
var $24cbfc2c0516d271$require$Writable = $hDoeW.Writable;

var $hDoeW = parcelRequire("hDoeW");
var $24cbfc2c0516d271$require$PassThrough = $hDoeW.PassThrough;
var $24cbfc2c0516d271$var$noop = function() {};
var $24cbfc2c0516d271$var$overflow = function(size) {
    size &= 511;
    return size && 512 - size;
};
var $24cbfc2c0516d271$var$emptyStream = function(self, offset) {
    var s = new $24cbfc2c0516d271$var$Source(self, offset);
    s.end();
    return s;
};
var $24cbfc2c0516d271$var$mixinPax = function(header, pax) {
    if (pax.path) header.name = pax.path;
    if (pax.linkpath) header.linkname = pax.linkpath;
    if (pax.size) header.size = parseInt(pax.size, 10);
    header.pax = pax;
    return header;
};
var $24cbfc2c0516d271$var$Source = function(self, offset) {
    this._parent = self;
    this.offset = offset;
    $24cbfc2c0516d271$require$PassThrough.call(this);
};
$dAk3n$util.inherits($24cbfc2c0516d271$var$Source, $24cbfc2c0516d271$require$PassThrough);
$24cbfc2c0516d271$var$Source.prototype.destroy = function(err) {
    this._parent.destroy(err);
};
var $24cbfc2c0516d271$var$Extract = function(opts) {
    if (!(this instanceof $24cbfc2c0516d271$var$Extract)) return new $24cbfc2c0516d271$var$Extract(opts);
    $24cbfc2c0516d271$require$Writable.call(this, opts);
    opts = opts || {};
    this._offset = 0;
    this._buffer = $ap0j4();
    this._missing = 0;
    this._partial = false;
    this._onparse = $24cbfc2c0516d271$var$noop;
    this._header = null;
    this._stream = null;
    this._overflow = null;
    this._cb = null;
    this._locked = false;
    this._destroyed = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    var self = this;
    var b = self._buffer;
    var oncontinue = function() {
        self._continue();
    };
    var onunlock = function(err) {
        self._locked = false;
        if (err) return self.destroy(err);
        if (!self._stream) oncontinue();
    };
    var onstreamend = function() {
        self._stream = null;
        var drain = $24cbfc2c0516d271$var$overflow(self._header.size);
        if (drain) self._parse(drain, ondrain);
        else self._parse(512, onheader);
        if (!self._locked) oncontinue();
    };
    var ondrain = function() {
        self._buffer.consume($24cbfc2c0516d271$var$overflow(self._header.size));
        self._parse(512, onheader);
        oncontinue();
    };
    var onpaxglobalheader = function() {
        var size = self._header.size;
        self._paxGlobal = $jUc0O.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
    };
    var onpaxheader = function() {
        var size = self._header.size;
        self._pax = $jUc0O.decodePax(b.slice(0, size));
        if (self._paxGlobal) self._pax = $exhnm(self._paxGlobal, self._pax);
        b.consume(size);
        onstreamend();
    };
    var ongnulongpath = function() {
        var size = self._header.size;
        this._gnuLongPath = $jUc0O.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
    };
    var ongnulonglinkpath = function() {
        var size = self._header.size;
        this._gnuLongLinkPath = $jUc0O.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
    };
    var onheader = function() {
        var offset = self._offset;
        var header;
        try {
            header = self._header = $jUc0O.decode(b.slice(0, 512), opts.filenameEncoding);
        } catch (err) {
            self.emit("error", err);
        }
        b.consume(512);
        if (!header) {
            self._parse(512, onheader);
            oncontinue();
            return;
        }
        if (header.type === "gnu-long-path") {
            self._parse(header.size, ongnulongpath);
            oncontinue();
            return;
        }
        if (header.type === "gnu-long-link-path") {
            self._parse(header.size, ongnulonglinkpath);
            oncontinue();
            return;
        }
        if (header.type === "pax-global-header") {
            self._parse(header.size, onpaxglobalheader);
            oncontinue();
            return;
        }
        if (header.type === "pax-header") {
            self._parse(header.size, onpaxheader);
            oncontinue();
            return;
        }
        if (self._gnuLongPath) {
            header.name = self._gnuLongPath;
            self._gnuLongPath = null;
        }
        if (self._gnuLongLinkPath) {
            header.linkname = self._gnuLongLinkPath;
            self._gnuLongLinkPath = null;
        }
        if (self._pax) {
            self._header = header = $24cbfc2c0516d271$var$mixinPax(header, self._pax);
            self._pax = null;
        }
        self._locked = true;
        if (!header.size || header.type === "directory") {
            self._parse(512, onheader);
            self.emit("entry", header, $24cbfc2c0516d271$var$emptyStream(self, offset), onunlock);
            return;
        }
        self._stream = new $24cbfc2c0516d271$var$Source(self, offset);
        self.emit("entry", header, self._stream, onunlock);
        self._parse(header.size, onstreamend);
        oncontinue();
    };
    this._onheader = onheader;
    this._parse(512, onheader);
};
$dAk3n$util.inherits($24cbfc2c0516d271$var$Extract, $24cbfc2c0516d271$require$Writable);
$24cbfc2c0516d271$var$Extract.prototype.destroy = function(err) {
    if (this._destroyed) return;
    this._destroyed = true;
    if (err) this.emit("error", err);
    this.emit("close");
    if (this._stream) this._stream.emit("close");
};
$24cbfc2c0516d271$var$Extract.prototype._parse = function(size, onparse) {
    if (this._destroyed) return;
    this._offset += size;
    this._missing = size;
    if (onparse === this._onheader) this._partial = false;
    this._onparse = onparse;
};
$24cbfc2c0516d271$var$Extract.prototype._continue = function() {
    if (this._destroyed) return;
    var cb = this._cb;
    this._cb = $24cbfc2c0516d271$var$noop;
    if (this._overflow) this._write(this._overflow, undefined, cb);
    else cb();
};
$24cbfc2c0516d271$var$Extract.prototype._write = function(data, enc, cb) {
    if (this._destroyed) return;
    var s = this._stream;
    var b = this._buffer;
    var missing = this._missing;
    if (data.length) this._partial = true;
    // we do not reach end-of-chunk now. just forward it
    if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s) return s.write(data, cb);
        b.append(data);
        return cb();
    }
    // end-of-chunk. the parser should call cb.
    this._cb = cb;
    this._missing = 0;
    var overflow = null;
    if (data.length > missing) {
        overflow = data.slice(missing);
        data = data.slice(0, missing);
    }
    if (s) s.end(data);
    else b.append(data);
    this._overflow = overflow;
    this._onparse();
};
$24cbfc2c0516d271$var$Extract.prototype._final = function(cb) {
    if (this._partial) return this.destroy(new Error("Unexpected end of data"));
    cb();
};
module.exports = $24cbfc2c0516d271$var$Extract;

});
parcelRequire.register("ap0j4", function(module, exports) {

var $6EfWE = parcelRequire("6EfWE");


var $2uDEU = parcelRequire("2uDEU");
var $792c7a148327e579$require$Buffer = $2uDEU.Buffer;
function $792c7a148327e579$var$BufferList(callback) {
    if (!(this instanceof $792c7a148327e579$var$BufferList)) return new $792c7a148327e579$var$BufferList(callback);
    this._bufs = [];
    this.length = 0;
    if (typeof callback == "function") {
        this._callback = callback;
        var piper = (function piper(err) {
            if (this._callback) {
                this._callback(err);
                this._callback = null;
            }
        }).bind(this);
        this.on("pipe", function onPipe(src) {
            src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
            src.removeListener("error", piper);
        });
    } else this.append(callback);
    $6EfWE.call(this);
}
$dAk3n$util.inherits($792c7a148327e579$var$BufferList, $6EfWE);
$792c7a148327e579$var$BufferList.prototype._offset = function _offset(offset) {
    var tot = 0, i = 0, _t;
    if (offset === 0) return [
        0,
        0
    ];
    for(; i < this._bufs.length; i++){
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) return [
            i,
            offset - tot
        ];
        tot = _t;
    }
};
$792c7a148327e579$var$BufferList.prototype.append = function append(buf) {
    var i = 0;
    if ($792c7a148327e579$require$Buffer.isBuffer(buf)) this._appendBuffer(buf);
    else if (Array.isArray(buf)) for(; i < buf.length; i++)this.append(buf[i]);
    else if (buf instanceof $792c7a148327e579$var$BufferList) // unwrap argument into individual BufferLists
    for(; i < buf._bufs.length; i++)this.append(buf._bufs[i]);
    else if (buf != null) {
        // coerce number arguments to strings, since Buffer(number) does
        // uninitialized memory allocation
        if (typeof buf == "number") buf = buf.toString();
        this._appendBuffer($792c7a148327e579$require$Buffer.from(buf));
    }
    return this;
};
$792c7a148327e579$var$BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
};
$792c7a148327e579$var$BufferList.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback == "function") callback();
};
$792c7a148327e579$var$BufferList.prototype._read = function _read(size) {
    if (!this.length) return this.push(null);
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
};
$792c7a148327e579$var$BufferList.prototype.end = function end(chunk) {
    $6EfWE.prototype.end.call(this, chunk);
    if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
    }
};
$792c7a148327e579$var$BufferList.prototype.get = function get(index) {
    return this.slice(index, index + 1)[0];
};
$792c7a148327e579$var$BufferList.prototype.slice = function slice(start, end) {
    if (typeof start == "number" && start < 0) start += this.length;
    if (typeof end == "number" && end < 0) end += this.length;
    return this.copy(null, 0, start, end);
};
$792c7a148327e579$var$BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart != "number" || srcStart < 0) srcStart = 0;
    if (typeof srcEnd != "number" || srcEnd > this.length) srcEnd = this.length;
    if (srcStart >= this.length) return dst || $792c7a148327e579$require$Buffer.alloc(0);
    if (srcEnd <= 0) return dst || $792c7a148327e579$require$Buffer.alloc(0);
    var copy = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy && dstStart || 0, start = off[1], l, i;
    // copy/slice everything
    if (srcStart === 0 && srcEnd == this.length) {
        if (!copy) return this._bufs.length === 1 ? this._bufs[0] : $792c7a148327e579$require$Buffer.concat(this._bufs, this.length);
        // copy, need to copy individual buffers
        for(i = 0; i < this._bufs.length; i++){
            this._bufs[i].copy(dst, bufoff);
            bufoff += this._bufs[i].length;
        }
        return dst;
    }
    // easy, cheap case where it's a subset of one of the buffers
    if (bytes <= this._bufs[off[0]].length - start) return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    if (!copy) dst = $792c7a148327e579$require$Buffer.allocUnsafe(len);
    for(i = off[0]; i < this._bufs.length; i++){
        l = this._bufs[i].length - start;
        if (bytes > l) {
            this._bufs[i].copy(dst, bufoff, start);
            bufoff += l;
        } else {
            this._bufs[i].copy(dst, bufoff, start, start + bytes);
            bufoff += l;
            break;
        }
        bytes -= l;
        if (start) start = 0;
    }
    // safeguard so that we don't return uninitialized memory
    if (dst.length > bufoff) return dst.slice(0, bufoff);
    return dst;
};
$792c7a148327e579$var$BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = end || this.length;
    if (start < 0) start += this.length;
    if (end < 0) end += this.length;
    var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] == 0) buffers.pop();
    else buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    if (startOffset[1] != 0) buffers[0] = buffers[0].slice(startOffset[1]);
    return new $792c7a148327e579$var$BufferList(buffers);
};
$792c7a148327e579$var$BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
};
$792c7a148327e579$var$BufferList.prototype.consume = function consume(bytes) {
    // first, normalize the argument, in accordance with how Buffer does it
    bytes = Math.trunc(bytes);
    // do nothing if not a positive number
    if (Number.isNaN(bytes) || bytes <= 0) return this;
    while(this._bufs.length)if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
    } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
    }
    return this;
};
$792c7a148327e579$var$BufferList.prototype.duplicate = function duplicate() {
    var i = 0, copy = new $792c7a148327e579$var$BufferList();
    for(; i < this._bufs.length; i++)copy.append(this._bufs[i]);
    return copy;
};
$792c7a148327e579$var$BufferList.prototype.destroy = function destroy() {
    this._bufs.length = 0;
    this.length = 0;
    this.push(null);
};
(function() {
    var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1
    };
    for(var m in methods)(function(m) {
        $792c7a148327e579$var$BufferList.prototype[m] = function(offset) {
            return this.slice(offset, offset + methods[m])[m](0);
        };
    })(m);
})();
module.exports = $792c7a148327e579$var$BufferList;

});
parcelRequire.register("6EfWE", function(module, exports) {

module.exports = (parcelRequire("hDoeW")).Duplex;

});
parcelRequire.register("hDoeW", function(module, exports) {






if (process.env.READABLE_STREAM === "disable" && $dAk3n$stream) {
    module.exports = $dAk3n$stream;
    exports = module.exports = $dAk3n$stream.Readable;
    exports.Readable = $dAk3n$stream.Readable;
    exports.Writable = $dAk3n$stream.Writable;
    exports.Duplex = $dAk3n$stream.Duplex;
    exports.Transform = $dAk3n$stream.Transform;
    exports.PassThrough = $dAk3n$stream.PassThrough;
    exports.Stream = $dAk3n$stream;
} else {
    exports = module.exports = (parcelRequire("iEjYl"));
    exports.Stream = $dAk3n$stream || exports;
    exports.Readable = exports;
    exports.Writable = (parcelRequire("3uSXb"));
    exports.Duplex = (parcelRequire("bWTaa"));
    exports.Transform = (parcelRequire("7MnTU"));
    exports.PassThrough = (parcelRequire("jrPuM"));
}

});
parcelRequire.register("iEjYl", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";

var $HWgk4 = parcelRequire("HWgk4");
/*</replacement>*/ module.exports = $d93b7480f4ab17c4$var$Readable;

var $4qzLI = parcelRequire("4qzLI");
/*</replacement>*/ /*<replacement>*/ var $d93b7480f4ab17c4$var$Duplex;
/*</replacement>*/ $d93b7480f4ab17c4$var$Readable.ReadableState = $d93b7480f4ab17c4$var$ReadableState;

var $d93b7480f4ab17c4$require$EE = $dAk3n$events.EventEmitter;
var $d93b7480f4ab17c4$var$EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
};

var $98SCi = parcelRequire("98SCi");

var $34VnU = parcelRequire("34VnU");
var $d93b7480f4ab17c4$require$Buffer = $34VnU.Buffer;
var $d93b7480f4ab17c4$var$OurUint8Array = (typeof $parcel$global !== "undefined" ? $parcel$global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function $d93b7480f4ab17c4$var$_uint8ArrayToBuffer(chunk) {
    return $d93b7480f4ab17c4$require$Buffer.from(chunk);
}
function $d93b7480f4ab17c4$var$_isUint8Array(obj) {
    return $d93b7480f4ab17c4$require$Buffer.isBuffer(obj) || obj instanceof $d93b7480f4ab17c4$var$OurUint8Array;
}

/*</replacement>*/ /*<replacement>*/ var $d93b7480f4ab17c4$var$util = Object.create((parcelRequire("8hX9Z")));

$d93b7480f4ab17c4$var$util.inherits = (parcelRequire("csJOe"));

var $d93b7480f4ab17c4$var$debug = void 0;
if ($dAk3n$util && $dAk3n$util.debuglog) $d93b7480f4ab17c4$var$debug = $dAk3n$util.debuglog("stream");
else $d93b7480f4ab17c4$var$debug = function() {};

var $g4Z28 = parcelRequire("g4Z28");

var $dSSZ2 = parcelRequire("dSSZ2");
var $d93b7480f4ab17c4$var$StringDecoder;
$d93b7480f4ab17c4$var$util.inherits($d93b7480f4ab17c4$var$Readable, $98SCi);
var $d93b7480f4ab17c4$var$kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function $d93b7480f4ab17c4$var$prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if ($4qzLI(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}


function $d93b7480f4ab17c4$var$ReadableState(options, stream) {
    $d93b7480f4ab17c4$var$Duplex = $d93b7480f4ab17c4$var$Duplex || (parcelRequire("bWTaa"));
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof $d93b7480f4ab17c4$var$Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16384;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new $g4Z28();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!$d93b7480f4ab17c4$var$StringDecoder) $d93b7480f4ab17c4$var$StringDecoder = (parcelRequire("1SAK8")).StringDecoder;
        this.decoder = new $d93b7480f4ab17c4$var$StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}

function $d93b7480f4ab17c4$var$Readable(options) {
    $d93b7480f4ab17c4$var$Duplex = $d93b7480f4ab17c4$var$Duplex || (parcelRequire("bWTaa"));
    if (!(this instanceof $d93b7480f4ab17c4$var$Readable)) return new $d93b7480f4ab17c4$var$Readable(options);
    this._readableState = new $d93b7480f4ab17c4$var$ReadableState(options, this);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    $98SCi.call(this);
}
Object.defineProperty($d93b7480f4ab17c4$var$Readable.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
$d93b7480f4ab17c4$var$Readable.prototype.destroy = $dSSZ2.destroy;
$d93b7480f4ab17c4$var$Readable.prototype._undestroy = $dSSZ2.undestroy;
$d93b7480f4ab17c4$var$Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
$d93b7480f4ab17c4$var$Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = $d93b7480f4ab17c4$require$Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return $d93b7480f4ab17c4$var$readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
$d93b7480f4ab17c4$var$Readable.prototype.unshift = function(chunk) {
    return $d93b7480f4ab17c4$var$readableAddChunk(this, chunk, null, true, false);
};
function $d93b7480f4ab17c4$var$readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        $d93b7480f4ab17c4$var$onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = $d93b7480f4ab17c4$var$chunkInvalid(state, chunk);
        if (er) stream.emit("error", er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== $d93b7480f4ab17c4$require$Buffer.prototype) chunk = $d93b7480f4ab17c4$var$_uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
                else $d93b7480f4ab17c4$var$addChunk(stream, state, chunk, true);
            } else if (state.ended) stream.emit("error", new Error("stream.push() after EOF"));
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) $d93b7480f4ab17c4$var$addChunk(stream, state, chunk, false);
                    else $d93b7480f4ab17c4$var$maybeReadMore(stream, state);
                } else $d93b7480f4ab17c4$var$addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) state.reading = false;
    }
    return $d93b7480f4ab17c4$var$needMoreData(state);
}
function $d93b7480f4ab17c4$var$addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) $d93b7480f4ab17c4$var$emitReadable(stream);
    }
    $d93b7480f4ab17c4$var$maybeReadMore(stream, state);
}
function $d93b7480f4ab17c4$var$chunkInvalid(state, chunk) {
    var er;
    if (!$d93b7480f4ab17c4$var$_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new TypeError("Invalid non-string/buffer chunk");
    return er;
}
// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function $d93b7480f4ab17c4$var$needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
$d93b7480f4ab17c4$var$Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};

// backwards compatibility.
$d93b7480f4ab17c4$var$Readable.prototype.setEncoding = function(enc) {
    if (!$d93b7480f4ab17c4$var$StringDecoder) $d93b7480f4ab17c4$var$StringDecoder = (parcelRequire("1SAK8")).StringDecoder;
    this._readableState.decoder = new $d93b7480f4ab17c4$var$StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
};
// Don't raise the hwm > 8MB
var $d93b7480f4ab17c4$var$MAX_HWM = 0x800000;
function $d93b7480f4ab17c4$var$computeNewHighWaterMark(n) {
    if (n >= $d93b7480f4ab17c4$var$MAX_HWM) n = $d93b7480f4ab17c4$var$MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $d93b7480f4ab17c4$var$howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = $d93b7480f4ab17c4$var$computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
$d93b7480f4ab17c4$var$Readable.prototype.read = function(n) {
    $d93b7480f4ab17c4$var$debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        $d93b7480f4ab17c4$var$debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) $d93b7480f4ab17c4$var$endReadable(this);
        else $d93b7480f4ab17c4$var$emitReadable(this);
        return null;
    }
    n = $d93b7480f4ab17c4$var$howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) $d93b7480f4ab17c4$var$endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    $d93b7480f4ab17c4$var$debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        $d93b7480f4ab17c4$var$debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        $d93b7480f4ab17c4$var$debug("reading or ended", doRead);
    } else if (doRead) {
        $d93b7480f4ab17c4$var$debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = $d93b7480f4ab17c4$var$howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = $d93b7480f4ab17c4$var$fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = true;
        n = 0;
    } else state.length -= n;
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) $d93b7480f4ab17c4$var$endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function $d93b7480f4ab17c4$var$onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    // emit 'readable' now to make sure it gets picked up.
    $d93b7480f4ab17c4$var$emitReadable(stream);
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function $d93b7480f4ab17c4$var$emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
        $d93b7480f4ab17c4$var$debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) $HWgk4.nextTick($d93b7480f4ab17c4$var$emitReadable_, stream);
        else $d93b7480f4ab17c4$var$emitReadable_(stream);
    }
}
function $d93b7480f4ab17c4$var$emitReadable_(stream) {
    $d93b7480f4ab17c4$var$debug("emit readable");
    stream.emit("readable");
    $d93b7480f4ab17c4$var$flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function $d93b7480f4ab17c4$var$maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        $HWgk4.nextTick($d93b7480f4ab17c4$var$maybeReadMore_, stream, state);
    }
}
function $d93b7480f4ab17c4$var$maybeReadMore_(stream, state) {
    var len = state.length;
    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){
        $d93b7480f4ab17c4$var$debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
        else len = state.length;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
$d93b7480f4ab17c4$var$Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
};
$d93b7480f4ab17c4$var$Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    $d93b7480f4ab17c4$var$debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) $HWgk4.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        $d93b7480f4ab17c4$var$debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        $d93b7480f4ab17c4$var$debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = $d93b7480f4ab17c4$var$pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        $d93b7480f4ab17c4$var$debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
        $d93b7480f4ab17c4$var$debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && $d93b7480f4ab17c4$var$indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                $d93b7480f4ab17c4$var$debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
                increasedAwaitDrain = true;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        $d93b7480f4ab17c4$var$debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if ($d93b7480f4ab17c4$var$EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    // Make sure our error handler is attached before userland ones.
    $d93b7480f4ab17c4$var$prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        $d93b7480f4ab17c4$var$debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        $d93b7480f4ab17c4$var$debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        $d93b7480f4ab17c4$var$debug("pipe resume");
        src.resume();
    }
    return dest;
};
function $d93b7480f4ab17c4$var$pipeOnDrain(src) {
    return function() {
        var state = src._readableState;
        $d93b7480f4ab17c4$var$debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && $d93b7480f4ab17c4$var$EElistenerCount(src, "data")) {
            state.flowing = true;
            $d93b7480f4ab17c4$var$flow(src);
        }
    };
}
$d93b7480f4ab17c4$var$Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = $d93b7480f4ab17c4$var$indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
$d93b7480f4ab17c4$var$Readable.prototype.on = function(ev, fn) {
    var res = $98SCi.prototype.on.call(this, ev, fn);
    if (ev === "data") // Start flowing on next tick if stream isn't explicitly paused
    {
        if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) $HWgk4.nextTick($d93b7480f4ab17c4$var$nReadingNextTick, this);
            else if (state.length) $d93b7480f4ab17c4$var$emitReadable(this);
        }
    }
    return res;
};
$d93b7480f4ab17c4$var$Readable.prototype.addListener = $d93b7480f4ab17c4$var$Readable.prototype.on;
function $d93b7480f4ab17c4$var$nReadingNextTick(self1) {
    $d93b7480f4ab17c4$var$debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
$d93b7480f4ab17c4$var$Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        $d93b7480f4ab17c4$var$debug("resume");
        state.flowing = true;
        $d93b7480f4ab17c4$var$resume(this, state);
    }
    return this;
};
function $d93b7480f4ab17c4$var$resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        $HWgk4.nextTick($d93b7480f4ab17c4$var$resume_, stream, state);
    }
}
function $d93b7480f4ab17c4$var$resume_(stream, state) {
    if (!state.reading) {
        $d93b7480f4ab17c4$var$debug("resume read 0");
        stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    $d93b7480f4ab17c4$var$flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
$d93b7480f4ab17c4$var$Readable.prototype.pause = function() {
    $d93b7480f4ab17c4$var$debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
        $d93b7480f4ab17c4$var$debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    return this;
};
function $d93b7480f4ab17c4$var$flow(stream) {
    var state = stream._readableState;
    $d93b7480f4ab17c4$var$debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
$d93b7480f4ab17c4$var$Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        $d93b7480f4ab17c4$var$debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        $d93b7480f4ab17c4$var$debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function(method) {
        return function() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < $d93b7480f4ab17c4$var$kProxyEvents.length; n++)stream.on($d93b7480f4ab17c4$var$kProxyEvents[n], this.emit.bind(this, $d93b7480f4ab17c4$var$kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        $d93b7480f4ab17c4$var$debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
Object.defineProperty($d93b7480f4ab17c4$var$Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._readableState.highWaterMark;
    }
});
// exposed for testing purposes only.
$d93b7480f4ab17c4$var$Readable._fromList = $d93b7480f4ab17c4$var$fromList;
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $d93b7480f4ab17c4$var$fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = $d93b7480f4ab17c4$var$fromListPartial(n, state.buffer, state.decoder);
    return ret;
}
// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $d93b7480f4ab17c4$var$fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) // first chunk is a perfect match
    ret = list.shift();
    else // result spans more than one buffer
    ret = hasStrings ? $d93b7480f4ab17c4$var$copyFromBufferString(n, list) : $d93b7480f4ab17c4$var$copyFromBuffer(n, list);
    return ret;
}
// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $d93b7480f4ab17c4$var$copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while(p = p.next){
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
            if (nb === str.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = str.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $d93b7480f4ab17c4$var$copyFromBuffer(n, list) {
    var ret = $d93b7480f4ab17c4$require$Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while(p = p.next){
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
            if (nb === buf.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = buf.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function $d93b7480f4ab17c4$var$endReadable(stream) {
    var state = stream._readableState;
    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
        state.ended = true;
        $HWgk4.nextTick($d93b7480f4ab17c4$var$endReadableNT, state, stream);
    }
}
function $d93b7480f4ab17c4$var$endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
    }
}
function $d93b7480f4ab17c4$var$indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

});
parcelRequire.register("HWgk4", function(module, exports) {
"use strict";
if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) module.exports = {
    nextTick: $084135f0a608ab0a$var$nextTick
};
else module.exports = process;
function $084135f0a608ab0a$var$nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") throw new TypeError('"callback" argument must be a function');
    var len = arguments.length;
    var args, i;
    switch(len){
        case 0:
        case 1:
            return process.nextTick(fn);
        case 2:
            return process.nextTick(function afterTickOne() {
                fn.call(null, arg1);
            });
        case 3:
            return process.nextTick(function afterTickTwo() {
                fn.call(null, arg1, arg2);
            });
        case 4:
            return process.nextTick(function afterTickThree() {
                fn.call(null, arg1, arg2, arg3);
            });
        default:
            args = new Array(len - 1);
            i = 0;
            while(i < args.length)args[i++] = arguments[i];
            return process.nextTick(function afterTick() {
                fn.apply(null, args);
            });
    }
}

});

parcelRequire.register("4qzLI", function(module, exports) {
var $33955609a452b09e$var$toString = {}.toString;
module.exports = Array.isArray || function(arr) {
    return $33955609a452b09e$var$toString.call(arr) == "[object Array]";
};

});

parcelRequire.register("98SCi", function(module, exports) {

module.exports = $dAk3n$stream;

});

parcelRequire.register("34VnU", function(module, exports) {
/* eslint-disable node/no-deprecated-api */ 
var $23de4238852abe81$var$Buffer = $dAk3n$buffer.Buffer;
// alternative to using Object.keys for old browsers
function $23de4238852abe81$var$copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if ($23de4238852abe81$var$Buffer.from && $23de4238852abe81$var$Buffer.alloc && $23de4238852abe81$var$Buffer.allocUnsafe && $23de4238852abe81$var$Buffer.allocUnsafeSlow) module.exports = $dAk3n$buffer;
else {
    // Copy properties from require('buffer')
    $23de4238852abe81$var$copyProps($dAk3n$buffer, module.exports);
    module.exports.Buffer = $23de4238852abe81$var$SafeBuffer;
}
function $23de4238852abe81$var$SafeBuffer(arg, encodingOrOffset, length) {
    return $23de4238852abe81$var$Buffer(arg, encodingOrOffset, length);
}
// Copy static methods from Buffer
$23de4238852abe81$var$copyProps($23de4238852abe81$var$Buffer, $23de4238852abe81$var$SafeBuffer);
$23de4238852abe81$var$SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return $23de4238852abe81$var$Buffer(arg, encodingOrOffset, length);
};
$23de4238852abe81$var$SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = $23de4238852abe81$var$Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
$23de4238852abe81$var$SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return $23de4238852abe81$var$Buffer(size);
};
$23de4238852abe81$var$SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return $dAk3n$buffer.SlowBuffer(size);
};

});

parcelRequire.register("8hX9Z", function(module, exports) {

$parcel$export(module.exports, "isArray", () => $608dcd3a9c06507b$export$43bee75e5e14138e, (v) => $608dcd3a9c06507b$export$43bee75e5e14138e = v);
$parcel$export(module.exports, "isBoolean", () => $608dcd3a9c06507b$export$f9ce7b637dfbe238, (v) => $608dcd3a9c06507b$export$f9ce7b637dfbe238 = v);
$parcel$export(module.exports, "isNull", () => $608dcd3a9c06507b$export$630801d484da15df, (v) => $608dcd3a9c06507b$export$630801d484da15df = v);
$parcel$export(module.exports, "isNullOrUndefined", () => $608dcd3a9c06507b$export$bedb7023a7733221, (v) => $608dcd3a9c06507b$export$bedb7023a7733221 = v);
$parcel$export(module.exports, "isNumber", () => $608dcd3a9c06507b$export$7e4aa119212bc614, (v) => $608dcd3a9c06507b$export$7e4aa119212bc614 = v);
$parcel$export(module.exports, "isString", () => $608dcd3a9c06507b$export$844ec244b1367d54, (v) => $608dcd3a9c06507b$export$844ec244b1367d54 = v);
$parcel$export(module.exports, "isSymbol", () => $608dcd3a9c06507b$export$a244864fd9645c7f, (v) => $608dcd3a9c06507b$export$a244864fd9645c7f = v);
$parcel$export(module.exports, "isUndefined", () => $608dcd3a9c06507b$export$fce6876652108ab, (v) => $608dcd3a9c06507b$export$fce6876652108ab = v);
$parcel$export(module.exports, "isRegExp", () => $608dcd3a9c06507b$export$49841c62b9eff15, (v) => $608dcd3a9c06507b$export$49841c62b9eff15 = v);
$parcel$export(module.exports, "isObject", () => $608dcd3a9c06507b$export$a6cdc56e425d0d0a, (v) => $608dcd3a9c06507b$export$a6cdc56e425d0d0a = v);
$parcel$export(module.exports, "isDate", () => $608dcd3a9c06507b$export$871608497c498473, (v) => $608dcd3a9c06507b$export$871608497c498473 = v);
$parcel$export(module.exports, "isError", () => $608dcd3a9c06507b$export$e6127cc7fe7395c3, (v) => $608dcd3a9c06507b$export$e6127cc7fe7395c3 = v);
$parcel$export(module.exports, "isFunction", () => $608dcd3a9c06507b$export$f6e2535fb5126e54, (v) => $608dcd3a9c06507b$export$f6e2535fb5126e54 = v);
$parcel$export(module.exports, "isPrimitive", () => $608dcd3a9c06507b$export$c3825b437cbdea5c, (v) => $608dcd3a9c06507b$export$c3825b437cbdea5c = v);
$parcel$export(module.exports, "isBuffer", () => $608dcd3a9c06507b$export$a7884ebc965f8f54, (v) => $608dcd3a9c06507b$export$a7884ebc965f8f54 = v);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
var $608dcd3a9c06507b$export$43bee75e5e14138e;
var $608dcd3a9c06507b$export$f9ce7b637dfbe238;
var $608dcd3a9c06507b$export$630801d484da15df;
var $608dcd3a9c06507b$export$bedb7023a7733221;
var $608dcd3a9c06507b$export$7e4aa119212bc614;
var $608dcd3a9c06507b$export$844ec244b1367d54;
var $608dcd3a9c06507b$export$a244864fd9645c7f;
var $608dcd3a9c06507b$export$fce6876652108ab;
var $608dcd3a9c06507b$export$49841c62b9eff15;
var $608dcd3a9c06507b$export$a6cdc56e425d0d0a;
var $608dcd3a9c06507b$export$871608497c498473;
var $608dcd3a9c06507b$export$e6127cc7fe7395c3;
var $608dcd3a9c06507b$export$f6e2535fb5126e54;
var $608dcd3a9c06507b$export$c3825b437cbdea5c;
var $608dcd3a9c06507b$export$a7884ebc965f8f54;
function $608dcd3a9c06507b$var$isArray(arg) {
    if (Array.isArray) return Array.isArray(arg);
    return $608dcd3a9c06507b$var$objectToString(arg) === "[object Array]";
}
$608dcd3a9c06507b$export$43bee75e5e14138e = $608dcd3a9c06507b$var$isArray;
function $608dcd3a9c06507b$var$isBoolean(arg) {
    return typeof arg === "boolean";
}
$608dcd3a9c06507b$export$f9ce7b637dfbe238 = $608dcd3a9c06507b$var$isBoolean;
function $608dcd3a9c06507b$var$isNull(arg) {
    return arg === null;
}
$608dcd3a9c06507b$export$630801d484da15df = $608dcd3a9c06507b$var$isNull;
function $608dcd3a9c06507b$var$isNullOrUndefined(arg) {
    return arg == null;
}
$608dcd3a9c06507b$export$bedb7023a7733221 = $608dcd3a9c06507b$var$isNullOrUndefined;
function $608dcd3a9c06507b$var$isNumber(arg) {
    return typeof arg === "number";
}
$608dcd3a9c06507b$export$7e4aa119212bc614 = $608dcd3a9c06507b$var$isNumber;
function $608dcd3a9c06507b$var$isString(arg) {
    return typeof arg === "string";
}
$608dcd3a9c06507b$export$844ec244b1367d54 = $608dcd3a9c06507b$var$isString;
function $608dcd3a9c06507b$var$isSymbol(arg) {
    return typeof arg === "symbol";
}
$608dcd3a9c06507b$export$a244864fd9645c7f = $608dcd3a9c06507b$var$isSymbol;
function $608dcd3a9c06507b$var$isUndefined(arg) {
    return arg === void 0;
}
$608dcd3a9c06507b$export$fce6876652108ab = $608dcd3a9c06507b$var$isUndefined;
function $608dcd3a9c06507b$var$isRegExp(re) {
    return $608dcd3a9c06507b$var$objectToString(re) === "[object RegExp]";
}
$608dcd3a9c06507b$export$49841c62b9eff15 = $608dcd3a9c06507b$var$isRegExp;
function $608dcd3a9c06507b$var$isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
$608dcd3a9c06507b$export$a6cdc56e425d0d0a = $608dcd3a9c06507b$var$isObject;
function $608dcd3a9c06507b$var$isDate(d) {
    return $608dcd3a9c06507b$var$objectToString(d) === "[object Date]";
}
$608dcd3a9c06507b$export$871608497c498473 = $608dcd3a9c06507b$var$isDate;
function $608dcd3a9c06507b$var$isError(e) {
    return $608dcd3a9c06507b$var$objectToString(e) === "[object Error]" || e instanceof Error;
}
$608dcd3a9c06507b$export$e6127cc7fe7395c3 = $608dcd3a9c06507b$var$isError;
function $608dcd3a9c06507b$var$isFunction(arg) {
    return typeof arg === "function";
}
$608dcd3a9c06507b$export$f6e2535fb5126e54 = $608dcd3a9c06507b$var$isFunction;
function $608dcd3a9c06507b$var$isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
}
$608dcd3a9c06507b$export$c3825b437cbdea5c = $608dcd3a9c06507b$var$isPrimitive;

$608dcd3a9c06507b$export$a7884ebc965f8f54 = $dAk3n$buffer.Buffer.isBuffer;
function $608dcd3a9c06507b$var$objectToString(o) {
    return Object.prototype.toString.call(o);
}

});

parcelRequire.register("csJOe", function(module, exports) {


try {
    var $912ba2554bae4e03$var$util = $912ba2554bae4e03$import$1706da53f7e85fa1;
    /* istanbul ignore next */ if (typeof $912ba2554bae4e03$var$util.inherits !== "function") throw "";
    module.exports = $912ba2554bae4e03$var$util.inherits;
} catch (e) {
    /* istanbul ignore next */ module.exports = (parcelRequire("ha7kF"));
}

});
parcelRequire.register("ha7kF", function(module, exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

});


parcelRequire.register("g4Z28", function(module, exports) {
"use strict";
function $bb4c5d068d3ba3ce$var$_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

var $34VnU = parcelRequire("34VnU");
var $bb4c5d068d3ba3ce$require$Buffer = $34VnU.Buffer;

function $bb4c5d068d3ba3ce$var$copyBuffer(src, target, offset) {
    src.copy(target, offset);
}
module.exports = function() {
    function BufferList() {
        $bb4c5d068d3ba3ce$var$_classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
        var entry = {
            data: v,
            next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
        var entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
    };
    BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
    };
    BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while(p = p.next)ret += s + p.data;
        return ret;
    };
    BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return $bb4c5d068d3ba3ce$require$Buffer.alloc(0);
        var ret = $bb4c5d068d3ba3ce$require$Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while(p){
            $bb4c5d068d3ba3ce$var$copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    };
    return BufferList;
}();
if ($dAk3n$util && $dAk3n$util.inspect && $dAk3n$util.inspect.custom) module.exports.prototype[$dAk3n$util.inspect.custom] = function() {
    var obj = $dAk3n$util.inspect({
        length: this.length
    });
    return this.constructor.name + " " + obj;
};

});

parcelRequire.register("dSSZ2", function(module, exports) {
"use strict";

var $HWgk4 = parcelRequire("HWgk4");
/*</replacement>*/ // undocumented cb() API, needed for core, not for public API
function $a1baf8191a7e1be4$var$destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) $HWgk4.nextTick($a1baf8191a7e1be4$var$emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                $HWgk4.nextTick($a1baf8191a7e1be4$var$emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) $HWgk4.nextTick($a1baf8191a7e1be4$var$emitErrorNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                $HWgk4.nextTick($a1baf8191a7e1be4$var$emitErrorNT, _this, err);
            }
        } else if (cb) cb(err);
    });
    return this;
}
function $a1baf8191a7e1be4$var$undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function $a1baf8191a7e1be4$var$emitErrorNT(self, err) {
    self.emit("error", err);
}
module.exports = {
    destroy: $a1baf8191a7e1be4$var$destroy,
    undestroy: $a1baf8191a7e1be4$var$undestroy
};

});

parcelRequire.register("bWTaa", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
"use strict";

var $HWgk4 = parcelRequire("HWgk4");
/*</replacement>*/ /*<replacement>*/ var $8b2fe6afaeb240ce$var$objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = $8b2fe6afaeb240ce$var$Duplex;

/*<replacement>*/ var $8b2fe6afaeb240ce$var$util = Object.create((parcelRequire("8hX9Z")));

$8b2fe6afaeb240ce$var$util.inherits = (parcelRequire("csJOe"));

var $iEjYl = parcelRequire("iEjYl");

var $3uSXb = parcelRequire("3uSXb");
$8b2fe6afaeb240ce$var$util.inherits($8b2fe6afaeb240ce$var$Duplex, $iEjYl);
// avoid scope creep, the keys array can then be collected
var $8b2fe6afaeb240ce$var$keys = $8b2fe6afaeb240ce$var$objectKeys($3uSXb.prototype);
for(var $8b2fe6afaeb240ce$var$v = 0; $8b2fe6afaeb240ce$var$v < $8b2fe6afaeb240ce$var$keys.length; $8b2fe6afaeb240ce$var$v++){
    var $8b2fe6afaeb240ce$var$method = $8b2fe6afaeb240ce$var$keys[$8b2fe6afaeb240ce$var$v];
    if (!$8b2fe6afaeb240ce$var$Duplex.prototype[$8b2fe6afaeb240ce$var$method]) $8b2fe6afaeb240ce$var$Duplex.prototype[$8b2fe6afaeb240ce$var$method] = $3uSXb.prototype[$8b2fe6afaeb240ce$var$method];
}
function $8b2fe6afaeb240ce$var$Duplex(options) {
    if (!(this instanceof $8b2fe6afaeb240ce$var$Duplex)) return new $8b2fe6afaeb240ce$var$Duplex(options);
    $iEjYl.call(this, options);
    $3uSXb.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", $8b2fe6afaeb240ce$var$onend);
}
Object.defineProperty($8b2fe6afaeb240ce$var$Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// the no-half-open enforcer
function $8b2fe6afaeb240ce$var$onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    $HWgk4.nextTick($8b2fe6afaeb240ce$var$onEndNT, this);
}
function $8b2fe6afaeb240ce$var$onEndNT(self) {
    self.end();
}
Object.defineProperty($8b2fe6afaeb240ce$var$Duplex.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});
$8b2fe6afaeb240ce$var$Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    $HWgk4.nextTick(cb, err);
};

});
parcelRequire.register("3uSXb", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
"use strict";

var $HWgk4 = parcelRequire("HWgk4");
/*</replacement>*/ module.exports = $28becd1937fce03b$var$Writable;
/* <replacement> */ function $28becd1937fce03b$var$WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function $28becd1937fce03b$var$CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        $28becd1937fce03b$var$onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var $28becd1937fce03b$var$asyncWrite = !process.browser && [
    "v0.10",
    "v0.9."
].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : $HWgk4.nextTick;
/*</replacement>*/ /*<replacement>*/ var $28becd1937fce03b$var$Duplex;
/*</replacement>*/ $28becd1937fce03b$var$Writable.WritableState = $28becd1937fce03b$var$WritableState;

/*<replacement>*/ var $28becd1937fce03b$var$util = Object.create((parcelRequire("8hX9Z")));

$28becd1937fce03b$var$util.inherits = (parcelRequire("csJOe"));

/*</replacement>*/ /*<replacement>*/ var $28becd1937fce03b$var$internalUtil = {
    deprecate: (parcelRequire("kOIq4"))
};

var $98SCi = parcelRequire("98SCi");

var $34VnU = parcelRequire("34VnU");
var $28becd1937fce03b$require$Buffer = $34VnU.Buffer;
var $28becd1937fce03b$var$OurUint8Array = (typeof $parcel$global !== "undefined" ? $parcel$global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function $28becd1937fce03b$var$_uint8ArrayToBuffer(chunk) {
    return $28becd1937fce03b$require$Buffer.from(chunk);
}
function $28becd1937fce03b$var$_isUint8Array(obj) {
    return $28becd1937fce03b$require$Buffer.isBuffer(obj) || obj instanceof $28becd1937fce03b$var$OurUint8Array;
}

var $dSSZ2 = parcelRequire("dSSZ2");
$28becd1937fce03b$var$util.inherits($28becd1937fce03b$var$Writable, $98SCi);
function $28becd1937fce03b$var$nop() {}

function $28becd1937fce03b$var$WritableState(options, stream) {
    $28becd1937fce03b$var$Duplex = $28becd1937fce03b$var$Duplex || (parcelRequire("bWTaa"));
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof $28becd1937fce03b$var$Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16384;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        $28becd1937fce03b$var$onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new $28becd1937fce03b$var$CorkedRequest(this);
}
$28becd1937fce03b$var$WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty($28becd1937fce03b$var$WritableState.prototype, "buffer", {
            get: $28becd1937fce03b$var$internalUtil.deprecate(function() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var $28becd1937fce03b$var$realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    $28becd1937fce03b$var$realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty($28becd1937fce03b$var$Writable, Symbol.hasInstance, {
        value: function(object) {
            if ($28becd1937fce03b$var$realHasInstance.call(this, object)) return true;
            if (this !== $28becd1937fce03b$var$Writable) return false;
            return object && object._writableState instanceof $28becd1937fce03b$var$WritableState;
        }
    });
} else $28becd1937fce03b$var$realHasInstance = function(object) {
    return object instanceof this;
};

function $28becd1937fce03b$var$Writable(options) {
    $28becd1937fce03b$var$Duplex = $28becd1937fce03b$var$Duplex || (parcelRequire("bWTaa"));
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    if (!$28becd1937fce03b$var$realHasInstance.call($28becd1937fce03b$var$Writable, this) && !(this instanceof $28becd1937fce03b$var$Duplex)) return new $28becd1937fce03b$var$Writable(options);
    this._writableState = new $28becd1937fce03b$var$WritableState(options, this);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    $98SCi.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
$28becd1937fce03b$var$Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
};
function $28becd1937fce03b$var$writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit("error", er);
    $HWgk4.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function $28becd1937fce03b$var$validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) er = new TypeError("May not write null values to stream");
    else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new TypeError("Invalid non-string/buffer chunk");
    if (er) {
        stream.emit("error", er);
        $HWgk4.nextTick(cb, er);
        valid = false;
    }
    return valid;
}
$28becd1937fce03b$var$Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && $28becd1937fce03b$var$_isUint8Array(chunk);
    if (isBuf && !$28becd1937fce03b$require$Buffer.isBuffer(chunk)) chunk = $28becd1937fce03b$var$_uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = $28becd1937fce03b$var$nop;
    if (state.ended) $28becd1937fce03b$var$writeAfterEnd(this, cb);
    else if (isBuf || $28becd1937fce03b$var$validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = $28becd1937fce03b$var$writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
$28becd1937fce03b$var$Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
};
$28becd1937fce03b$var$Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) $28becd1937fce03b$var$clearBuffer(this, state);
    }
};
$28becd1937fce03b$var$Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
function $28becd1937fce03b$var$decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = $28becd1937fce03b$require$Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty($28becd1937fce03b$var$Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function $28becd1937fce03b$var$writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = $28becd1937fce03b$var$decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else $28becd1937fce03b$var$doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function $28becd1937fce03b$var$doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function $28becd1937fce03b$var$onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        $HWgk4.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        $HWgk4.nextTick($28becd1937fce03b$var$finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        // this can emit finish, but finish must
        // always follow error
        $28becd1937fce03b$var$finishMaybe(stream, state);
    }
}
function $28becd1937fce03b$var$onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function $28becd1937fce03b$var$onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    $28becd1937fce03b$var$onwriteStateUpdate(state);
    if (er) $28becd1937fce03b$var$onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = $28becd1937fce03b$var$needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) $28becd1937fce03b$var$clearBuffer(stream, state);
        if (sync) /*<replacement>*/ $28becd1937fce03b$var$asyncWrite($28becd1937fce03b$var$afterWrite, stream, state, finished, cb);
        else $28becd1937fce03b$var$afterWrite(stream, state, finished, cb);
    }
}
function $28becd1937fce03b$var$afterWrite(stream, state, finished, cb) {
    if (!finished) $28becd1937fce03b$var$onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    $28becd1937fce03b$var$finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function $28becd1937fce03b$var$onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function $28becd1937fce03b$var$clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        $28becd1937fce03b$var$doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new $28becd1937fce03b$var$CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            $28becd1937fce03b$var$doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
$28becd1937fce03b$var$Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
};
$28becd1937fce03b$var$Writable.prototype._writev = null;
$28becd1937fce03b$var$Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) $28becd1937fce03b$var$endWritable(this, state, cb);
};
function $28becd1937fce03b$var$needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function $28becd1937fce03b$var$callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) stream.emit("error", err);
        state.prefinished = true;
        stream.emit("prefinish");
        $28becd1937fce03b$var$finishMaybe(stream, state);
    });
}
function $28becd1937fce03b$var$prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            $HWgk4.nextTick($28becd1937fce03b$var$callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function $28becd1937fce03b$var$finishMaybe(stream, state) {
    var need = $28becd1937fce03b$var$needFinish(state);
    if (need) {
        $28becd1937fce03b$var$prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
        }
    }
    return need;
}
function $28becd1937fce03b$var$endWritable(stream, state, cb) {
    state.ending = true;
    $28becd1937fce03b$var$finishMaybe(stream, state);
    if (cb) {
        if (state.finished) $HWgk4.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function $28becd1937fce03b$var$onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty($28becd1937fce03b$var$Writable.prototype, "destroyed", {
    get: function() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
$28becd1937fce03b$var$Writable.prototype.destroy = $dSSZ2.destroy;
$28becd1937fce03b$var$Writable.prototype._undestroy = $dSSZ2.undestroy;
$28becd1937fce03b$var$Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
};

});
parcelRequire.register("kOIq4", function(module, exports) {
/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */ 
module.exports = $dAk3n$util.deprecate;

});



parcelRequire.register("1SAK8", function(module, exports) {

$parcel$export(module.exports, "StringDecoder", () => $15e75602ada2cb9b$export$63a7aa211a91ed69, (v) => $15e75602ada2cb9b$export$63a7aa211a91ed69 = v);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
var $15e75602ada2cb9b$export$63a7aa211a91ed69;
"use strict";

var $34VnU = parcelRequire("34VnU");
var $15e75602ada2cb9b$require$Buffer = $34VnU.Buffer;
/*</replacement>*/ var $15e75602ada2cb9b$var$isEncoding = $15e75602ada2cb9b$require$Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function $15e75602ada2cb9b$var$_normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function $15e75602ada2cb9b$var$normalizeEncoding(enc) {
    var nenc = $15e75602ada2cb9b$var$_normalizeEncoding(enc);
    if (typeof nenc !== "string" && ($15e75602ada2cb9b$require$Buffer.isEncoding === $15e75602ada2cb9b$var$isEncoding || !$15e75602ada2cb9b$var$isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
$15e75602ada2cb9b$export$63a7aa211a91ed69 = $15e75602ada2cb9b$var$StringDecoder;
function $15e75602ada2cb9b$var$StringDecoder(encoding) {
    this.encoding = $15e75602ada2cb9b$var$normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = $15e75602ada2cb9b$var$utf16Text;
            this.end = $15e75602ada2cb9b$var$utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = $15e75602ada2cb9b$var$utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = $15e75602ada2cb9b$var$base64Text;
            this.end = $15e75602ada2cb9b$var$base64End;
            nb = 3;
            break;
        default:
            this.write = $15e75602ada2cb9b$var$simpleWrite;
            this.end = $15e75602ada2cb9b$var$simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = $15e75602ada2cb9b$require$Buffer.allocUnsafe(nb);
}
$15e75602ada2cb9b$var$StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
$15e75602ada2cb9b$var$StringDecoder.prototype.end = $15e75602ada2cb9b$var$utf8End;
// Returns only complete characters in a Buffer
$15e75602ada2cb9b$var$StringDecoder.prototype.text = $15e75602ada2cb9b$var$utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
$15e75602ada2cb9b$var$StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function $15e75602ada2cb9b$var$utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function $15e75602ada2cb9b$var$utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = $15e75602ada2cb9b$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = $15e75602ada2cb9b$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = $15e75602ada2cb9b$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function $15e75602ada2cb9b$var$utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "�";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "�";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function $15e75602ada2cb9b$var$utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = $15e75602ada2cb9b$var$utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function $15e75602ada2cb9b$var$utf8Text(buf, i) {
    var total = $15e75602ada2cb9b$var$utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function $15e75602ada2cb9b$var$utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function $15e75602ada2cb9b$var$utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function $15e75602ada2cb9b$var$utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function $15e75602ada2cb9b$var$base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function $15e75602ada2cb9b$var$base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function $15e75602ada2cb9b$var$simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function $15e75602ada2cb9b$var$simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

});


parcelRequire.register("7MnTU", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = $5a9f8e45cb523c2c$var$Transform;

var $bWTaa = parcelRequire("bWTaa");

/*<replacement>*/ var $5a9f8e45cb523c2c$var$util = Object.create((parcelRequire("8hX9Z")));

$5a9f8e45cb523c2c$var$util.inherits = (parcelRequire("csJOe"));
/*</replacement>*/ $5a9f8e45cb523c2c$var$util.inherits($5a9f8e45cb523c2c$var$Transform, $bWTaa);
function $5a9f8e45cb523c2c$var$afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) return this.emit("error", new Error("write callback called multiple times"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function $5a9f8e45cb523c2c$var$Transform(options) {
    if (!(this instanceof $5a9f8e45cb523c2c$var$Transform)) return new $5a9f8e45cb523c2c$var$Transform(options);
    $bWTaa.call(this, options);
    this._transformState = {
        afterTransform: $5a9f8e45cb523c2c$var$afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", $5a9f8e45cb523c2c$var$prefinish);
}
function $5a9f8e45cb523c2c$var$prefinish() {
    var _this = this;
    if (typeof this._flush === "function") this._flush(function(er, data) {
        $5a9f8e45cb523c2c$var$done(_this, er, data);
    });
    else $5a9f8e45cb523c2c$var$done(this, null, null);
}
$5a9f8e45cb523c2c$var$Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return $bWTaa.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
$5a9f8e45cb523c2c$var$Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
};
$5a9f8e45cb523c2c$var$Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
$5a9f8e45cb523c2c$var$Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
$5a9f8e45cb523c2c$var$Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    $bWTaa.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
    });
};
function $5a9f8e45cb523c2c$var$done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) stream.push(data);
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
}

});

parcelRequire.register("jrPuM", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = $e2887bd7c8a4b6ad$var$PassThrough;

var $7MnTU = parcelRequire("7MnTU");

/*<replacement>*/ var $e2887bd7c8a4b6ad$var$util = Object.create((parcelRequire("8hX9Z")));

$e2887bd7c8a4b6ad$var$util.inherits = (parcelRequire("csJOe"));
/*</replacement>*/ $e2887bd7c8a4b6ad$var$util.inherits($e2887bd7c8a4b6ad$var$PassThrough, $7MnTU);
function $e2887bd7c8a4b6ad$var$PassThrough(options) {
    if (!(this instanceof $e2887bd7c8a4b6ad$var$PassThrough)) return new $e2887bd7c8a4b6ad$var$PassThrough(options);
    $7MnTU.call(this, options);
}
$e2887bd7c8a4b6ad$var$PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

});



parcelRequire.register("2uDEU", function(module, exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ 
var $1d0d258c52e87902$var$Buffer = $dAk3n$buffer.Buffer;
// alternative to using Object.keys for old browsers
function $1d0d258c52e87902$var$copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if ($1d0d258c52e87902$var$Buffer.from && $1d0d258c52e87902$var$Buffer.alloc && $1d0d258c52e87902$var$Buffer.allocUnsafe && $1d0d258c52e87902$var$Buffer.allocUnsafeSlow) module.exports = $dAk3n$buffer;
else {
    // Copy properties from require('buffer')
    $1d0d258c52e87902$var$copyProps($dAk3n$buffer, module.exports);
    module.exports.Buffer = $1d0d258c52e87902$var$SafeBuffer;
}
function $1d0d258c52e87902$var$SafeBuffer(arg, encodingOrOffset, length) {
    return $1d0d258c52e87902$var$Buffer(arg, encodingOrOffset, length);
}
$1d0d258c52e87902$var$SafeBuffer.prototype = Object.create($1d0d258c52e87902$var$Buffer.prototype);
// Copy static methods from Buffer
$1d0d258c52e87902$var$copyProps($1d0d258c52e87902$var$Buffer, $1d0d258c52e87902$var$SafeBuffer);
$1d0d258c52e87902$var$SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return $1d0d258c52e87902$var$Buffer(arg, encodingOrOffset, length);
};
$1d0d258c52e87902$var$SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = $1d0d258c52e87902$var$Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
$1d0d258c52e87902$var$SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return $1d0d258c52e87902$var$Buffer(size);
};
$1d0d258c52e87902$var$SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return $dAk3n$buffer.SlowBuffer(size);
};

});


parcelRequire.register("exhnm", function(module, exports) {
module.exports = $a951a034498ac0f1$var$extend;
var $a951a034498ac0f1$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $a951a034498ac0f1$var$extend() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if ($a951a034498ac0f1$var$hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}

});

parcelRequire.register("jUc0O", function(module, exports) {

$parcel$export(module.exports, "decodeLongPath", () => $e7dc90a1f92eea64$export$761ce50369298299, (v) => $e7dc90a1f92eea64$export$761ce50369298299 = v);
$parcel$export(module.exports, "encodePax", () => $e7dc90a1f92eea64$export$14f79099ae1358ea, (v) => $e7dc90a1f92eea64$export$14f79099ae1358ea = v);
$parcel$export(module.exports, "decodePax", () => $e7dc90a1f92eea64$export$7f2688b12909e7f3, (v) => $e7dc90a1f92eea64$export$7f2688b12909e7f3 = v);
$parcel$export(module.exports, "encode", () => $e7dc90a1f92eea64$export$c564cdbbe6da493, (v) => $e7dc90a1f92eea64$export$c564cdbbe6da493 = v);
$parcel$export(module.exports, "decode", () => $e7dc90a1f92eea64$export$2f872c0f2117be69, (v) => $e7dc90a1f92eea64$export$2f872c0f2117be69 = v);
var $e7dc90a1f92eea64$export$761ce50369298299;
var $e7dc90a1f92eea64$export$14f79099ae1358ea;
var $e7dc90a1f92eea64$export$7f2688b12909e7f3;
var $e7dc90a1f92eea64$export$c564cdbbe6da493;
var $e7dc90a1f92eea64$export$2f872c0f2117be69;

var $lqnkI = parcelRequire("lqnkI");

var $6BTvJ = parcelRequire("6BTvJ");
var $e7dc90a1f92eea64$var$ZEROS = "0000000000000000000";
var $e7dc90a1f92eea64$var$SEVENS = "7777777777777777777";
var $e7dc90a1f92eea64$var$ZERO_OFFSET = "0".charCodeAt(0);
var $e7dc90a1f92eea64$var$USTAR = "ustar\x0000";
var $e7dc90a1f92eea64$var$MASK = parseInt("7777", 8);
var $e7dc90a1f92eea64$var$clamp = function(index, len, defaultValue) {
    if (typeof index !== "number") return defaultValue;
    index = ~~index // Coerce to integer.
    ;
    if (index >= len) return len;
    if (index >= 0) return index;
    index += len;
    if (index >= 0) return index;
    return 0;
};
var $e7dc90a1f92eea64$var$toType = function(flag) {
    switch(flag){
        case 0:
            return "file";
        case 1:
            return "link";
        case 2:
            return "symlink";
        case 3:
            return "character-device";
        case 4:
            return "block-device";
        case 5:
            return "directory";
        case 6:
            return "fifo";
        case 7:
            return "contiguous-file";
        case 72:
            return "pax-header";
        case 55:
            return "pax-global-header";
        case 27:
            return "gnu-long-link-path";
        case 28:
        case 30:
            return "gnu-long-path";
    }
    return null;
};
var $e7dc90a1f92eea64$var$toTypeflag = function(flag) {
    switch(flag){
        case "file":
            return 0;
        case "link":
            return 1;
        case "symlink":
            return 2;
        case "character-device":
            return 3;
        case "block-device":
            return 4;
        case "directory":
            return 5;
        case "fifo":
            return 6;
        case "contiguous-file":
            return 7;
        case "pax-header":
            return 72;
    }
    return 0;
};
var $e7dc90a1f92eea64$var$indexOf = function(block, num, offset, end) {
    for(; offset < end; offset++){
        if (block[offset] === num) return offset;
    }
    return end;
};
var $e7dc90a1f92eea64$var$cksum = function(block) {
    var sum = 256;
    for(var i = 0; i < 148; i++)sum += block[i];
    for(var j = 156; j < 512; j++)sum += block[j];
    return sum;
};
var $e7dc90a1f92eea64$var$encodeOct = function(val, n) {
    val = val.toString(8);
    if (val.length > n) return $e7dc90a1f92eea64$var$SEVENS.slice(0, n) + " ";
    else return $e7dc90a1f92eea64$var$ZEROS.slice(0, n - val.length) + val + " ";
};
/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */ function $e7dc90a1f92eea64$var$parse256(buf) {
    // first byte MUST be either 80 or FF
    // 80 for positive, FF for 2's comp
    var positive;
    if (buf[0] === 0x80) positive = true;
    else if (buf[0] === 0xFF) positive = false;
    else return null;
    // build up a base-256 tuple from the least sig to the highest
    var zero = false;
    var tuple = [];
    for(var i = buf.length - 1; i > 0; i--){
        var byte = buf[i];
        if (positive) tuple.push(byte);
        else if (zero && byte === 0) tuple.push(0);
        else if (zero) {
            zero = false;
            tuple.push(0x100 - byte);
        } else tuple.push(0xFF - byte);
    }
    var sum = 0;
    var l = tuple.length;
    for(i = 0; i < l; i++)sum += tuple[i] * Math.pow(256, i);
    return positive ? sum : -1 * sum;
}
var $e7dc90a1f92eea64$var$decodeOct = function(val, offset, length) {
    val = val.slice(offset, offset + length);
    offset = 0;
    // If prefixed with 0x80 then parse as a base-256 integer
    if (val[offset] & 0x80) return $e7dc90a1f92eea64$var$parse256(val);
    else {
        // Older versions of tar can prefix with spaces
        while(offset < val.length && val[offset] === 32)offset++;
        var end = $e7dc90a1f92eea64$var$clamp($e7dc90a1f92eea64$var$indexOf(val, 32, offset, val.length), val.length, val.length);
        while(offset < end && val[offset] === 0)offset++;
        if (end === offset) return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
    }
};
var $e7dc90a1f92eea64$var$decodeStr = function(val, offset, length, encoding) {
    return val.slice(offset, $e7dc90a1f92eea64$var$indexOf(val, 0, offset, offset + length)).toString(encoding);
};
var $e7dc90a1f92eea64$var$addLength = function(str) {
    var len = Buffer.byteLength(str);
    var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits)) digits++;
    return len + digits + str;
};
$e7dc90a1f92eea64$export$761ce50369298299 = function(buf, encoding) {
    return $e7dc90a1f92eea64$var$decodeStr(buf, 0, buf.length, encoding);
};
$e7dc90a1f92eea64$export$14f79099ae1358ea = function(opts) {
    var result = "";
    if (opts.name) result += $e7dc90a1f92eea64$var$addLength(" path=" + opts.name + "\n");
    if (opts.linkname) result += $e7dc90a1f92eea64$var$addLength(" linkpath=" + opts.linkname + "\n");
    var pax = opts.pax;
    if (pax) for(var key in pax)result += $e7dc90a1f92eea64$var$addLength(" " + key + "=" + pax[key] + "\n");
    return $lqnkI(result);
};
$e7dc90a1f92eea64$export$7f2688b12909e7f3 = function(buf) {
    var result = {};
    while(buf.length){
        var i = 0;
        while(i < buf.length && buf[i] !== 32)i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len) return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1) return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
    }
    return result;
};
$e7dc90a1f92eea64$export$c564cdbbe6da493 = function(opts) {
    var buf = $6BTvJ(512);
    var name = opts.name;
    var prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
    if (Buffer.byteLength(name) !== name.length) return null // utf-8
    ;
    while(Buffer.byteLength(name) > 100){
        var i = name.indexOf("/");
        if (i === -1) return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
    }
    if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
    if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
    buf.write(name);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.mode & $e7dc90a1f92eea64$var$MASK, 6), 100);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.uid, 6), 108);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.gid, 6), 116);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.size, 11), 124);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = $e7dc90a1f92eea64$var$ZERO_OFFSET + $e7dc90a1f92eea64$var$toTypeflag(opts.type);
    if (opts.linkname) buf.write(opts.linkname, 157);
    buf.write($e7dc90a1f92eea64$var$USTAR, 257);
    if (opts.uname) buf.write(opts.uname, 265);
    if (opts.gname) buf.write(opts.gname, 297);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.devmajor || 0, 6), 329);
    buf.write($e7dc90a1f92eea64$var$encodeOct(opts.devminor || 0, 6), 337);
    if (prefix) buf.write(prefix, 345);
    buf.write($e7dc90a1f92eea64$var$encodeOct($e7dc90a1f92eea64$var$cksum(buf), 6), 148);
    return buf;
};
$e7dc90a1f92eea64$export$2f872c0f2117be69 = function(buf, filenameEncoding) {
    var typeflag = buf[156] === 0 ? 0 : buf[156] - $e7dc90a1f92eea64$var$ZERO_OFFSET;
    var name = $e7dc90a1f92eea64$var$decodeStr(buf, 0, 100, filenameEncoding);
    var mode = $e7dc90a1f92eea64$var$decodeOct(buf, 100, 8);
    var uid = $e7dc90a1f92eea64$var$decodeOct(buf, 108, 8);
    var gid = $e7dc90a1f92eea64$var$decodeOct(buf, 116, 8);
    var size = $e7dc90a1f92eea64$var$decodeOct(buf, 124, 12);
    var mtime = $e7dc90a1f92eea64$var$decodeOct(buf, 136, 12);
    var type = $e7dc90a1f92eea64$var$toType(typeflag);
    var linkname = buf[157] === 0 ? null : $e7dc90a1f92eea64$var$decodeStr(buf, 157, 100, filenameEncoding);
    var uname = $e7dc90a1f92eea64$var$decodeStr(buf, 265, 32);
    var gname = $e7dc90a1f92eea64$var$decodeStr(buf, 297, 32);
    var devmajor = $e7dc90a1f92eea64$var$decodeOct(buf, 329, 8);
    var devminor = $e7dc90a1f92eea64$var$decodeOct(buf, 337, 8);
    if (buf[345]) name = $e7dc90a1f92eea64$var$decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    // to support old tar versions that use trailing / to indicate dirs
    if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
    var c = $e7dc90a1f92eea64$var$cksum(buf);
    // checksum is still initial value if header was null.
    if (c === 256) return null;
    // valid checksum
    if (c !== $e7dc90a1f92eea64$var$decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    return {
        name: name,
        mode: mode,
        uid: uid,
        gid: gid,
        size: size,
        mtime: new Date(1000 * mtime),
        type: type,
        linkname: linkname,
        uname: uname,
        gname: gname,
        devmajor: devmajor,
        devminor: devminor
    };
};

});
parcelRequire.register("lqnkI", function(module, exports) {
module.exports = $f98e20266bc9c34e$var$toBuffer;
var $f98e20266bc9c34e$var$makeBuffer = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from : $f98e20266bc9c34e$var$bufferFrom;
function $f98e20266bc9c34e$var$bufferFrom(buf, enc) {
    return new Buffer(buf, enc);
}
function $f98e20266bc9c34e$var$toBuffer(buf, enc) {
    if (Buffer.isBuffer(buf)) return buf;
    if (typeof buf === "string") return $f98e20266bc9c34e$var$makeBuffer(buf, enc);
    if (Array.isArray(buf)) return $f98e20266bc9c34e$var$makeBuffer(buf);
    throw new Error("Input should be a buffer or a string");
}

});

parcelRequire.register("6BTvJ", function(module, exports) {

var $jg6b8 = parcelRequire("jg6b8");

var $2AjNp = parcelRequire("2AjNp");
module.exports = function alloc(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be a number');
    if (size < 0) throw new RangeError('"size" argument must not be negative');
    if (Buffer.alloc) return Buffer.alloc(size, fill, encoding);
    var buffer = $2AjNp(size);
    if (size === 0) return buffer;
    if (fill === undefined) return $jg6b8(buffer, 0);
    if (typeof encoding !== "string") encoding = undefined;
    return $jg6b8(buffer, fill, encoding);
};

});
parcelRequire.register("jg6b8", function(module, exports) {
/* Node.js 6.4.0 and up has full support */ var $e0544de8e03ee49e$var$hasFullSupport = function() {
    try {
        if (!Buffer.isEncoding("latin1")) return false;
        var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
        buf.fill("ab", "ucs2");
        return buf.toString("hex") === "61006200";
    } catch (_) {
        return false;
    }
}();
function $e0544de8e03ee49e$var$isSingleByte(val) {
    return val.length === 1 && val.charCodeAt(0) < 256;
}
function $e0544de8e03ee49e$var$fillWithNumber(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) throw new RangeError("Out of range index");
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    if (end > start) buffer.fill(val, start, end);
    return buffer;
}
function $e0544de8e03ee49e$var$fillWithBuffer(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) throw new RangeError("Out of range index");
    if (end <= start) return buffer;
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    var pos = start;
    var len = val.length;
    while(pos <= end - len){
        val.copy(buffer, pos);
        pos += len;
    }
    if (pos !== end) val.copy(buffer, pos, 0, end - pos);
    return buffer;
}
function $e0544de8e03ee49e$var$fill(buffer, val, start, end, encoding) {
    if ($e0544de8e03ee49e$var$hasFullSupport) return buffer.fill(val, start, end, encoding);
    if (typeof val === "number") return $e0544de8e03ee49e$var$fillWithNumber(buffer, val, start, end);
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = buffer.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = buffer.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (encoding === "latin1") encoding = "binary";
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val === "") return $e0544de8e03ee49e$var$fillWithNumber(buffer, 0, start, end);
        if ($e0544de8e03ee49e$var$isSingleByte(val)) return $e0544de8e03ee49e$var$fillWithNumber(buffer, val.charCodeAt(0), start, end);
        val = new Buffer(val, encoding);
    }
    if (Buffer.isBuffer(val)) return $e0544de8e03ee49e$var$fillWithBuffer(buffer, val, start, end);
    // Other values (e.g. undefined, boolean, object) results in zero-fill
    return $e0544de8e03ee49e$var$fillWithNumber(buffer, 0, start, end);
}
module.exports = $e0544de8e03ee49e$var$fill;

});

parcelRequire.register("2AjNp", function(module, exports) {
function $1e1e4ca566871d02$var$allocUnsafe(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be a number');
    if (size < 0) throw new RangeError('"size" argument must not be negative');
    if (Buffer.allocUnsafe) return Buffer.allocUnsafe(size);
    else return new Buffer(size);
}
module.exports = $1e1e4ca566871d02$var$allocUnsafe;

});




parcelRequire.register("9mXEg", function(module, exports) {

var $9XHJH = parcelRequire("9XHJH");

var $KHY5l = parcelRequire("KHY5l");


var $6BTvJ = parcelRequire("6BTvJ");

var $lqnkI = parcelRequire("lqnkI");

var $hDoeW = parcelRequire("hDoeW");
var $6d24700d7e2bfd94$require$Readable = $hDoeW.Readable;

var $hDoeW = parcelRequire("hDoeW");
var $6d24700d7e2bfd94$require$Writable = $hDoeW.Writable;

var $6d24700d7e2bfd94$require$StringDecoder = $dAk3n$string_decoder.StringDecoder;

var $jUc0O = parcelRequire("jUc0O");
var $6d24700d7e2bfd94$var$DMODE = parseInt("755", 8);
var $6d24700d7e2bfd94$var$FMODE = parseInt("644", 8);
var $6d24700d7e2bfd94$var$END_OF_TAR = $6BTvJ(1024);
var $6d24700d7e2bfd94$var$noop = function() {};
var $6d24700d7e2bfd94$var$overflow = function(self, size) {
    size &= 511;
    if (size) self.push($6d24700d7e2bfd94$var$END_OF_TAR.slice(0, 512 - size));
};
function $6d24700d7e2bfd94$var$modeToType(mode) {
    switch(mode & $9XHJH.S_IFMT){
        case $9XHJH.S_IFBLK:
            return "block-device";
        case $9XHJH.S_IFCHR:
            return "character-device";
        case $9XHJH.S_IFDIR:
            return "directory";
        case $9XHJH.S_IFIFO:
            return "fifo";
        case $9XHJH.S_IFLNK:
            return "symlink";
    }
    return "file";
}
var $6d24700d7e2bfd94$var$Sink = function(to) {
    $6d24700d7e2bfd94$require$Writable.call(this);
    this.written = 0;
    this._to = to;
    this._destroyed = false;
};
$dAk3n$util.inherits($6d24700d7e2bfd94$var$Sink, $6d24700d7e2bfd94$require$Writable);
$6d24700d7e2bfd94$var$Sink.prototype._write = function(data, enc, cb) {
    this.written += data.length;
    if (this._to.push(data)) return cb();
    this._to._drain = cb;
};
$6d24700d7e2bfd94$var$Sink.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
};
var $6d24700d7e2bfd94$var$LinkSink = function() {
    $6d24700d7e2bfd94$require$Writable.call(this);
    this.linkname = "";
    this._decoder = new $6d24700d7e2bfd94$require$StringDecoder("utf-8");
    this._destroyed = false;
};
$dAk3n$util.inherits($6d24700d7e2bfd94$var$LinkSink, $6d24700d7e2bfd94$require$Writable);
$6d24700d7e2bfd94$var$LinkSink.prototype._write = function(data, enc, cb) {
    this.linkname += this._decoder.write(data);
    cb();
};
$6d24700d7e2bfd94$var$LinkSink.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
};
var $6d24700d7e2bfd94$var$Void = function() {
    $6d24700d7e2bfd94$require$Writable.call(this);
    this._destroyed = false;
};
$dAk3n$util.inherits($6d24700d7e2bfd94$var$Void, $6d24700d7e2bfd94$require$Writable);
$6d24700d7e2bfd94$var$Void.prototype._write = function(data, enc, cb) {
    cb(new Error("No body allowed for this entry"));
};
$6d24700d7e2bfd94$var$Void.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
};
var $6d24700d7e2bfd94$var$Pack = function(opts) {
    if (!(this instanceof $6d24700d7e2bfd94$var$Pack)) return new $6d24700d7e2bfd94$var$Pack(opts);
    $6d24700d7e2bfd94$require$Readable.call(this, opts);
    this._drain = $6d24700d7e2bfd94$var$noop;
    this._finalized = false;
    this._finalizing = false;
    this._destroyed = false;
    this._stream = null;
};
$dAk3n$util.inherits($6d24700d7e2bfd94$var$Pack, $6d24700d7e2bfd94$require$Readable);
$6d24700d7e2bfd94$var$Pack.prototype.entry = function(header, buffer, callback) {
    if (this._stream) throw new Error("already piping an entry");
    if (this._finalized || this._destroyed) return;
    if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
    }
    if (!callback) callback = $6d24700d7e2bfd94$var$noop;
    var self = this;
    if (!header.size || header.type === "symlink") header.size = 0;
    if (!header.type) header.type = $6d24700d7e2bfd94$var$modeToType(header.mode);
    if (!header.mode) header.mode = header.type === "directory" ? $6d24700d7e2bfd94$var$DMODE : $6d24700d7e2bfd94$var$FMODE;
    if (!header.uid) header.uid = 0;
    if (!header.gid) header.gid = 0;
    if (!header.mtime) header.mtime = new Date();
    if (typeof buffer === "string") buffer = $lqnkI(buffer);
    if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        this.push(buffer);
        $6d24700d7e2bfd94$var$overflow(self, header.size);
        process.nextTick(callback);
        return new $6d24700d7e2bfd94$var$Void();
    }
    if (header.type === "symlink" && !header.linkname) {
        var linkSink = new $6d24700d7e2bfd94$var$LinkSink();
        $KHY5l(linkSink, function(err) {
            if (err) {
                self.destroy();
                return callback(err);
            }
            header.linkname = linkSink.linkname;
            self._encode(header);
            callback();
        });
        return linkSink;
    }
    this._encode(header);
    if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new $6d24700d7e2bfd94$var$Void();
    }
    var sink = new $6d24700d7e2bfd94$var$Sink(this);
    this._stream = sink;
    $KHY5l(sink, function(err) {
        self._stream = null;
        if (err) {
            self.destroy();
            return callback(err);
        }
        if (sink.written !== header.size) {
            self.destroy();
            return callback(new Error("size mismatch"));
        }
        $6d24700d7e2bfd94$var$overflow(self, header.size);
        if (self._finalizing) self.finalize();
        callback();
    });
    return sink;
};
$6d24700d7e2bfd94$var$Pack.prototype.finalize = function() {
    if (this._stream) {
        this._finalizing = true;
        return;
    }
    if (this._finalized) return;
    this._finalized = true;
    this.push($6d24700d7e2bfd94$var$END_OF_TAR);
    this.push(null);
};
$6d24700d7e2bfd94$var$Pack.prototype.destroy = function(err) {
    if (this._destroyed) return;
    this._destroyed = true;
    if (err) this.emit("error", err);
    this.emit("close");
    if (this._stream && this._stream.destroy) this._stream.destroy();
};
$6d24700d7e2bfd94$var$Pack.prototype._encode = function(header) {
    if (!header.pax) {
        var buf = $jUc0O.encode(header);
        if (buf) {
            this.push(buf);
            return;
        }
    }
    this._encodePax(header);
};
$6d24700d7e2bfd94$var$Pack.prototype._encodePax = function(header) {
    var paxHeader = $jUc0O.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
    });
    var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
    };
    this.push($jUc0O.encode(newHeader));
    this.push(paxHeader);
    $6d24700d7e2bfd94$var$overflow(this, paxHeader.length);
    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push($jUc0O.encode(newHeader));
};
$6d24700d7e2bfd94$var$Pack.prototype._read = function(n) {
    var drain = this._drain;
    this._drain = $6d24700d7e2bfd94$var$noop;
    drain();
};
module.exports = $6d24700d7e2bfd94$var$Pack;

});
parcelRequire.register("9XHJH", function(module, exports) {


module.exports = $dAk3n$fs.constants || $dAk3n$constants;

});

parcelRequire.register("KHY5l", function(module, exports) {

var $877nj = parcelRequire("877nj");
var $08c66724e9cabaa1$var$noop = function() {};
var $08c66724e9cabaa1$var$isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
};
var $08c66724e9cabaa1$var$isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};
var $08c66724e9cabaa1$var$eos = function(stream, opts, callback) {
    if (typeof opts === "function") return $08c66724e9cabaa1$var$eos(stream, null, opts);
    if (!opts) opts = {};
    callback = $877nj(callback || $08c66724e9cabaa1$var$noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
    };
    var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
    };
    var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
    };
    var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
        callback.call(stream, err);
    };
    var onclose = function() {
        process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
        stream.req.on("finish", onfinish);
    };
    if ($08c66724e9cabaa1$var$isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if ($08c66724e9cabaa1$var$isChildProcess(stream)) stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
};
module.exports = $08c66724e9cabaa1$var$eos;

});
parcelRequire.register("877nj", function(module, exports) {

var $d0UsB = parcelRequire("d0UsB");
module.exports = $d0UsB($5e84b2b04625ef0b$var$once);
module.exports.strict = $d0UsB($5e84b2b04625ef0b$var$onceStrict);
$5e84b2b04625ef0b$var$once.proto = $5e84b2b04625ef0b$var$once(function() {
    Object.defineProperty(Function.prototype, "once", {
        value: function() {
            return $5e84b2b04625ef0b$var$once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
            return $5e84b2b04625ef0b$var$onceStrict(this);
        },
        configurable: true
    });
});
function $5e84b2b04625ef0b$var$once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function $5e84b2b04625ef0b$var$onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}

});
parcelRequire.register("d0UsB", function(module, exports) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = $9797125180ab4e5a$var$wrappy;
function $9797125180ab4e5a$var$wrappy(fn, cb) {
    if (fn && cb) return $9797125180ab4e5a$var$wrappy(fn)(cb);
    if (typeof fn !== "function") throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i];
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb) Object.keys(cb).forEach(function(k) {
            ret[k] = cb[k];
        });
        return ret;
    }
}

});




parcelRequire.register("6IqSU", function(module, exports) {

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)
exports = module.exports = through;
through.through = through;
//create a readable writable stream.
function through(write, end, opts) {
    write = write || function(data) {
        this.queue(data);
    };
    end = end || function() {
        this.queue(null);
    };
    var ended = false, destroyed = false, buffer = [], _ended = false;
    var stream = new $dAk3n$stream();
    stream.readable = stream.writable = true;
    stream.paused = false;
    //  stream.autoPause   = !(opts && opts.autoPause   === false)
    stream.autoDestroy = !(opts && opts.autoDestroy === false);
    stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
    };
    function drain() {
        while(buffer.length && !stream.paused){
            var data = buffer.shift();
            if (null === data) return stream.emit("end");
            else stream.emit("data", data);
        }
    }
    stream.queue = stream.push = function(data) {
        //    console.error(ended)
        if (_ended) return stream;
        if (data === null) _ended = true;
        buffer.push(data);
        drain();
        return stream;
    };
    //this will be registered as the first 'end' listener
    //must call destroy next tick, to make sure we're after any
    //stream piped from here.
    //this is only a problem if end is not emitted synchronously.
    //a nicer way to do this is to make sure this is the last listener for 'end'
    stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy) process.nextTick(function() {
            stream.destroy();
        });
    });
    function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy) stream.destroy();
    }
    stream.end = function(data) {
        if (ended) return;
        ended = true;
        if (arguments.length) stream.write(data);
        _end() // will emit or queue
        ;
        return stream;
    };
    stream.destroy = function() {
        if (destroyed) return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
    };
    stream.pause = function() {
        if (stream.paused) return;
        stream.paused = true;
        return stream;
    };
    stream.resume = function() {
        if (stream.paused) {
            stream.paused = false;
            stream.emit("resume");
        }
        drain();
        //may have become paused again,
        //as drain emits 'data'.
        if (!stream.paused) stream.emit("drain");
        return stream;
    };
    return stream;
}

});

parcelRequire.register("ekQJU", function(module, exports) {
"use strict";
var $a6fbd7e99ffd87bd$var$PENDING = "pending";
var $a6fbd7e99ffd87bd$var$SETTLED = "settled";
var $a6fbd7e99ffd87bd$var$FULFILLED = "fulfilled";
var $a6fbd7e99ffd87bd$var$REJECTED = "rejected";
var $a6fbd7e99ffd87bd$var$NOOP = function() {};
var $a6fbd7e99ffd87bd$var$isNode = typeof $parcel$global !== "undefined" && typeof $parcel$global.process !== "undefined" && typeof $parcel$global.process.emit === "function";
var $a6fbd7e99ffd87bd$var$asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
var $a6fbd7e99ffd87bd$var$asyncQueue = [];
var $a6fbd7e99ffd87bd$var$asyncTimer;
function $a6fbd7e99ffd87bd$var$asyncFlush() {
    // run promise callbacks
    for(var i = 0; i < $a6fbd7e99ffd87bd$var$asyncQueue.length; i++)$a6fbd7e99ffd87bd$var$asyncQueue[i][0]($a6fbd7e99ffd87bd$var$asyncQueue[i][1]);
    // reset async asyncQueue
    $a6fbd7e99ffd87bd$var$asyncQueue = [];
    $a6fbd7e99ffd87bd$var$asyncTimer = false;
}
function $a6fbd7e99ffd87bd$var$asyncCall(callback, arg) {
    $a6fbd7e99ffd87bd$var$asyncQueue.push([
        callback,
        arg
    ]);
    if (!$a6fbd7e99ffd87bd$var$asyncTimer) {
        $a6fbd7e99ffd87bd$var$asyncTimer = true;
        $a6fbd7e99ffd87bd$var$asyncSetTimer($a6fbd7e99ffd87bd$var$asyncFlush, 0);
    }
}
function $a6fbd7e99ffd87bd$var$invokeResolver(resolver, promise) {
    function resolvePromise(value) {
        $a6fbd7e99ffd87bd$var$resolve(promise, value);
    }
    function rejectPromise(reason) {
        $a6fbd7e99ffd87bd$var$reject(promise, reason);
    }
    try {
        resolver(resolvePromise, rejectPromise);
    } catch (e) {
        rejectPromise(e);
    }
}
function $a6fbd7e99ffd87bd$var$invokeCallback(subscriber) {
    var owner = subscriber.owner;
    var settled = owner._state;
    var value = owner._data;
    var callback = subscriber[settled];
    var promise = subscriber.then;
    if (typeof callback === "function") {
        settled = $a6fbd7e99ffd87bd$var$FULFILLED;
        try {
            value = callback(value);
        } catch (e) {
            $a6fbd7e99ffd87bd$var$reject(promise, e);
        }
    }
    if (!$a6fbd7e99ffd87bd$var$handleThenable(promise, value)) {
        if (settled === $a6fbd7e99ffd87bd$var$FULFILLED) $a6fbd7e99ffd87bd$var$resolve(promise, value);
        if (settled === $a6fbd7e99ffd87bd$var$REJECTED) $a6fbd7e99ffd87bd$var$reject(promise, value);
    }
}
function $a6fbd7e99ffd87bd$var$handleThenable(promise, value) {
    var resolved;
    try {
        if (promise === value) throw new TypeError("A promises callback cannot return that same promise.");
        if (value && (typeof value === "function" || typeof value === "object")) {
            // then should be retrieved only once
            var then = value.then;
            if (typeof then === "function") {
                then.call(value, function(val) {
                    if (!resolved) {
                        resolved = true;
                        if (value === val) $a6fbd7e99ffd87bd$var$fulfill(promise, val);
                        else $a6fbd7e99ffd87bd$var$resolve(promise, val);
                    }
                }, function(reason) {
                    if (!resolved) {
                        resolved = true;
                        $a6fbd7e99ffd87bd$var$reject(promise, reason);
                    }
                });
                return true;
            }
        }
    } catch (e) {
        if (!resolved) $a6fbd7e99ffd87bd$var$reject(promise, e);
        return true;
    }
    return false;
}
function $a6fbd7e99ffd87bd$var$resolve(promise, value) {
    if (promise === value || !$a6fbd7e99ffd87bd$var$handleThenable(promise, value)) $a6fbd7e99ffd87bd$var$fulfill(promise, value);
}
function $a6fbd7e99ffd87bd$var$fulfill(promise, value) {
    if (promise._state === $a6fbd7e99ffd87bd$var$PENDING) {
        promise._state = $a6fbd7e99ffd87bd$var$SETTLED;
        promise._data = value;
        $a6fbd7e99ffd87bd$var$asyncCall($a6fbd7e99ffd87bd$var$publishFulfillment, promise);
    }
}
function $a6fbd7e99ffd87bd$var$reject(promise, reason) {
    if (promise._state === $a6fbd7e99ffd87bd$var$PENDING) {
        promise._state = $a6fbd7e99ffd87bd$var$SETTLED;
        promise._data = reason;
        $a6fbd7e99ffd87bd$var$asyncCall($a6fbd7e99ffd87bd$var$publishRejection, promise);
    }
}
function $a6fbd7e99ffd87bd$var$publish(promise) {
    promise._then = promise._then.forEach($a6fbd7e99ffd87bd$var$invokeCallback);
}
function $a6fbd7e99ffd87bd$var$publishFulfillment(promise) {
    promise._state = $a6fbd7e99ffd87bd$var$FULFILLED;
    $a6fbd7e99ffd87bd$var$publish(promise);
}
function $a6fbd7e99ffd87bd$var$publishRejection(promise) {
    promise._state = $a6fbd7e99ffd87bd$var$REJECTED;
    $a6fbd7e99ffd87bd$var$publish(promise);
    if (!promise._handled && $a6fbd7e99ffd87bd$var$isNode) $parcel$global.process.emit("unhandledRejection", promise._data, promise);
}
function $a6fbd7e99ffd87bd$var$notifyRejectionHandled(promise) {
    $parcel$global.process.emit("rejectionHandled", promise);
}
/**
 * @class
 */ function $a6fbd7e99ffd87bd$var$Promise(resolver) {
    if (typeof resolver !== "function") throw new TypeError("Promise resolver " + resolver + " is not a function");
    if (this instanceof $a6fbd7e99ffd87bd$var$Promise === false) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    this._then = [];
    $a6fbd7e99ffd87bd$var$invokeResolver(resolver, this);
}
$a6fbd7e99ffd87bd$var$Promise.prototype = {
    constructor: $a6fbd7e99ffd87bd$var$Promise,
    _state: $a6fbd7e99ffd87bd$var$PENDING,
    _then: null,
    _data: undefined,
    _handled: false,
    then: function(onFulfillment, onRejection) {
        var subscriber = {
            owner: this,
            then: new this.constructor($a6fbd7e99ffd87bd$var$NOOP),
            fulfilled: onFulfillment,
            rejected: onRejection
        };
        if ((onRejection || onFulfillment) && !this._handled) {
            this._handled = true;
            if (this._state === $a6fbd7e99ffd87bd$var$REJECTED && $a6fbd7e99ffd87bd$var$isNode) $a6fbd7e99ffd87bd$var$asyncCall($a6fbd7e99ffd87bd$var$notifyRejectionHandled, this);
        }
        if (this._state === $a6fbd7e99ffd87bd$var$FULFILLED || this._state === $a6fbd7e99ffd87bd$var$REJECTED) // already resolved, call callback async
        $a6fbd7e99ffd87bd$var$asyncCall($a6fbd7e99ffd87bd$var$invokeCallback, subscriber);
        else // subscribe
        this._then.push(subscriber);
        return subscriber.then;
    },
    catch: function(onRejection) {
        return this.then(null, onRejection);
    }
};
$a6fbd7e99ffd87bd$var$Promise.all = function(promises) {
    if (!Array.isArray(promises)) throw new TypeError("You must pass an array to Promise.all().");
    return new $a6fbd7e99ffd87bd$var$Promise(function(resolve, reject) {
        var results = [];
        var remaining = 0;
        function resolver(index) {
            remaining++;
            return function(value) {
                results[index] = value;
                if (!--remaining) resolve(results);
            };
        }
        for(var i = 0, promise; i < promises.length; i++){
            promise = promises[i];
            if (promise && typeof promise.then === "function") promise.then(resolver(i), reject);
            else results[i] = promise;
        }
        if (!remaining) resolve(results);
    });
};
$a6fbd7e99ffd87bd$var$Promise.race = function(promises) {
    if (!Array.isArray(promises)) throw new TypeError("You must pass an array to Promise.race().");
    return new $a6fbd7e99ffd87bd$var$Promise(function(resolve, reject) {
        for(var i = 0, promise; i < promises.length; i++){
            promise = promises[i];
            if (promise && typeof promise.then === "function") promise.then(resolve, reject);
            else resolve(promise);
        }
    });
};
$a6fbd7e99ffd87bd$var$Promise.resolve = function(value) {
    if (value && typeof value === "object" && value.constructor === $a6fbd7e99ffd87bd$var$Promise) return value;
    return new $a6fbd7e99ffd87bd$var$Promise(function(resolve) {
        resolve(value);
    });
};
$a6fbd7e99ffd87bd$var$Promise.reject = function(reason) {
    return new $a6fbd7e99ffd87bd$var$Promise(function(resolve, reject) {
        reject(reason);
    });
};
module.exports = $a6fbd7e99ffd87bd$var$Promise;

});

parcelRequire.register("kQK5c", function(module, exports) {
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

});

parcelRequire.register("jB1CW", function(module, exports) {
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
];
if (process.platform !== "win32") module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
if (process.platform === "linux") module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");

});

parcelRequire.register("6SGoC", function(module, exports) {
module.exports = JSON.parse('{"dots":{"interval":80,"frames":["⠋","⠙","⠹","⠸","⠼","⠴","⠦","⠧","⠇","⠏"]},"dots2":{"interval":80,"frames":["⣾","⣽","⣻","⢿","⡿","⣟","⣯","⣷"]},"dots3":{"interval":80,"frames":["⠋","⠙","⠚","⠞","⠖","⠦","⠴","⠲","⠳","⠓"]},"dots4":{"interval":80,"frames":["⠄","⠆","⠇","⠋","⠙","⠸","⠰","⠠","⠰","⠸","⠙","⠋","⠇","⠆"]},"dots5":{"interval":80,"frames":["⠋","⠙","⠚","⠒","⠂","⠂","⠒","⠲","⠴","⠦","⠖","⠒","⠐","⠐","⠒","⠓","⠋"]},"dots6":{"interval":80,"frames":["⠁","⠉","⠙","⠚","⠒","⠂","⠂","⠒","⠲","⠴","⠤","⠄","⠄","⠤","⠴","⠲","⠒","⠂","⠂","⠒","⠚","⠙","⠉","⠁"]},"dots7":{"interval":80,"frames":["⠈","⠉","⠋","⠓","⠒","⠐","⠐","⠒","⠖","⠦","⠤","⠠","⠠","⠤","⠦","⠖","⠒","⠐","⠐","⠒","⠓","⠋","⠉","⠈"]},"dots8":{"interval":80,"frames":["⠁","⠁","⠉","⠙","⠚","⠒","⠂","⠂","⠒","⠲","⠴","⠤","⠄","⠄","⠤","⠠","⠠","⠤","⠦","⠖","⠒","⠐","⠐","⠒","⠓","⠋","⠉","⠈","⠈"]},"dots9":{"interval":80,"frames":["⢹","⢺","⢼","⣸","⣇","⡧","⡗","⡏"]},"dots10":{"interval":80,"frames":["⢄","⢂","⢁","⡁","⡈","⡐","⡠"]},"dots11":{"interval":100,"frames":["⠁","⠂","⠄","⡀","⢀","⠠","⠐","⠈"]},"dots12":{"interval":80,"frames":["⢀⠀","⡀⠀","⠄⠀","⢂⠀","⡂⠀","⠅⠀","⢃⠀","⡃⠀","⠍⠀","⢋⠀","⡋⠀","⠍⠁","⢋⠁","⡋⠁","⠍⠉","⠋⠉","⠋⠉","⠉⠙","⠉⠙","⠉⠩","⠈⢙","⠈⡙","⢈⠩","⡀⢙","⠄⡙","⢂⠩","⡂⢘","⠅⡘","⢃⠨","⡃⢐","⠍⡐","⢋⠠","⡋⢀","⠍⡁","⢋⠁","⡋⠁","⠍⠉","⠋⠉","⠋⠉","⠉⠙","⠉⠙","⠉⠩","⠈⢙","⠈⡙","⠈⠩","⠀⢙","⠀⡙","⠀⠩","⠀⢘","⠀⡘","⠀⠨","⠀⢐","⠀⡐","⠀⠠","⠀⢀","⠀⡀"]},"dots13":{"interval":80,"frames":["⣼","⣹","⢻","⠿","⡟","⣏","⣧","⣶"]},"dots8Bit":{"interval":80,"frames":["⠀","⠁","⠂","⠃","⠄","⠅","⠆","⠇","⡀","⡁","⡂","⡃","⡄","⡅","⡆","⡇","⠈","⠉","⠊","⠋","⠌","⠍","⠎","⠏","⡈","⡉","⡊","⡋","⡌","⡍","⡎","⡏","⠐","⠑","⠒","⠓","⠔","⠕","⠖","⠗","⡐","⡑","⡒","⡓","⡔","⡕","⡖","⡗","⠘","⠙","⠚","⠛","⠜","⠝","⠞","⠟","⡘","⡙","⡚","⡛","⡜","⡝","⡞","⡟","⠠","⠡","⠢","⠣","⠤","⠥","⠦","⠧","⡠","⡡","⡢","⡣","⡤","⡥","⡦","⡧","⠨","⠩","⠪","⠫","⠬","⠭","⠮","⠯","⡨","⡩","⡪","⡫","⡬","⡭","⡮","⡯","⠰","⠱","⠲","⠳","⠴","⠵","⠶","⠷","⡰","⡱","⡲","⡳","⡴","⡵","⡶","⡷","⠸","⠹","⠺","⠻","⠼","⠽","⠾","⠿","⡸","⡹","⡺","⡻","⡼","⡽","⡾","⡿","⢀","⢁","⢂","⢃","⢄","⢅","⢆","⢇","⣀","⣁","⣂","⣃","⣄","⣅","⣆","⣇","⢈","⢉","⢊","⢋","⢌","⢍","⢎","⢏","⣈","⣉","⣊","⣋","⣌","⣍","⣎","⣏","⢐","⢑","⢒","⢓","⢔","⢕","⢖","⢗","⣐","⣑","⣒","⣓","⣔","⣕","⣖","⣗","⢘","⢙","⢚","⢛","⢜","⢝","⢞","⢟","⣘","⣙","⣚","⣛","⣜","⣝","⣞","⣟","⢠","⢡","⢢","⢣","⢤","⢥","⢦","⢧","⣠","⣡","⣢","⣣","⣤","⣥","⣦","⣧","⢨","⢩","⢪","⢫","⢬","⢭","⢮","⢯","⣨","⣩","⣪","⣫","⣬","⣭","⣮","⣯","⢰","⢱","⢲","⢳","⢴","⢵","⢶","⢷","⣰","⣱","⣲","⣳","⣴","⣵","⣶","⣷","⢸","⢹","⢺","⢻","⢼","⢽","⢾","⢿","⣸","⣹","⣺","⣻","⣼","⣽","⣾","⣿"]},"sand":{"interval":80,"frames":["⠁","⠂","⠄","⡀","⡈","⡐","⡠","⣀","⣁","⣂","⣄","⣌","⣔","⣤","⣥","⣦","⣮","⣶","⣷","⣿","⡿","⠿","⢟","⠟","⡛","⠛","⠫","⢋","⠋","⠍","⡉","⠉","⠑","⠡","⢁"]},"line":{"interval":130,"frames":["-","\\\\","|","/"]},"line2":{"interval":100,"frames":["⠂","-","–","—","–","-"]},"pipe":{"interval":100,"frames":["┤","┘","┴","└","├","┌","┬","┐"]},"simpleDots":{"interval":400,"frames":[".  ",".. ","...","   "]},"simpleDotsScrolling":{"interval":200,"frames":[".  ",".. ","..."," ..","  .","   "]},"star":{"interval":70,"frames":["✶","✸","✹","✺","✹","✷"]},"star2":{"interval":80,"frames":["+","x","*"]},"flip":{"interval":70,"frames":["_","_","_","-","`","`","\'","\xb4","-","_","_","_"]},"hamburger":{"interval":100,"frames":["☱","☲","☴"]},"growVertical":{"interval":120,"frames":["▁","▃","▄","▅","▆","▇","▆","▅","▄","▃"]},"growHorizontal":{"interval":120,"frames":["▏","▎","▍","▌","▋","▊","▉","▊","▋","▌","▍","▎"]},"balloon":{"interval":140,"frames":[" ",".","o","O","@","*"," "]},"balloon2":{"interval":120,"frames":[".","o","O","\xb0","O","o","."]},"noise":{"interval":100,"frames":["▓","▒","░"]},"bounce":{"interval":120,"frames":["⠁","⠂","⠄","⠂"]},"boxBounce":{"interval":120,"frames":["▖","▘","▝","▗"]},"boxBounce2":{"interval":100,"frames":["▌","▀","▐","▄"]},"triangle":{"interval":50,"frames":["◢","◣","◤","◥"]},"binary":{"interval":80,"frames":["010010","001100","100101","111010","111101","010111","101011","111000","110011","110101"]},"arc":{"interval":100,"frames":["◜","◠","◝","◞","◡","◟"]},"circle":{"interval":120,"frames":["◡","⊙","◠"]},"squareCorners":{"interval":180,"frames":["◰","◳","◲","◱"]},"circleQuarters":{"interval":120,"frames":["◴","◷","◶","◵"]},"circleHalves":{"interval":50,"frames":["◐","◓","◑","◒"]},"squish":{"interval":100,"frames":["╫","╪"]},"toggle":{"interval":250,"frames":["⊶","⊷"]},"toggle2":{"interval":80,"frames":["▫","▪"]},"toggle3":{"interval":120,"frames":["□","■"]},"toggle4":{"interval":100,"frames":["■","□","▪","▫"]},"toggle5":{"interval":100,"frames":["▮","▯"]},"toggle6":{"interval":300,"frames":["ဝ","၀"]},"toggle7":{"interval":80,"frames":["⦾","⦿"]},"toggle8":{"interval":100,"frames":["◍","◌"]},"toggle9":{"interval":100,"frames":["◉","◎"]},"toggle10":{"interval":100,"frames":["㊂","㊀","㊁"]},"toggle11":{"interval":50,"frames":["⧇","⧆"]},"toggle12":{"interval":120,"frames":["☗","☖"]},"toggle13":{"interval":80,"frames":["=","*","-"]},"arrow":{"interval":100,"frames":["←","↖","↑","↗","→","↘","↓","↙"]},"arrow2":{"interval":80,"frames":["⬆️ ","↗️ ","➡️ ","↘️ ","⬇️ ","↙️ ","⬅️ ","↖️ "]},"arrow3":{"interval":120,"frames":["▹▹▹▹▹","▸▹▹▹▹","▹▸▹▹▹","▹▹▸▹▹","▹▹▹▸▹","▹▹▹▹▸"]},"bouncingBar":{"interval":80,"frames":["[    ]","[=   ]","[==  ]","[=== ]","[ ===]","[  ==]","[   =]","[    ]","[   =]","[  ==]","[ ===]","[====]","[=== ]","[==  ]","[=   ]"]},"bouncingBall":{"interval":80,"frames":["( ●    )","(  ●   )","(   ●  )","(    ● )","(     ●)","(    ● )","(   ●  )","(  ●   )","( ●    )","(●     )"]},"smiley":{"interval":200,"frames":["\uD83D\uDE04 ","\uD83D\uDE1D "]},"monkey":{"interval":300,"frames":["\uD83D\uDE48 ","\uD83D\uDE48 ","\uD83D\uDE49 ","\uD83D\uDE4A "]},"hearts":{"interval":100,"frames":["\uD83D\uDC9B ","\uD83D\uDC99 ","\uD83D\uDC9C ","\uD83D\uDC9A ","❤️ "]},"clock":{"interval":100,"frames":["\uD83D\uDD5B ","\uD83D\uDD50 ","\uD83D\uDD51 ","\uD83D\uDD52 ","\uD83D\uDD53 ","\uD83D\uDD54 ","\uD83D\uDD55 ","\uD83D\uDD56 ","\uD83D\uDD57 ","\uD83D\uDD58 ","\uD83D\uDD59 ","\uD83D\uDD5A "]},"earth":{"interval":180,"frames":["\uD83C\uDF0D ","\uD83C\uDF0E ","\uD83C\uDF0F "]},"material":{"interval":17,"frames":["█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","███▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","████▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁","██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁","███████▁▁▁▁▁▁▁▁▁▁▁▁▁","████████▁▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","██████████▁▁▁▁▁▁▁▁▁▁","███████████▁▁▁▁▁▁▁▁▁","█████████████▁▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁▁██████████████▁▁▁▁","▁▁▁██████████████▁▁▁","▁▁▁▁█████████████▁▁▁","▁▁▁▁██████████████▁▁","▁▁▁▁██████████████▁▁","▁▁▁▁▁██████████████▁","▁▁▁▁▁██████████████▁","▁▁▁▁▁██████████████▁","▁▁▁▁▁▁██████████████","▁▁▁▁▁▁██████████████","▁▁▁▁▁▁▁█████████████","▁▁▁▁▁▁▁█████████████","▁▁▁▁▁▁▁▁████████████","▁▁▁▁▁▁▁▁████████████","▁▁▁▁▁▁▁▁▁███████████","▁▁▁▁▁▁▁▁▁███████████","▁▁▁▁▁▁▁▁▁▁██████████","▁▁▁▁▁▁▁▁▁▁██████████","▁▁▁▁▁▁▁▁▁▁▁▁████████","▁▁▁▁▁▁▁▁▁▁▁▁▁███████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁██████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████","█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","███▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","████▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","██████▁▁▁▁▁▁▁▁▁▁▁▁▁█","████████▁▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","███████████▁▁▁▁▁▁▁▁▁","████████████▁▁▁▁▁▁▁▁","████████████▁▁▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁▁▁█████████████▁▁▁▁","▁▁▁▁▁████████████▁▁▁","▁▁▁▁▁████████████▁▁▁","▁▁▁▁▁▁███████████▁▁▁","▁▁▁▁▁▁▁▁█████████▁▁▁","▁▁▁▁▁▁▁▁█████████▁▁▁","▁▁▁▁▁▁▁▁▁█████████▁▁","▁▁▁▁▁▁▁▁▁█████████▁▁","▁▁▁▁▁▁▁▁▁▁█████████▁","▁▁▁▁▁▁▁▁▁▁▁████████▁","▁▁▁▁▁▁▁▁▁▁▁████████▁","▁▁▁▁▁▁▁▁▁▁▁▁███████▁","▁▁▁▁▁▁▁▁▁▁▁▁███████▁","▁▁▁▁▁▁▁▁▁▁▁▁▁███████","▁▁▁▁▁▁▁▁▁▁▁▁▁███████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁"]},"moon":{"interval":80,"frames":["\uD83C\uDF11 ","\uD83C\uDF12 ","\uD83C\uDF13 ","\uD83C\uDF14 ","\uD83C\uDF15 ","\uD83C\uDF16 ","\uD83C\uDF17 ","\uD83C\uDF18 "]},"runner":{"interval":140,"frames":["\uD83D\uDEB6 ","\uD83C\uDFC3 "]},"pong":{"interval":80,"frames":["▐⠂       ▌","▐⠈       ▌","▐ ⠂      ▌","▐ ⠠      ▌","▐  ⡀     ▌","▐  ⠠     ▌","▐   ⠂    ▌","▐   ⠈    ▌","▐    ⠂   ▌","▐    ⠠   ▌","▐     ⡀  ▌","▐     ⠠  ▌","▐      ⠂ ▌","▐      ⠈ ▌","▐       ⠂▌","▐       ⠠▌","▐       ⡀▌","▐      ⠠ ▌","▐      ⠂ ▌","▐     ⠈  ▌","▐     ⠂  ▌","▐    ⠠   ▌","▐    ⡀   ▌","▐   ⠠    ▌","▐   ⠂    ▌","▐  ⠈     ▌","▐  ⠂     ▌","▐ ⠠      ▌","▐ ⡀      ▌","▐⠠       ▌"]},"shark":{"interval":120,"frames":["▐|\\\\____________▌","▐_|\\\\___________▌","▐__|\\\\__________▌","▐___|\\\\_________▌","▐____|\\\\________▌","▐_____|\\\\_______▌","▐______|\\\\______▌","▐_______|\\\\_____▌","▐________|\\\\____▌","▐_________|\\\\___▌","▐__________|\\\\__▌","▐___________|\\\\_▌","▐____________|\\\\▌","▐____________/|▌","▐___________/|_▌","▐__________/|__▌","▐_________/|___▌","▐________/|____▌","▐_______/|_____▌","▐______/|______▌","▐_____/|_______▌","▐____/|________▌","▐___/|_________▌","▐__/|__________▌","▐_/|___________▌","▐/|____________▌"]},"dqpb":{"interval":100,"frames":["d","q","p","b"]},"weather":{"interval":100,"frames":["☀️ ","☀️ ","☀️ ","\uD83C\uDF24 ","⛅️ ","\uD83C\uDF25 ","☁️ ","\uD83C\uDF27 ","\uD83C\uDF28 ","\uD83C\uDF27 ","\uD83C\uDF28 ","\uD83C\uDF27 ","\uD83C\uDF28 ","⛈ ","\uD83C\uDF28 ","\uD83C\uDF27 ","\uD83C\uDF28 ","☁️ ","\uD83C\uDF25 ","⛅️ ","\uD83C\uDF24 ","☀️ ","☀️ "]},"christmas":{"interval":400,"frames":["\uD83C\uDF32","\uD83C\uDF84"]},"grenade":{"interval":80,"frames":["،  ","′  "," \xb4 "," ‾ ","  ⸌","  ⸊","  |","  ⁎","  ⁕"," ෴ ","  ⁓","   ","   ","   "]},"point":{"interval":125,"frames":["∙∙∙","●∙∙","∙●∙","∙∙●","∙∙∙"]},"layer":{"interval":150,"frames":["-","=","≡"]},"betaWave":{"interval":80,"frames":["ρββββββ","βρβββββ","ββρββββ","βββρβββ","ββββρββ","βββββρβ","ββββββρ"]},"fingerDance":{"interval":160,"frames":["\uD83E\uDD18 ","\uD83E\uDD1F ","\uD83D\uDD96 ","✋ ","\uD83E\uDD1A ","\uD83D\uDC46 "]},"fistBump":{"interval":80,"frames":["\uD83E\uDD1C　　　　\uD83E\uDD1B ","\uD83E\uDD1C　　　　\uD83E\uDD1B ","\uD83E\uDD1C　　　　\uD83E\uDD1B ","　\uD83E\uDD1C　　\uD83E\uDD1B　 ","　　\uD83E\uDD1C\uD83E\uDD1B　　 ","　\uD83E\uDD1C✨\uD83E\uDD1B　　 ","\uD83E\uDD1C　✨　\uD83E\uDD1B　 "]},"soccerHeader":{"interval":80,"frames":[" \uD83E\uDDD1⚽️       \uD83E\uDDD1 ","\uD83E\uDDD1  ⚽️      \uD83E\uDDD1 ","\uD83E\uDDD1   ⚽️     \uD83E\uDDD1 ","\uD83E\uDDD1    ⚽️    \uD83E\uDDD1 ","\uD83E\uDDD1     ⚽️   \uD83E\uDDD1 ","\uD83E\uDDD1      ⚽️  \uD83E\uDDD1 ","\uD83E\uDDD1       ⚽️\uD83E\uDDD1  ","\uD83E\uDDD1      ⚽️  \uD83E\uDDD1 ","\uD83E\uDDD1     ⚽️   \uD83E\uDDD1 ","\uD83E\uDDD1    ⚽️    \uD83E\uDDD1 ","\uD83E\uDDD1   ⚽️     \uD83E\uDDD1 ","\uD83E\uDDD1  ⚽️      \uD83E\uDDD1 "]},"mindblown":{"interval":160,"frames":["\uD83D\uDE10 ","\uD83D\uDE10 ","\uD83D\uDE2E ","\uD83D\uDE2E ","\uD83D\uDE26 ","\uD83D\uDE26 ","\uD83D\uDE27 ","\uD83D\uDE27 ","\uD83E\uDD2F ","\uD83D\uDCA5 ","✨ ","　 ","　 ","　 "]},"speaker":{"interval":160,"frames":["\uD83D\uDD08 ","\uD83D\uDD09 ","\uD83D\uDD0A ","\uD83D\uDD09 "]},"orangePulse":{"interval":100,"frames":["\uD83D\uDD38 ","\uD83D\uDD36 ","\uD83D\uDFE0 ","\uD83D\uDFE0 ","\uD83D\uDD36 "]},"bluePulse":{"interval":100,"frames":["\uD83D\uDD39 ","\uD83D\uDD37 ","\uD83D\uDD35 ","\uD83D\uDD35 ","\uD83D\uDD37 "]},"orangeBluePulse":{"interval":100,"frames":["\uD83D\uDD38 ","\uD83D\uDD36 ","\uD83D\uDFE0 ","\uD83D\uDFE0 ","\uD83D\uDD36 ","\uD83D\uDD39 ","\uD83D\uDD37 ","\uD83D\uDD35 ","\uD83D\uDD35 ","\uD83D\uDD37 "]},"timeTravel":{"interval":100,"frames":["\uD83D\uDD5B ","\uD83D\uDD5A ","\uD83D\uDD59 ","\uD83D\uDD58 ","\uD83D\uDD57 ","\uD83D\uDD56 ","\uD83D\uDD55 ","\uD83D\uDD54 ","\uD83D\uDD53 ","\uD83D\uDD52 ","\uD83D\uDD51 ","\uD83D\uDD50 "]},"aesthetic":{"interval":80,"frames":["▰▱▱▱▱▱▱","▰▰▱▱▱▱▱","▰▰▰▱▱▱▱","▰▰▰▰▱▱▱","▰▰▰▰▰▱▱","▰▰▰▰▰▰▱","▰▰▰▰▰▰▰","▰▱▱▱▱▱▱"]},"dwarfFortress":{"interval":80,"frames":[" ██████\xa3\xa3\xa3  ","☺██████\xa3\xa3\xa3  ","☺██████\xa3\xa3\xa3  ","☺▓█████\xa3\xa3\xa3  ","☺▓█████\xa3\xa3\xa3  ","☺▒█████\xa3\xa3\xa3  ","☺▒█████\xa3\xa3\xa3  ","☺░█████\xa3\xa3\xa3  ","☺░█████\xa3\xa3\xa3  ","☺ █████\xa3\xa3\xa3  "," ☺█████\xa3\xa3\xa3  "," ☺█████\xa3\xa3\xa3  "," ☺▓████\xa3\xa3\xa3  "," ☺▓████\xa3\xa3\xa3  "," ☺▒████\xa3\xa3\xa3  "," ☺▒████\xa3\xa3\xa3  "," ☺░████\xa3\xa3\xa3  "," ☺░████\xa3\xa3\xa3  "," ☺ ████\xa3\xa3\xa3  ","  ☺████\xa3\xa3\xa3  ","  ☺████\xa3\xa3\xa3  ","  ☺▓███\xa3\xa3\xa3  ","  ☺▓███\xa3\xa3\xa3  ","  ☺▒███\xa3\xa3\xa3  ","  ☺▒███\xa3\xa3\xa3  ","  ☺░███\xa3\xa3\xa3  ","  ☺░███\xa3\xa3\xa3  ","  ☺ ███\xa3\xa3\xa3  ","   ☺███\xa3\xa3\xa3  ","   ☺███\xa3\xa3\xa3  ","   ☺▓██\xa3\xa3\xa3  ","   ☺▓██\xa3\xa3\xa3  ","   ☺▒██\xa3\xa3\xa3  ","   ☺▒██\xa3\xa3\xa3  ","   ☺░██\xa3\xa3\xa3  ","   ☺░██\xa3\xa3\xa3  ","   ☺ ██\xa3\xa3\xa3  ","    ☺██\xa3\xa3\xa3  ","    ☺██\xa3\xa3\xa3  ","    ☺▓█\xa3\xa3\xa3  ","    ☺▓█\xa3\xa3\xa3  ","    ☺▒█\xa3\xa3\xa3  ","    ☺▒█\xa3\xa3\xa3  ","    ☺░█\xa3\xa3\xa3  ","    ☺░█\xa3\xa3\xa3  ","    ☺ █\xa3\xa3\xa3  ","     ☺█\xa3\xa3\xa3  ","     ☺█\xa3\xa3\xa3  ","     ☺▓\xa3\xa3\xa3  ","     ☺▓\xa3\xa3\xa3  ","     ☺▒\xa3\xa3\xa3  ","     ☺▒\xa3\xa3\xa3  ","     ☺░\xa3\xa3\xa3  ","     ☺░\xa3\xa3\xa3  ","     ☺ \xa3\xa3\xa3  ","      ☺\xa3\xa3\xa3  ","      ☺\xa3\xa3\xa3  ","      ☺▓\xa3\xa3  ","      ☺▓\xa3\xa3  ","      ☺▒\xa3\xa3  ","      ☺▒\xa3\xa3  ","      ☺░\xa3\xa3  ","      ☺░\xa3\xa3  ","      ☺ \xa3\xa3  ","       ☺\xa3\xa3  ","       ☺\xa3\xa3  ","       ☺▓\xa3  ","       ☺▓\xa3  ","       ☺▒\xa3  ","       ☺▒\xa3  ","       ☺░\xa3  ","       ☺░\xa3  ","       ☺ \xa3  ","        ☺\xa3  ","        ☺\xa3  ","        ☺▓  ","        ☺▓  ","        ☺▒  ","        ☺▒  ","        ☺░  ","        ☺░  ","        ☺   ","        ☺  &","        ☺ ☼&","       ☺ ☼ &","       ☺☼  &","      ☺☼  & ","      ‼   & ","     ☺   &  ","    ‼    &  ","   ☺    &   ","  ‼     &   "," ☺     &    ","‼      &    ","      &     ","      &     ","     &   ░  ","     &   ▒  ","    &    ▓  ","    &    \xa3  ","   &    ░\xa3  ","   &    ▒\xa3  ","  &     ▓\xa3  ","  &     \xa3\xa3  "," &     ░\xa3\xa3  "," &     ▒\xa3\xa3  ","&      ▓\xa3\xa3  ","&      \xa3\xa3\xa3  ","      ░\xa3\xa3\xa3  ","      ▒\xa3\xa3\xa3  ","      ▓\xa3\xa3\xa3  ","      █\xa3\xa3\xa3  ","     ░█\xa3\xa3\xa3  ","     ▒█\xa3\xa3\xa3  ","     ▓█\xa3\xa3\xa3  ","     ██\xa3\xa3\xa3  ","    ░██\xa3\xa3\xa3  ","    ▒██\xa3\xa3\xa3  ","    ▓██\xa3\xa3\xa3  ","    ███\xa3\xa3\xa3  ","   ░███\xa3\xa3\xa3  ","   ▒███\xa3\xa3\xa3  ","   ▓███\xa3\xa3\xa3  ","   ████\xa3\xa3\xa3  ","  ░████\xa3\xa3\xa3  ","  ▒████\xa3\xa3\xa3  ","  ▓████\xa3\xa3\xa3  ","  █████\xa3\xa3\xa3  "," ░█████\xa3\xa3\xa3  "," ▒█████\xa3\xa3\xa3  "," ▓█████\xa3\xa3\xa3  "," ██████\xa3\xa3\xa3  "," ██████\xa3\xa3\xa3  "]}}');

});

parcelRequire.register("9FpLB", function(module, exports) {








if (process.env.READABLE_STREAM === "disable" && $dAk3n$stream) {
    module.exports = $dAk3n$stream.Readable;
    Object.assign(module.exports, $dAk3n$stream);
    module.exports.Stream = $dAk3n$stream;
} else {
    exports = module.exports = (parcelRequire("lKmMa"));
    exports.Stream = $dAk3n$stream || exports;
    exports.Readable = exports;
    exports.Writable = (parcelRequire("iO42g"));
    exports.Duplex = (parcelRequire("1OgOr"));
    exports.Transform = (parcelRequire("fnbe7"));
    exports.PassThrough = (parcelRequire("2gLr7"));
    exports.finished = (parcelRequire("38DOk"));
    exports.pipeline = (parcelRequire("6ZwzM"));
}

});
parcelRequire.register("lKmMa", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
module.exports = $fd4f8fa57f5fc47b$var$Readable;
/*<replacement>*/ var $fd4f8fa57f5fc47b$var$Duplex;
/*</replacement>*/ $fd4f8fa57f5fc47b$var$Readable.ReadableState = $fd4f8fa57f5fc47b$var$ReadableState;

var $fd4f8fa57f5fc47b$require$EE = $dAk3n$events.EventEmitter;
var $fd4f8fa57f5fc47b$var$EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};

var $30RxH = parcelRequire("30RxH");

var $fd4f8fa57f5fc47b$require$Buffer = $dAk3n$buffer.Buffer;
var $fd4f8fa57f5fc47b$var$OurUint8Array = (typeof $parcel$global !== "undefined" ? $parcel$global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function $fd4f8fa57f5fc47b$var$_uint8ArrayToBuffer(chunk) {
    return $fd4f8fa57f5fc47b$require$Buffer.from(chunk);
}
function $fd4f8fa57f5fc47b$var$_isUint8Array(obj) {
    return $fd4f8fa57f5fc47b$require$Buffer.isBuffer(obj) || obj instanceof $fd4f8fa57f5fc47b$var$OurUint8Array;
}

var $fd4f8fa57f5fc47b$var$debug;
if ($dAk3n$util && $dAk3n$util.debuglog) $fd4f8fa57f5fc47b$var$debug = $dAk3n$util.debuglog("stream");
else $fd4f8fa57f5fc47b$var$debug = function debug() {};

var $2sujf = parcelRequire("2sujf");

var $lzT1I = parcelRequire("lzT1I");

var $k6hpf = parcelRequire("k6hpf");
var $fd4f8fa57f5fc47b$var$getHighWaterMark = $k6hpf.getHighWaterMark;

var $lVnqN = parcelRequire("lVnqN");
var $fd4f8fa57f5fc47b$require$_require$codes = $lVnqN.codes;
var $fd4f8fa57f5fc47b$var$ERR_INVALID_ARG_TYPE = $fd4f8fa57f5fc47b$require$_require$codes.ERR_INVALID_ARG_TYPE, $fd4f8fa57f5fc47b$var$ERR_STREAM_PUSH_AFTER_EOF = $fd4f8fa57f5fc47b$require$_require$codes.ERR_STREAM_PUSH_AFTER_EOF, $fd4f8fa57f5fc47b$var$ERR_METHOD_NOT_IMPLEMENTED = $fd4f8fa57f5fc47b$require$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $fd4f8fa57f5fc47b$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT = $fd4f8fa57f5fc47b$require$_require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var $fd4f8fa57f5fc47b$var$StringDecoder;
var $fd4f8fa57f5fc47b$var$createReadableStreamAsyncIterator;
var $fd4f8fa57f5fc47b$var$from;

(parcelRequire("csJOe"))($fd4f8fa57f5fc47b$var$Readable, $30RxH);
var $fd4f8fa57f5fc47b$var$errorOrDestroy = $lzT1I.errorOrDestroy;
var $fd4f8fa57f5fc47b$var$kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function $fd4f8fa57f5fc47b$var$prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}


function $fd4f8fa57f5fc47b$var$ReadableState(options, stream, isDuplex) {
    $fd4f8fa57f5fc47b$var$Duplex = $fd4f8fa57f5fc47b$var$Duplex || (parcelRequire("1OgOr"));
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof $fd4f8fa57f5fc47b$var$Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = $fd4f8fa57f5fc47b$var$getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new $2sujf();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!$fd4f8fa57f5fc47b$var$StringDecoder) $fd4f8fa57f5fc47b$var$StringDecoder = (parcelRequire("9AjJP")).StringDecoder;
        this.decoder = new $fd4f8fa57f5fc47b$var$StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}

function $fd4f8fa57f5fc47b$var$Readable(options) {
    $fd4f8fa57f5fc47b$var$Duplex = $fd4f8fa57f5fc47b$var$Duplex || (parcelRequire("1OgOr"));
    if (!(this instanceof $fd4f8fa57f5fc47b$var$Readable)) return new $fd4f8fa57f5fc47b$var$Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof $fd4f8fa57f5fc47b$var$Duplex;
    this._readableState = new $fd4f8fa57f5fc47b$var$ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    $30RxH.call(this);
}
Object.defineProperty($fd4f8fa57f5fc47b$var$Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
$fd4f8fa57f5fc47b$var$Readable.prototype.destroy = $lzT1I.destroy;
$fd4f8fa57f5fc47b$var$Readable.prototype._undestroy = $lzT1I.undestroy;
$fd4f8fa57f5fc47b$var$Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
$fd4f8fa57f5fc47b$var$Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = $fd4f8fa57f5fc47b$require$Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return $fd4f8fa57f5fc47b$var$readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
$fd4f8fa57f5fc47b$var$Readable.prototype.unshift = function(chunk) {
    return $fd4f8fa57f5fc47b$var$readableAddChunk(this, chunk, null, true, false);
};
function $fd4f8fa57f5fc47b$var$readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    $fd4f8fa57f5fc47b$var$debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        $fd4f8fa57f5fc47b$var$onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = $fd4f8fa57f5fc47b$var$chunkInvalid(state, chunk);
        if (er) $fd4f8fa57f5fc47b$var$errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== $fd4f8fa57f5fc47b$require$Buffer.prototype) chunk = $fd4f8fa57f5fc47b$var$_uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) $fd4f8fa57f5fc47b$var$errorOrDestroy(stream, new $fd4f8fa57f5fc47b$var$ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else $fd4f8fa57f5fc47b$var$addChunk(stream, state, chunk, true);
            } else if (state.ended) $fd4f8fa57f5fc47b$var$errorOrDestroy(stream, new $fd4f8fa57f5fc47b$var$ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) $fd4f8fa57f5fc47b$var$addChunk(stream, state, chunk, false);
                    else $fd4f8fa57f5fc47b$var$maybeReadMore(stream, state);
                } else $fd4f8fa57f5fc47b$var$addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            $fd4f8fa57f5fc47b$var$maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function $fd4f8fa57f5fc47b$var$addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) $fd4f8fa57f5fc47b$var$emitReadable(stream);
    }
    $fd4f8fa57f5fc47b$var$maybeReadMore(stream, state);
}
function $fd4f8fa57f5fc47b$var$chunkInvalid(state, chunk) {
    var er;
    if (!$fd4f8fa57f5fc47b$var$_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new $fd4f8fa57f5fc47b$var$ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
$fd4f8fa57f5fc47b$var$Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};

// backwards compatibility.
$fd4f8fa57f5fc47b$var$Readable.prototype.setEncoding = function(enc) {
    if (!$fd4f8fa57f5fc47b$var$StringDecoder) $fd4f8fa57f5fc47b$var$StringDecoder = (parcelRequire("9AjJP")).StringDecoder;
    var decoder = new $fd4f8fa57f5fc47b$var$StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var $fd4f8fa57f5fc47b$var$MAX_HWM = 0x40000000;
function $fd4f8fa57f5fc47b$var$computeNewHighWaterMark(n) {
    if (n >= $fd4f8fa57f5fc47b$var$MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = $fd4f8fa57f5fc47b$var$MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $fd4f8fa57f5fc47b$var$howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = $fd4f8fa57f5fc47b$var$computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
$fd4f8fa57f5fc47b$var$Readable.prototype.read = function(n) {
    $fd4f8fa57f5fc47b$var$debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        $fd4f8fa57f5fc47b$var$debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) $fd4f8fa57f5fc47b$var$endReadable(this);
        else $fd4f8fa57f5fc47b$var$emitReadable(this);
        return null;
    }
    n = $fd4f8fa57f5fc47b$var$howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) $fd4f8fa57f5fc47b$var$endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    $fd4f8fa57f5fc47b$var$debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        $fd4f8fa57f5fc47b$var$debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        $fd4f8fa57f5fc47b$var$debug("reading or ended", doRead);
    } else if (doRead) {
        $fd4f8fa57f5fc47b$var$debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = $fd4f8fa57f5fc47b$var$howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = $fd4f8fa57f5fc47b$var$fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) $fd4f8fa57f5fc47b$var$endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function $fd4f8fa57f5fc47b$var$onEofChunk(stream, state) {
    $fd4f8fa57f5fc47b$var$debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    $fd4f8fa57f5fc47b$var$emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            $fd4f8fa57f5fc47b$var$emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function $fd4f8fa57f5fc47b$var$emitReadable(stream) {
    var state = stream._readableState;
    $fd4f8fa57f5fc47b$var$debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        $fd4f8fa57f5fc47b$var$debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick($fd4f8fa57f5fc47b$var$emitReadable_, stream);
    }
}
function $fd4f8fa57f5fc47b$var$emitReadable_(stream) {
    var state = stream._readableState;
    $fd4f8fa57f5fc47b$var$debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    $fd4f8fa57f5fc47b$var$flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function $fd4f8fa57f5fc47b$var$maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick($fd4f8fa57f5fc47b$var$maybeReadMore_, stream, state);
    }
}
function $fd4f8fa57f5fc47b$var$maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        $fd4f8fa57f5fc47b$var$debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
$fd4f8fa57f5fc47b$var$Readable.prototype._read = function(n) {
    $fd4f8fa57f5fc47b$var$errorOrDestroy(this, new $fd4f8fa57f5fc47b$var$ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
$fd4f8fa57f5fc47b$var$Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    $fd4f8fa57f5fc47b$var$debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        $fd4f8fa57f5fc47b$var$debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        $fd4f8fa57f5fc47b$var$debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = $fd4f8fa57f5fc47b$var$pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        $fd4f8fa57f5fc47b$var$debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        $fd4f8fa57f5fc47b$var$debug("ondata");
        var ret = dest.write(chunk);
        $fd4f8fa57f5fc47b$var$debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && $fd4f8fa57f5fc47b$var$indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                $fd4f8fa57f5fc47b$var$debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        $fd4f8fa57f5fc47b$var$debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if ($fd4f8fa57f5fc47b$var$EElistenerCount(dest, "error") === 0) $fd4f8fa57f5fc47b$var$errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    $fd4f8fa57f5fc47b$var$prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        $fd4f8fa57f5fc47b$var$debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        $fd4f8fa57f5fc47b$var$debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        $fd4f8fa57f5fc47b$var$debug("pipe resume");
        src.resume();
    }
    return dest;
};
function $fd4f8fa57f5fc47b$var$pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        $fd4f8fa57f5fc47b$var$debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && $fd4f8fa57f5fc47b$var$EElistenerCount(src, "data")) {
            state.flowing = true;
            $fd4f8fa57f5fc47b$var$flow(src);
        }
    };
}
$fd4f8fa57f5fc47b$var$Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = $fd4f8fa57f5fc47b$var$indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
$fd4f8fa57f5fc47b$var$Readable.prototype.on = function(ev, fn) {
    var res = $30RxH.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            $fd4f8fa57f5fc47b$var$debug("on readable", state.length, state.reading);
            if (state.length) $fd4f8fa57f5fc47b$var$emitReadable(this);
            else if (!state.reading) process.nextTick($fd4f8fa57f5fc47b$var$nReadingNextTick, this);
        }
    }
    return res;
};
$fd4f8fa57f5fc47b$var$Readable.prototype.addListener = $fd4f8fa57f5fc47b$var$Readable.prototype.on;
$fd4f8fa57f5fc47b$var$Readable.prototype.removeListener = function(ev, fn) {
    var res = $30RxH.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick($fd4f8fa57f5fc47b$var$updateReadableListening, this);
    return res;
};
$fd4f8fa57f5fc47b$var$Readable.prototype.removeAllListeners = function(ev) {
    var res = $30RxH.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick($fd4f8fa57f5fc47b$var$updateReadableListening, this);
    return res;
};
function $fd4f8fa57f5fc47b$var$updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;
    else if (self1.listenerCount("data") > 0) self1.resume();
}
function $fd4f8fa57f5fc47b$var$nReadingNextTick(self1) {
    $fd4f8fa57f5fc47b$var$debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
$fd4f8fa57f5fc47b$var$Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        $fd4f8fa57f5fc47b$var$debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        $fd4f8fa57f5fc47b$var$resume(this, state);
    }
    state.paused = false;
    return this;
};
function $fd4f8fa57f5fc47b$var$resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick($fd4f8fa57f5fc47b$var$resume_, stream, state);
    }
}
function $fd4f8fa57f5fc47b$var$resume_(stream, state) {
    $fd4f8fa57f5fc47b$var$debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    $fd4f8fa57f5fc47b$var$flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
$fd4f8fa57f5fc47b$var$Readable.prototype.pause = function() {
    $fd4f8fa57f5fc47b$var$debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        $fd4f8fa57f5fc47b$var$debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function $fd4f8fa57f5fc47b$var$flow(stream) {
    var state = stream._readableState;
    $fd4f8fa57f5fc47b$var$debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
$fd4f8fa57f5fc47b$var$Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        $fd4f8fa57f5fc47b$var$debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        $fd4f8fa57f5fc47b$var$debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < $fd4f8fa57f5fc47b$var$kProxyEvents.length; n++)stream.on($fd4f8fa57f5fc47b$var$kProxyEvents[n], this.emit.bind(this, $fd4f8fa57f5fc47b$var$kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        $fd4f8fa57f5fc47b$var$debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};

if (typeof Symbol === "function") $fd4f8fa57f5fc47b$var$Readable.prototype[Symbol.asyncIterator] = function() {
    if ($fd4f8fa57f5fc47b$var$createReadableStreamAsyncIterator === undefined) $fd4f8fa57f5fc47b$var$createReadableStreamAsyncIterator = (parcelRequire("if4Nz"));
    return $fd4f8fa57f5fc47b$var$createReadableStreamAsyncIterator(this);
};
Object.defineProperty($fd4f8fa57f5fc47b$var$Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty($fd4f8fa57f5fc47b$var$Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty($fd4f8fa57f5fc47b$var$Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
});
// exposed for testing purposes only.
$fd4f8fa57f5fc47b$var$Readable._fromList = $fd4f8fa57f5fc47b$var$fromList;
Object.defineProperty($fd4f8fa57f5fc47b$var$Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function $fd4f8fa57f5fc47b$var$fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function $fd4f8fa57f5fc47b$var$endReadable(stream) {
    var state = stream._readableState;
    $fd4f8fa57f5fc47b$var$debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick($fd4f8fa57f5fc47b$var$endReadableNT, state, stream);
    }
}
function $fd4f8fa57f5fc47b$var$endReadableNT(state, stream) {
    $fd4f8fa57f5fc47b$var$debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}

if (typeof Symbol === "function") $fd4f8fa57f5fc47b$var$Readable.from = function(iterable, opts) {
    if ($fd4f8fa57f5fc47b$var$from === undefined) $fd4f8fa57f5fc47b$var$from = (parcelRequire("gx3Pp"));
    return $fd4f8fa57f5fc47b$var$from($fd4f8fa57f5fc47b$var$Readable, iterable, opts);
};
function $fd4f8fa57f5fc47b$var$indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

});
parcelRequire.register("30RxH", function(module, exports) {

module.exports = $dAk3n$stream;

});

parcelRequire.register("2sujf", function(module, exports) {
"use strict";
function $1ca5b518abe99fb6$var$ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function $1ca5b518abe99fb6$var$_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? $1ca5b518abe99fb6$var$ownKeys(Object(source), !0).forEach(function(key) {
            $1ca5b518abe99fb6$var$_defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : $1ca5b518abe99fb6$var$ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function $1ca5b518abe99fb6$var$_defineProperty(obj, key, value) {
    key = $1ca5b518abe99fb6$var$_toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $1ca5b518abe99fb6$var$_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function $1ca5b518abe99fb6$var$_defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, $1ca5b518abe99fb6$var$_toPropertyKey(descriptor.key), descriptor);
    }
}
function $1ca5b518abe99fb6$var$_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) $1ca5b518abe99fb6$var$_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) $1ca5b518abe99fb6$var$_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function $1ca5b518abe99fb6$var$_toPropertyKey(arg) {
    var key = $1ca5b518abe99fb6$var$_toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function $1ca5b518abe99fb6$var$_toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}

var $1ca5b518abe99fb6$var$Buffer = $dAk3n$buffer.Buffer;

var $1ca5b518abe99fb6$var$inspect = $dAk3n$util.inspect;
var $1ca5b518abe99fb6$var$custom = $1ca5b518abe99fb6$var$inspect && $1ca5b518abe99fb6$var$inspect.custom || "inspect";
function $1ca5b518abe99fb6$var$copyBuffer(src, target, offset) {
    $1ca5b518abe99fb6$var$Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        $1ca5b518abe99fb6$var$_classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    $1ca5b518abe99fb6$var$_createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return $1ca5b518abe99fb6$var$Buffer.alloc(0);
                var ret = $1ca5b518abe99fb6$var$Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    $1ca5b518abe99fb6$var$copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = $1ca5b518abe99fb6$var$Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: $1ca5b518abe99fb6$var$custom,
            value: function value(_, options) {
                return $1ca5b518abe99fb6$var$inspect(this, $1ca5b518abe99fb6$var$_objectSpread($1ca5b518abe99fb6$var$_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

});

parcelRequire.register("lzT1I", function(module, exports) {
"use strict";
// undocumented cb() API, needed for core, not for public API
function $fb578d065d6097ad$var$destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick($fb578d065d6097ad$var$emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick($fb578d065d6097ad$var$emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick($fb578d065d6097ad$var$emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick($fb578d065d6097ad$var$emitErrorAndCloseNT, _this, err);
            } else process.nextTick($fb578d065d6097ad$var$emitCloseNT, _this);
        } else if (cb) {
            process.nextTick($fb578d065d6097ad$var$emitCloseNT, _this);
            cb(err);
        } else process.nextTick($fb578d065d6097ad$var$emitCloseNT, _this);
    });
    return this;
}
function $fb578d065d6097ad$var$emitErrorAndCloseNT(self, err) {
    $fb578d065d6097ad$var$emitErrorNT(self, err);
    $fb578d065d6097ad$var$emitCloseNT(self);
}
function $fb578d065d6097ad$var$emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function $fb578d065d6097ad$var$undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function $fb578d065d6097ad$var$emitErrorNT(self, err) {
    self.emit("error", err);
}
function $fb578d065d6097ad$var$errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: $fb578d065d6097ad$var$destroy,
    undestroy: $fb578d065d6097ad$var$undestroy,
    errorOrDestroy: $fb578d065d6097ad$var$errorOrDestroy
};

});

parcelRequire.register("k6hpf", function(module, exports) {
"use strict";

var $lVnqN = parcelRequire("lVnqN");
var $ea21deb2ac451d29$var$ERR_INVALID_OPT_VALUE = $lVnqN.codes.ERR_INVALID_OPT_VALUE;
function $ea21deb2ac451d29$var$highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function $ea21deb2ac451d29$var$getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = $ea21deb2ac451d29$var$highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new $ea21deb2ac451d29$var$ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: $ea21deb2ac451d29$var$getHighWaterMark
};

});
parcelRequire.register("lVnqN", function(module, exports) {

$parcel$export(module.exports, "codes", () => $ff6118cd61bb2d21$export$e45cb6485273080e, (v) => $ff6118cd61bb2d21$export$e45cb6485273080e = v);
var $ff6118cd61bb2d21$export$e45cb6485273080e;
"use strict";
const $ff6118cd61bb2d21$var$codes = {};
function $ff6118cd61bb2d21$var$createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    class NodeError extends Base {
        constructor(arg1, arg2, arg3){
            super(getMessage(arg1, arg2, arg3));
        }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    $ff6118cd61bb2d21$var$codes[code] = NodeError;
}
// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function $ff6118cd61bb2d21$var$oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i)=>String(i));
        if (len > 2) return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        else if (len === 2) return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        else return `of ${thing} ${expected[0]}`;
    } else return `of ${thing} ${String(expected)}`;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function $ff6118cd61bb2d21$var$startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function $ff6118cd61bb2d21$var$endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function $ff6118cd61bb2d21$var$includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
$ff6118cd61bb2d21$var$createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
$ff6118cd61bb2d21$var$createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;
    if (typeof expected === "string" && $ff6118cd61bb2d21$var$startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    let msg;
    if ($ff6118cd61bb2d21$var$endsWith(name, " argument")) // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${$ff6118cd61bb2d21$var$oneOf(expected, "type")}`;
    else {
        const type = $ff6118cd61bb2d21$var$includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${$ff6118cd61bb2d21$var$oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
}, TypeError);
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
$ff6118cd61bb2d21$var$createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
$ff6118cd61bb2d21$var$createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
$ff6118cd61bb2d21$var$createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
$ff6118cd61bb2d21$var$createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
$ff6118cd61bb2d21$export$e45cb6485273080e = $ff6118cd61bb2d21$var$codes;

});


parcelRequire.register("1OgOr", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
"use strict";
/*<replacement>*/ var $15178098e7165497$var$objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = $15178098e7165497$var$Duplex;

var $lKmMa = parcelRequire("lKmMa");

var $iO42g = parcelRequire("iO42g");

(parcelRequire("csJOe"))($15178098e7165497$var$Duplex, $lKmMa);
// Allow the keys array to be GC'ed.
var $15178098e7165497$var$keys = $15178098e7165497$var$objectKeys($iO42g.prototype);
for(var $15178098e7165497$var$v = 0; $15178098e7165497$var$v < $15178098e7165497$var$keys.length; $15178098e7165497$var$v++){
    var $15178098e7165497$var$method = $15178098e7165497$var$keys[$15178098e7165497$var$v];
    if (!$15178098e7165497$var$Duplex.prototype[$15178098e7165497$var$method]) $15178098e7165497$var$Duplex.prototype[$15178098e7165497$var$method] = $iO42g.prototype[$15178098e7165497$var$method];
}
function $15178098e7165497$var$Duplex(options) {
    if (!(this instanceof $15178098e7165497$var$Duplex)) return new $15178098e7165497$var$Duplex(options);
    $lKmMa.call(this, options);
    $iO42g.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", $15178098e7165497$var$onend);
        }
    }
}
Object.defineProperty($15178098e7165497$var$Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty($15178098e7165497$var$Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty($15178098e7165497$var$Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function $15178098e7165497$var$onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick($15178098e7165497$var$onEndNT, this);
}
function $15178098e7165497$var$onEndNT(self) {
    self.end();
}
Object.defineProperty($15178098e7165497$var$Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

});
parcelRequire.register("iO42g", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
"use strict";
module.exports = $db1006e0db8fadbf$var$Writable;
/* <replacement> */ function $db1006e0db8fadbf$var$WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function $db1006e0db8fadbf$var$CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        $db1006e0db8fadbf$var$onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var $db1006e0db8fadbf$var$Duplex;
/*</replacement>*/ $db1006e0db8fadbf$var$Writable.WritableState = $db1006e0db8fadbf$var$WritableState;

/*<replacement>*/ var $db1006e0db8fadbf$var$internalUtil = {
    deprecate: (parcelRequire("kOIq4"))
};

var $30RxH = parcelRequire("30RxH");

var $db1006e0db8fadbf$require$Buffer = $dAk3n$buffer.Buffer;
var $db1006e0db8fadbf$var$OurUint8Array = (typeof $parcel$global !== "undefined" ? $parcel$global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function $db1006e0db8fadbf$var$_uint8ArrayToBuffer(chunk) {
    return $db1006e0db8fadbf$require$Buffer.from(chunk);
}
function $db1006e0db8fadbf$var$_isUint8Array(obj) {
    return $db1006e0db8fadbf$require$Buffer.isBuffer(obj) || obj instanceof $db1006e0db8fadbf$var$OurUint8Array;
}

var $lzT1I = parcelRequire("lzT1I");

var $k6hpf = parcelRequire("k6hpf");
var $db1006e0db8fadbf$var$getHighWaterMark = $k6hpf.getHighWaterMark;

var $lVnqN = parcelRequire("lVnqN");
var $db1006e0db8fadbf$require$_require$codes = $lVnqN.codes;
var $db1006e0db8fadbf$var$ERR_INVALID_ARG_TYPE = $db1006e0db8fadbf$require$_require$codes.ERR_INVALID_ARG_TYPE, $db1006e0db8fadbf$var$ERR_METHOD_NOT_IMPLEMENTED = $db1006e0db8fadbf$require$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $db1006e0db8fadbf$var$ERR_MULTIPLE_CALLBACK = $db1006e0db8fadbf$require$_require$codes.ERR_MULTIPLE_CALLBACK, $db1006e0db8fadbf$var$ERR_STREAM_CANNOT_PIPE = $db1006e0db8fadbf$require$_require$codes.ERR_STREAM_CANNOT_PIPE, $db1006e0db8fadbf$var$ERR_STREAM_DESTROYED = $db1006e0db8fadbf$require$_require$codes.ERR_STREAM_DESTROYED, $db1006e0db8fadbf$var$ERR_STREAM_NULL_VALUES = $db1006e0db8fadbf$require$_require$codes.ERR_STREAM_NULL_VALUES, $db1006e0db8fadbf$var$ERR_STREAM_WRITE_AFTER_END = $db1006e0db8fadbf$require$_require$codes.ERR_STREAM_WRITE_AFTER_END, $db1006e0db8fadbf$var$ERR_UNKNOWN_ENCODING = $db1006e0db8fadbf$require$_require$codes.ERR_UNKNOWN_ENCODING;
var $db1006e0db8fadbf$var$errorOrDestroy = $lzT1I.errorOrDestroy;

(parcelRequire("csJOe"))($db1006e0db8fadbf$var$Writable, $30RxH);
function $db1006e0db8fadbf$var$nop() {}

function $db1006e0db8fadbf$var$WritableState(options, stream, isDuplex) {
    $db1006e0db8fadbf$var$Duplex = $db1006e0db8fadbf$var$Duplex || (parcelRequire("1OgOr"));
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof $db1006e0db8fadbf$var$Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = $db1006e0db8fadbf$var$getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        $db1006e0db8fadbf$var$onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new $db1006e0db8fadbf$var$CorkedRequest(this);
}
$db1006e0db8fadbf$var$WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty($db1006e0db8fadbf$var$WritableState.prototype, "buffer", {
            get: $db1006e0db8fadbf$var$internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var $db1006e0db8fadbf$var$realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    $db1006e0db8fadbf$var$realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty($db1006e0db8fadbf$var$Writable, Symbol.hasInstance, {
        value: function value(object) {
            if ($db1006e0db8fadbf$var$realHasInstance.call(this, object)) return true;
            if (this !== $db1006e0db8fadbf$var$Writable) return false;
            return object && object._writableState instanceof $db1006e0db8fadbf$var$WritableState;
        }
    });
} else $db1006e0db8fadbf$var$realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};

function $db1006e0db8fadbf$var$Writable(options) {
    $db1006e0db8fadbf$var$Duplex = $db1006e0db8fadbf$var$Duplex || (parcelRequire("1OgOr"));
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof $db1006e0db8fadbf$var$Duplex;
    if (!isDuplex && !$db1006e0db8fadbf$var$realHasInstance.call($db1006e0db8fadbf$var$Writable, this)) return new $db1006e0db8fadbf$var$Writable(options);
    this._writableState = new $db1006e0db8fadbf$var$WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    $30RxH.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
$db1006e0db8fadbf$var$Writable.prototype.pipe = function() {
    $db1006e0db8fadbf$var$errorOrDestroy(this, new $db1006e0db8fadbf$var$ERR_STREAM_CANNOT_PIPE());
};
function $db1006e0db8fadbf$var$writeAfterEnd(stream, cb) {
    var er = new $db1006e0db8fadbf$var$ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    $db1006e0db8fadbf$var$errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function $db1006e0db8fadbf$var$validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new $db1006e0db8fadbf$var$ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new $db1006e0db8fadbf$var$ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        $db1006e0db8fadbf$var$errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
$db1006e0db8fadbf$var$Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && $db1006e0db8fadbf$var$_isUint8Array(chunk);
    if (isBuf && !$db1006e0db8fadbf$require$Buffer.isBuffer(chunk)) chunk = $db1006e0db8fadbf$var$_uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = $db1006e0db8fadbf$var$nop;
    if (state.ending) $db1006e0db8fadbf$var$writeAfterEnd(this, cb);
    else if (isBuf || $db1006e0db8fadbf$var$validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = $db1006e0db8fadbf$var$writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
$db1006e0db8fadbf$var$Writable.prototype.cork = function() {
    this._writableState.corked++;
};
$db1006e0db8fadbf$var$Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) $db1006e0db8fadbf$var$clearBuffer(this, state);
    }
};
$db1006e0db8fadbf$var$Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new $db1006e0db8fadbf$var$ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty($db1006e0db8fadbf$var$Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function $db1006e0db8fadbf$var$decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = $db1006e0db8fadbf$require$Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty($db1006e0db8fadbf$var$Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function $db1006e0db8fadbf$var$writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = $db1006e0db8fadbf$var$decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else $db1006e0db8fadbf$var$doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function $db1006e0db8fadbf$var$doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new $db1006e0db8fadbf$var$ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function $db1006e0db8fadbf$var$onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick($db1006e0db8fadbf$var$finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        $db1006e0db8fadbf$var$errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        $db1006e0db8fadbf$var$errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        $db1006e0db8fadbf$var$finishMaybe(stream, state);
    }
}
function $db1006e0db8fadbf$var$onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function $db1006e0db8fadbf$var$onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new $db1006e0db8fadbf$var$ERR_MULTIPLE_CALLBACK();
    $db1006e0db8fadbf$var$onwriteStateUpdate(state);
    if (er) $db1006e0db8fadbf$var$onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = $db1006e0db8fadbf$var$needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) $db1006e0db8fadbf$var$clearBuffer(stream, state);
        if (sync) process.nextTick($db1006e0db8fadbf$var$afterWrite, stream, state, finished, cb);
        else $db1006e0db8fadbf$var$afterWrite(stream, state, finished, cb);
    }
}
function $db1006e0db8fadbf$var$afterWrite(stream, state, finished, cb) {
    if (!finished) $db1006e0db8fadbf$var$onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    $db1006e0db8fadbf$var$finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function $db1006e0db8fadbf$var$onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function $db1006e0db8fadbf$var$clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        $db1006e0db8fadbf$var$doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new $db1006e0db8fadbf$var$CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            $db1006e0db8fadbf$var$doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
$db1006e0db8fadbf$var$Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new $db1006e0db8fadbf$var$ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
$db1006e0db8fadbf$var$Writable.prototype._writev = null;
$db1006e0db8fadbf$var$Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) $db1006e0db8fadbf$var$endWritable(this, state, cb);
    return this;
};
Object.defineProperty($db1006e0db8fadbf$var$Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function $db1006e0db8fadbf$var$needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function $db1006e0db8fadbf$var$callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) $db1006e0db8fadbf$var$errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit("prefinish");
        $db1006e0db8fadbf$var$finishMaybe(stream, state);
    });
}
function $db1006e0db8fadbf$var$prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick($db1006e0db8fadbf$var$callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function $db1006e0db8fadbf$var$finishMaybe(stream, state) {
    var need = $db1006e0db8fadbf$var$needFinish(state);
    if (need) {
        $db1006e0db8fadbf$var$prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function $db1006e0db8fadbf$var$endWritable(stream, state, cb) {
    state.ending = true;
    $db1006e0db8fadbf$var$finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function $db1006e0db8fadbf$var$onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty($db1006e0db8fadbf$var$Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
$db1006e0db8fadbf$var$Writable.prototype.destroy = $lzT1I.destroy;
$db1006e0db8fadbf$var$Writable.prototype._undestroy = $lzT1I.undestroy;
$db1006e0db8fadbf$var$Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

});


parcelRequire.register("9AjJP", function(module, exports) {

$parcel$export(module.exports, "StringDecoder", () => $6fa6c9735dba76ca$export$63a7aa211a91ed69, (v) => $6fa6c9735dba76ca$export$63a7aa211a91ed69 = v);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
var $6fa6c9735dba76ca$export$63a7aa211a91ed69;
"use strict";

var $2uDEU = parcelRequire("2uDEU");
var $6fa6c9735dba76ca$require$Buffer = $2uDEU.Buffer;
/*</replacement>*/ var $6fa6c9735dba76ca$var$isEncoding = $6fa6c9735dba76ca$require$Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function $6fa6c9735dba76ca$var$_normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function $6fa6c9735dba76ca$var$normalizeEncoding(enc) {
    var nenc = $6fa6c9735dba76ca$var$_normalizeEncoding(enc);
    if (typeof nenc !== "string" && ($6fa6c9735dba76ca$require$Buffer.isEncoding === $6fa6c9735dba76ca$var$isEncoding || !$6fa6c9735dba76ca$var$isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
$6fa6c9735dba76ca$export$63a7aa211a91ed69 = $6fa6c9735dba76ca$var$StringDecoder;
function $6fa6c9735dba76ca$var$StringDecoder(encoding) {
    this.encoding = $6fa6c9735dba76ca$var$normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = $6fa6c9735dba76ca$var$utf16Text;
            this.end = $6fa6c9735dba76ca$var$utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = $6fa6c9735dba76ca$var$utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = $6fa6c9735dba76ca$var$base64Text;
            this.end = $6fa6c9735dba76ca$var$base64End;
            nb = 3;
            break;
        default:
            this.write = $6fa6c9735dba76ca$var$simpleWrite;
            this.end = $6fa6c9735dba76ca$var$simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = $6fa6c9735dba76ca$require$Buffer.allocUnsafe(nb);
}
$6fa6c9735dba76ca$var$StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
$6fa6c9735dba76ca$var$StringDecoder.prototype.end = $6fa6c9735dba76ca$var$utf8End;
// Returns only complete characters in a Buffer
$6fa6c9735dba76ca$var$StringDecoder.prototype.text = $6fa6c9735dba76ca$var$utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
$6fa6c9735dba76ca$var$StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function $6fa6c9735dba76ca$var$utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function $6fa6c9735dba76ca$var$utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = $6fa6c9735dba76ca$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = $6fa6c9735dba76ca$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = $6fa6c9735dba76ca$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function $6fa6c9735dba76ca$var$utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "�";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "�";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function $6fa6c9735dba76ca$var$utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = $6fa6c9735dba76ca$var$utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function $6fa6c9735dba76ca$var$utf8Text(buf, i) {
    var total = $6fa6c9735dba76ca$var$utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function $6fa6c9735dba76ca$var$utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function $6fa6c9735dba76ca$var$utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function $6fa6c9735dba76ca$var$utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function $6fa6c9735dba76ca$var$base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function $6fa6c9735dba76ca$var$base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function $6fa6c9735dba76ca$var$simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function $6fa6c9735dba76ca$var$simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

});

parcelRequire.register("if4Nz", function(module, exports) {
"use strict";
var $d47d599f21a7089e$var$_Object$setPrototypeO;
function $d47d599f21a7089e$var$_defineProperty(obj, key, value) {
    key = $d47d599f21a7089e$var$_toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $d47d599f21a7089e$var$_toPropertyKey(arg) {
    var key = $d47d599f21a7089e$var$_toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function $d47d599f21a7089e$var$_toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}

var $38DOk = parcelRequire("38DOk");
var $d47d599f21a7089e$var$kLastResolve = Symbol("lastResolve");
var $d47d599f21a7089e$var$kLastReject = Symbol("lastReject");
var $d47d599f21a7089e$var$kError = Symbol("error");
var $d47d599f21a7089e$var$kEnded = Symbol("ended");
var $d47d599f21a7089e$var$kLastPromise = Symbol("lastPromise");
var $d47d599f21a7089e$var$kHandlePromise = Symbol("handlePromise");
var $d47d599f21a7089e$var$kStream = Symbol("stream");
function $d47d599f21a7089e$var$createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function $d47d599f21a7089e$var$readAndResolve(iter) {
    var resolve = iter[$d47d599f21a7089e$var$kLastResolve];
    if (resolve !== null) {
        var data = iter[$d47d599f21a7089e$var$kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[$d47d599f21a7089e$var$kLastPromise] = null;
            iter[$d47d599f21a7089e$var$kLastResolve] = null;
            iter[$d47d599f21a7089e$var$kLastReject] = null;
            resolve($d47d599f21a7089e$var$createIterResult(data, false));
        }
    }
}
function $d47d599f21a7089e$var$onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick($d47d599f21a7089e$var$readAndResolve, iter);
}
function $d47d599f21a7089e$var$wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[$d47d599f21a7089e$var$kEnded]) {
                resolve($d47d599f21a7089e$var$createIterResult(undefined, true));
                return;
            }
            iter[$d47d599f21a7089e$var$kHandlePromise](resolve, reject);
        }, reject);
    };
}
var $d47d599f21a7089e$var$AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var $d47d599f21a7089e$var$ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(($d47d599f21a7089e$var$_Object$setPrototypeO = {
    get stream () {
        return this[$d47d599f21a7089e$var$kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[$d47d599f21a7089e$var$kError];
        if (error !== null) return Promise.reject(error);
        if (this[$d47d599f21a7089e$var$kEnded]) return Promise.resolve($d47d599f21a7089e$var$createIterResult(undefined, true));
        if (this[$d47d599f21a7089e$var$kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[$d47d599f21a7089e$var$kError]) reject(_this[$d47d599f21a7089e$var$kError]);
                else resolve($d47d599f21a7089e$var$createIterResult(undefined, true));
            });
        });
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[$d47d599f21a7089e$var$kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise($d47d599f21a7089e$var$wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[$d47d599f21a7089e$var$kStream].read();
            if (data !== null) return Promise.resolve($d47d599f21a7089e$var$createIterResult(data, false));
            promise = new Promise(this[$d47d599f21a7089e$var$kHandlePromise]);
        }
        this[$d47d599f21a7089e$var$kLastPromise] = promise;
        return promise;
    }
}, $d47d599f21a7089e$var$_defineProperty($d47d599f21a7089e$var$_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), $d47d599f21a7089e$var$_defineProperty($d47d599f21a7089e$var$_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[$d47d599f21a7089e$var$kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve($d47d599f21a7089e$var$createIterResult(undefined, true));
        });
    });
}), $d47d599f21a7089e$var$_Object$setPrototypeO), $d47d599f21a7089e$var$AsyncIteratorPrototype);
var $d47d599f21a7089e$var$createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create($d47d599f21a7089e$var$ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, $d47d599f21a7089e$var$_defineProperty(_Object$create, $d47d599f21a7089e$var$kStream, {
        value: stream,
        writable: true
    }), $d47d599f21a7089e$var$_defineProperty(_Object$create, $d47d599f21a7089e$var$kLastResolve, {
        value: null,
        writable: true
    }), $d47d599f21a7089e$var$_defineProperty(_Object$create, $d47d599f21a7089e$var$kLastReject, {
        value: null,
        writable: true
    }), $d47d599f21a7089e$var$_defineProperty(_Object$create, $d47d599f21a7089e$var$kError, {
        value: null,
        writable: true
    }), $d47d599f21a7089e$var$_defineProperty(_Object$create, $d47d599f21a7089e$var$kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), $d47d599f21a7089e$var$_defineProperty(_Object$create, $d47d599f21a7089e$var$kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[$d47d599f21a7089e$var$kStream].read();
            if (data) {
                iterator[$d47d599f21a7089e$var$kLastPromise] = null;
                iterator[$d47d599f21a7089e$var$kLastResolve] = null;
                iterator[$d47d599f21a7089e$var$kLastReject] = null;
                resolve($d47d599f21a7089e$var$createIterResult(data, false));
            } else {
                iterator[$d47d599f21a7089e$var$kLastResolve] = resolve;
                iterator[$d47d599f21a7089e$var$kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[$d47d599f21a7089e$var$kLastPromise] = null;
    $38DOk(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[$d47d599f21a7089e$var$kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[$d47d599f21a7089e$var$kLastPromise] = null;
                iterator[$d47d599f21a7089e$var$kLastResolve] = null;
                iterator[$d47d599f21a7089e$var$kLastReject] = null;
                reject(err);
            }
            iterator[$d47d599f21a7089e$var$kError] = err;
            return;
        }
        var resolve = iterator[$d47d599f21a7089e$var$kLastResolve];
        if (resolve !== null) {
            iterator[$d47d599f21a7089e$var$kLastPromise] = null;
            iterator[$d47d599f21a7089e$var$kLastResolve] = null;
            iterator[$d47d599f21a7089e$var$kLastReject] = null;
            resolve($d47d599f21a7089e$var$createIterResult(undefined, true));
        }
        iterator[$d47d599f21a7089e$var$kEnded] = true;
    });
    stream.on("readable", $d47d599f21a7089e$var$onReadable.bind(null, iterator));
    return iterator;
};
module.exports = $d47d599f21a7089e$var$createReadableStreamAsyncIterator;

});
parcelRequire.register("38DOk", function(module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";

var $lVnqN = parcelRequire("lVnqN");
var $2491000846e5a12e$var$ERR_STREAM_PREMATURE_CLOSE = $lVnqN.codes.ERR_STREAM_PREMATURE_CLOSE;
function $2491000846e5a12e$var$once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function $2491000846e5a12e$var$noop() {}
function $2491000846e5a12e$var$isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function $2491000846e5a12e$var$eos(stream, opts, callback) {
    if (typeof opts === "function") return $2491000846e5a12e$var$eos(stream, null, opts);
    if (!opts) opts = {};
    callback = $2491000846e5a12e$var$once(callback || $2491000846e5a12e$var$noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new $2491000846e5a12e$var$ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new $2491000846e5a12e$var$ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if ($2491000846e5a12e$var$isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = $2491000846e5a12e$var$eos;

});


parcelRequire.register("gx3Pp", function(module, exports) {
"use strict";
function $c092b29750d9a4ca$var$asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function $c092b29750d9a4ca$var$_asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                $c092b29750d9a4ca$var$asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                $c092b29750d9a4ca$var$asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function $c092b29750d9a4ca$var$ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function $c092b29750d9a4ca$var$_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? $c092b29750d9a4ca$var$ownKeys(Object(source), !0).forEach(function(key) {
            $c092b29750d9a4ca$var$_defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : $c092b29750d9a4ca$var$ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function $c092b29750d9a4ca$var$_defineProperty(obj, key, value) {
    key = $c092b29750d9a4ca$var$_toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $c092b29750d9a4ca$var$_toPropertyKey(arg) {
    var key = $c092b29750d9a4ca$var$_toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function $c092b29750d9a4ca$var$_toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}

var $lVnqN = parcelRequire("lVnqN");
var $c092b29750d9a4ca$var$ERR_INVALID_ARG_TYPE = $lVnqN.codes.ERR_INVALID_ARG_TYPE;
function $c092b29750d9a4ca$var$from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") iterator = iterable;
    else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new $c092b29750d9a4ca$var$ERR_INVALID_ARG_TYPE("iterable", [
        "Iterable"
    ], iterable);
    var readable = new Readable($c092b29750d9a4ca$var$_objectSpread({
        objectMode: true
    }, opts));
    // Reading boolean to protect against _read
    // being called before last iteration completion.
    var reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    function next() {
        return _next2.apply(this, arguments);
    }
    function _next2() {
        _next2 = $c092b29750d9a4ca$var$_asyncToGenerator(function*() {
            try {
                var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
                if (done) readable.push(null);
                else if (readable.push((yield value))) next();
                else reading = false;
            } catch (err) {
                readable.destroy(err);
            }
        });
        return _next2.apply(this, arguments);
    }
    return readable;
}
module.exports = $c092b29750d9a4ca$var$from;

});


parcelRequire.register("fnbe7", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = $b311b65dc009b01f$var$Transform;

var $lVnqN = parcelRequire("lVnqN");
var $b311b65dc009b01f$require$_require$codes = $lVnqN.codes;
var $b311b65dc009b01f$var$ERR_METHOD_NOT_IMPLEMENTED = $b311b65dc009b01f$require$_require$codes.ERR_METHOD_NOT_IMPLEMENTED, $b311b65dc009b01f$var$ERR_MULTIPLE_CALLBACK = $b311b65dc009b01f$require$_require$codes.ERR_MULTIPLE_CALLBACK, $b311b65dc009b01f$var$ERR_TRANSFORM_ALREADY_TRANSFORMING = $b311b65dc009b01f$require$_require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, $b311b65dc009b01f$var$ERR_TRANSFORM_WITH_LENGTH_0 = $b311b65dc009b01f$require$_require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var $1OgOr = parcelRequire("1OgOr");

(parcelRequire("csJOe"))($b311b65dc009b01f$var$Transform, $1OgOr);
function $b311b65dc009b01f$var$afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit("error", new $b311b65dc009b01f$var$ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function $b311b65dc009b01f$var$Transform(options) {
    if (!(this instanceof $b311b65dc009b01f$var$Transform)) return new $b311b65dc009b01f$var$Transform(options);
    $1OgOr.call(this, options);
    this._transformState = {
        afterTransform: $b311b65dc009b01f$var$afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", $b311b65dc009b01f$var$prefinish);
}
function $b311b65dc009b01f$var$prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
        $b311b65dc009b01f$var$done(_this, er, data);
    });
    else $b311b65dc009b01f$var$done(this, null, null);
}
$b311b65dc009b01f$var$Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return $1OgOr.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
$b311b65dc009b01f$var$Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new $b311b65dc009b01f$var$ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
$b311b65dc009b01f$var$Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
$b311b65dc009b01f$var$Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
$b311b65dc009b01f$var$Transform.prototype._destroy = function(err, cb) {
    $1OgOr.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function $b311b65dc009b01f$var$done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new $b311b65dc009b01f$var$ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new $b311b65dc009b01f$var$ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

});

parcelRequire.register("2gLr7", function(module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = $1a71df49f5923ee1$var$PassThrough;

var $fnbe7 = parcelRequire("fnbe7");

(parcelRequire("csJOe"))($1a71df49f5923ee1$var$PassThrough, $fnbe7);
function $1a71df49f5923ee1$var$PassThrough(options) {
    if (!(this instanceof $1a71df49f5923ee1$var$PassThrough)) return new $1a71df49f5923ee1$var$PassThrough(options);
    $fnbe7.call(this, options);
}
$1a71df49f5923ee1$var$PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

});

parcelRequire.register("6ZwzM", function(module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var $5171b584b2790ad6$var$eos;
function $5171b584b2790ad6$var$once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}

var $lVnqN = parcelRequire("lVnqN");
var $5171b584b2790ad6$require$_require$codes = $lVnqN.codes;
var $5171b584b2790ad6$var$ERR_MISSING_ARGS = $5171b584b2790ad6$require$_require$codes.ERR_MISSING_ARGS, $5171b584b2790ad6$var$ERR_STREAM_DESTROYED = $5171b584b2790ad6$require$_require$codes.ERR_STREAM_DESTROYED;
function $5171b584b2790ad6$var$noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function $5171b584b2790ad6$var$isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}

function $5171b584b2790ad6$var$destroyer(stream, reading, writing, callback) {
    callback = $5171b584b2790ad6$var$once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if ($5171b584b2790ad6$var$eos === undefined) $5171b584b2790ad6$var$eos = (parcelRequire("38DOk"));
    $5171b584b2790ad6$var$eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if ($5171b584b2790ad6$var$isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new $5171b584b2790ad6$var$ERR_STREAM_DESTROYED("pipe"));
    };
}
function $5171b584b2790ad6$var$call(fn) {
    fn();
}
function $5171b584b2790ad6$var$pipe(from, to) {
    return from.pipe(to);
}
function $5171b584b2790ad6$var$popCallback(streams) {
    if (!streams.length) return $5171b584b2790ad6$var$noop;
    if (typeof streams[streams.length - 1] !== "function") return $5171b584b2790ad6$var$noop;
    return streams.pop();
}
function $5171b584b2790ad6$var$pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = $5171b584b2790ad6$var$popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new $5171b584b2790ad6$var$ERR_MISSING_ARGS("streams");
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return $5171b584b2790ad6$var$destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach($5171b584b2790ad6$var$call);
            if (reading) return;
            destroys.forEach($5171b584b2790ad6$var$call);
            callback(error);
        });
    });
    return streams.reduce($5171b584b2790ad6$var$pipe);
}
module.exports = $5171b584b2790ad6$var$pipeline;

});



const $09be3d43e9d44af2$export$82f8df700a244a95 = [
    "darwin-x64",
    "linux-x64",
    "win32-x64"
];



function $0b247b6288277a12$export$c499093521e352b1(targetString) {
    return (0, $09be3d43e9d44af2$export$82f8df700a244a95).includes(targetString);
}
function $0b247b6288277a12$export$54acae3e6c7216cb(target) {
    const targetString = `${target.platform}-${target.arch}`;
    if (!$0b247b6288277a12$export$c499093521e352b1(targetString)) return "untargeted";
    return targetString;
}
function $0b247b6288277a12$export$aacb940844e655b9(targetOption) {
    let target;
    // if `options.target` is false, don't use a target for the build
    if (targetOption === false) target = null;
    else if (targetOption === undefined) target = {
        platform: process.platform,
        arch: process.arch
    };
    else {
        const [platform, arch] = targetOption.split("-");
        if (platform === undefined || arch === undefined) throw new Error(`Invalid target: ${targetOption}`);
        target = {
            platform: platform,
            arch: arch
        };
    }
    return target;
}








var $ec8669dea71015f9$exports = {};
"use strict";

var $46e4ed69ddfc08f1$exports = {};
"use strict";

var $f87cdc8126a06970$exports = {};
"use strict";

var $5202c2b7164879d6$exports = {};
const $5202c2b7164879d6$var$isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";

const $5202c2b7164879d6$var$COLON = $5202c2b7164879d6$var$isWindows ? ";" : ":";
var $15a631dabb82f074$exports = {};

var $15a631dabb82f074$var$core;


if (process.platform === "win32" || $parcel$global.TESTING_WINDOWS) $15a631dabb82f074$var$core = (parcelRequire("ijniW"));
else $15a631dabb82f074$var$core = (parcelRequire("1dBIs"));
$15a631dabb82f074$exports = $15a631dabb82f074$var$isexe;
$15a631dabb82f074$var$isexe.sync = $15a631dabb82f074$var$sync;
function $15a631dabb82f074$var$isexe(path, options, cb) {
    if (typeof options === "function") {
        cb = options;
        options = {};
    }
    if (!cb) {
        if (typeof Promise !== "function") throw new TypeError("callback not provided");
        return new Promise(function(resolve, reject) {
            $15a631dabb82f074$var$isexe(path, options || {}, function(er, is) {
                if (er) reject(er);
                else resolve(is);
            });
        });
    }
    $15a631dabb82f074$var$core(path, options || {}, function(er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
            if (er.code === "EACCES" || options && options.ignoreErrors) {
                er = null;
                is = false;
            }
        }
        cb(er, is);
    });
}
function $15a631dabb82f074$var$sync(path, options) {
    // my kingdom for a filtered catch
    try {
        return $15a631dabb82f074$var$core.sync(path, options || {});
    } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") return false;
        else throw er;
    }
}


const $5202c2b7164879d6$var$getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
        code: "ENOENT"
    });
const $5202c2b7164879d6$var$getPathInfo = (cmd, opt)=>{
    const colon = opt.colon || $5202c2b7164879d6$var$COLON;
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    const pathEnv = cmd.match(/\//) || $5202c2b7164879d6$var$isWindows && cmd.match(/\\/) ? [
        ""
    ] : [
        // windows always checks the cwd first
        ...$5202c2b7164879d6$var$isWindows ? [
            process.cwd()
        ] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ "").split(colon)
    ];
    const pathExtExe = $5202c2b7164879d6$var$isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = $5202c2b7164879d6$var$isWindows ? pathExtExe.split(colon) : [
        ""
    ];
    if ($5202c2b7164879d6$var$isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "") pathExt.unshift("");
    }
    return {
        pathEnv: pathEnv,
        pathExt: pathExt,
        pathExtExe: pathExtExe
    };
};
const $5202c2b7164879d6$var$which = (cmd, opt, cb)=>{
    if (typeof opt === "function") {
        cb = opt;
        opt = {};
    }
    if (!opt) opt = {};
    const { pathEnv: pathEnv, pathExt: pathExt, pathExtExe: pathExtExe } = $5202c2b7164879d6$var$getPathInfo(cmd, opt);
    const found = [];
    const step = (i)=>new Promise((resolve, reject)=>{
            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject($5202c2b7164879d6$var$getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = $dAk3n$path.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
        });
    const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
            if (ii === pathExt.length) return resolve(step(i + 1));
            const ext = pathExt[ii];
            $15a631dabb82f074$exports(p + ext, {
                pathExt: pathExtExe
            }, (er, is)=>{
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return resolve(p + ext);
                }
                return resolve(subStep(p, i, ii + 1));
            });
        });
    return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
};
const $5202c2b7164879d6$var$whichSync = (cmd, opt)=>{
    opt = opt || {};
    const { pathEnv: pathEnv, pathExt: pathExt, pathExtExe: pathExtExe } = $5202c2b7164879d6$var$getPathInfo(cmd, opt);
    const found = [];
    for(let i = 0; i < pathEnv.length; i++){
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = $dAk3n$path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for(let j = 0; j < pathExt.length; j++){
            const cur = p + pathExt[j];
            try {
                const is = $15a631dabb82f074$exports.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw $5202c2b7164879d6$var$getNotFoundError(cmd);
};
$5202c2b7164879d6$exports = $5202c2b7164879d6$var$which;
$5202c2b7164879d6$var$which.sync = $5202c2b7164879d6$var$whichSync;


var $5dab73ee643f3585$exports = {};
"use strict";
const $5dab73ee643f3585$var$pathKey = (options = {})=>{
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") return "PATH";
    return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === "PATH") || "Path";
};
$5dab73ee643f3585$exports = $5dab73ee643f3585$var$pathKey;
// TODO: Remove this for the next major release
$5dab73ee643f3585$exports.default = $5dab73ee643f3585$var$pathKey;


function $f87cdc8126a06970$var$resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) try {
        process.chdir(parsed.options.cwd);
    } catch (err) {
    /* Empty */ }
    let resolved;
    try {
        resolved = $5202c2b7164879d6$exports.sync(parsed.command, {
            path: env[$5dab73ee643f3585$exports({
                env: env
            })],
            pathExt: withoutPathExt ? $dAk3n$path.delimiter : undefined
        });
    } catch (e) {
    /* Empty */ } finally{
        if (shouldSwitchCwd) process.chdir(cwd);
    }
    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) resolved = $dAk3n$path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    return resolved;
}
function $f87cdc8126a06970$var$resolveCommand(parsed) {
    return $f87cdc8126a06970$var$resolveCommandAttempt(parsed) || $f87cdc8126a06970$var$resolveCommandAttempt(parsed, true);
}
$f87cdc8126a06970$exports = $f87cdc8126a06970$var$resolveCommand;


var $9eb18b08aeb8520f$export$ae50443ffc990749;
var $9eb18b08aeb8520f$export$6ea29ee575e3f5ff;
"use strict";
// See http://www.robvanderwoude.com/escapechars.php
const $9eb18b08aeb8520f$var$metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function $9eb18b08aeb8520f$var$escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace($9eb18b08aeb8520f$var$metaCharsRegExp, "^$1");
    return arg;
}
function $9eb18b08aeb8520f$var$escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;
    // Algorithm below is based on https://qntm.org/cmd
    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, "$1$1");
    // All other backslashes occur literally
    // Quote the whole thing:
    arg = `"${arg}"`;
    // Escape meta chars
    arg = arg.replace($9eb18b08aeb8520f$var$metaCharsRegExp, "^$1");
    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) arg = arg.replace($9eb18b08aeb8520f$var$metaCharsRegExp, "^$1");
    return arg;
}
$9eb18b08aeb8520f$export$ae50443ffc990749 = $9eb18b08aeb8520f$var$escapeCommand;
$9eb18b08aeb8520f$export$6ea29ee575e3f5ff = $9eb18b08aeb8520f$var$escapeArgument;


var $6288ccc793cd38c8$exports = {};
"use strict";

var $5542c94aac1939e1$exports = {};
"use strict";
var $95fdc74ebcf13a1a$exports = {};
"use strict";
$95fdc74ebcf13a1a$exports = /^#!(.*)/;


$5542c94aac1939e1$exports = (string = "")=>{
    const match = string.match($95fdc74ebcf13a1a$exports);
    if (!match) return null;
    const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path.split("/").pop();
    if (binary === "env") return argument;
    return argument ? `${binary} ${argument}` : binary;
};


function $6288ccc793cd38c8$var$readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
        fd = $dAk3n$fs.openSync(command, "r");
        $dAk3n$fs.readSync(fd, buffer, 0, size, 0);
        $dAk3n$fs.closeSync(fd);
    } catch (e) {}
    // Attempt to extract shebang (null is returned if not a shebang)
    return $5542c94aac1939e1$exports(buffer.toString());
}
$6288ccc793cd38c8$exports = $6288ccc793cd38c8$var$readShebang;


const $46e4ed69ddfc08f1$var$isWin = process.platform === "win32";
const $46e4ed69ddfc08f1$var$isExecutableRegExp = /\.(?:com|exe)$/i;
const $46e4ed69ddfc08f1$var$isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function $46e4ed69ddfc08f1$var$detectShebang(parsed) {
    parsed.file = $f87cdc8126a06970$exports(parsed);
    const shebang = parsed.file && $6288ccc793cd38c8$exports(parsed.file);
    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return $f87cdc8126a06970$exports(parsed);
    }
    return parsed.file;
}
function $46e4ed69ddfc08f1$var$parseNonShell(parsed) {
    if (!$46e4ed69ddfc08f1$var$isWin) return parsed;
    // Detect & add support for shebangs
    const commandFile = $46e4ed69ddfc08f1$var$detectShebang(parsed);
    // We don't need a shell if the command filename is an executable
    const needsShell = !$46e4ed69ddfc08f1$var$isExecutableRegExp.test(commandFile);
    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = $46e4ed69ddfc08f1$var$isCmdShimRegExp.test(commandFile);
        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = $dAk3n$path.normalize(parsed.command);
        // Escape command & arguments
        parsed.command = $9eb18b08aeb8520f$export$ae50443ffc990749(parsed.command);
        parsed.args = parsed.args.map((arg)=>$9eb18b08aeb8520f$export$6ea29ee575e3f5ff(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [
            parsed.command
        ].concat(parsed.args).join(" ");
        parsed.args = [
            "/d",
            "/s",
            "/c",
            `"${shellCommand}"`
        ];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }
    return parsed;
}
function $46e4ed69ddfc08f1$var$parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }
    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original
    // Build our parsed object
    const parsed = {
        command: command,
        args: args,
        options: options,
        file: undefined,
        original: {
            command: command,
            args: args
        }
    };
    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : $46e4ed69ddfc08f1$var$parseNonShell(parsed);
}
$46e4ed69ddfc08f1$exports = $46e4ed69ddfc08f1$var$parse;


var $88805f0a7d3daef8$exports = {};
"use strict";
const $88805f0a7d3daef8$var$isWin = process.platform === "win32";
function $88805f0a7d3daef8$var$notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
    });
}
function $88805f0a7d3daef8$var$hookChildProcess(cp, parsed) {
    if (!$88805f0a7d3daef8$var$isWin) return;
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === "exit") {
            const err = $88805f0a7d3daef8$var$verifyENOENT(arg1, parsed, "spawn");
            if (err) return originalEmit.call(cp, "error", err);
        }
        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}
function $88805f0a7d3daef8$var$verifyENOENT(status, parsed) {
    if ($88805f0a7d3daef8$var$isWin && status === 1 && !parsed.file) return $88805f0a7d3daef8$var$notFoundError(parsed.original, "spawn");
    return null;
}
function $88805f0a7d3daef8$var$verifyENOENTSync(status, parsed) {
    if ($88805f0a7d3daef8$var$isWin && status === 1 && !parsed.file) return $88805f0a7d3daef8$var$notFoundError(parsed.original, "spawnSync");
    return null;
}
$88805f0a7d3daef8$exports = {
    hookChildProcess: $88805f0a7d3daef8$var$hookChildProcess,
    verifyENOENT: $88805f0a7d3daef8$var$verifyENOENT,
    verifyENOENTSync: $88805f0a7d3daef8$var$verifyENOENTSync,
    notFoundError: $88805f0a7d3daef8$var$notFoundError
};


function $ec8669dea71015f9$var$spawn(command, args, options) {
    // Parse the arguments
    const parsed = $46e4ed69ddfc08f1$exports(command, args, options);
    // Spawn the child process
    const spawned = $dAk3n$child_process.spawn(parsed.command, parsed.args, parsed.options);
    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    $88805f0a7d3daef8$exports.hookChildProcess(spawned, parsed);
    return spawned;
}
function $ec8669dea71015f9$var$spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = $46e4ed69ddfc08f1$exports(command, args, options);
    // Spawn the child process
    const result = $dAk3n$child_process.spawnSync(parsed.command, parsed.args, parsed.options);
    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || $88805f0a7d3daef8$exports.verifyENOENTSync(result.status, parsed);
    return result;
}
$ec8669dea71015f9$exports = $ec8669dea71015f9$var$spawn;
$ec8669dea71015f9$exports.spawn = $ec8669dea71015f9$var$spawn;
$ec8669dea71015f9$exports.sync = $ec8669dea71015f9$var$spawnSync;
$ec8669dea71015f9$exports._parse = $46e4ed69ddfc08f1$exports;
$ec8669dea71015f9$exports._enoent = $88805f0a7d3daef8$exports;


function $7aaedcc1d0c00e6c$export$2e2bcd8739ae039(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) input = input.slice(0, -1);
    if (input[input.length - 1] === CR) input = input.slice(0, -1);
    return input;
}





function $fb08467c4320d9f4$export$2e2bcd8739ae039(options = {}) {
    const { env: env = process.env, platform: platform = process.platform } = options;
    if (platform !== "win32") return "PATH";
    return Object.keys(env).reverse().find((key)=>key.toUpperCase() === "PATH") || "Path";
}


function $66683530f9da98f2$export$62a298cbef08d65c(options = {}) {
    const { cwd: cwd = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).cwd(), path: path_ = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env[(0, $fb08467c4320d9f4$export$2e2bcd8739ae039)()], execPath: execPath = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).execPath } = options;
    let previous;
    const cwdString = cwd instanceof URL ? (0, ($parcel$interopDefault($dAk3n$nodeurl))).fileURLToPath(cwd) : cwd;
    let cwdPath = (0, ($parcel$interopDefault($dAk3n$nodepath))).resolve(cwdString);
    const result = [];
    while(previous !== cwdPath){
        result.push((0, ($parcel$interopDefault($dAk3n$nodepath))).join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = (0, ($parcel$interopDefault($dAk3n$nodepath))).resolve(cwdPath, "..");
    }
    // Ensure the running `node` binary is used.
    result.push((0, ($parcel$interopDefault($dAk3n$nodepath))).resolve(cwdString, execPath, ".."));
    return [
        ...result,
        path_
    ].join((0, ($parcel$interopDefault($dAk3n$nodepath))).delimiter);
}
function $66683530f9da98f2$export$340e1fbaac04248b({ env: env = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env, ...options } = {}) {
    env = {
        ...env
    };
    const path = (0, $fb08467c4320d9f4$export$2e2bcd8739ae039)({
        env: env
    });
    options.path = env[path];
    env[path] = $66683530f9da98f2$export$62a298cbef08d65c(options);
    return env;
}


const $c529529f3a2ecf4a$var$copyProperty = (to, from, property, ignoreNonConfigurable)=>{
    // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.
    // `Function#prototype` is non-writable and non-configurable so can never be modified.
    if (property === "length" || property === "prototype") return;
    // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.
    if (property === "arguments" || property === "caller") return;
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    if (!$c529529f3a2ecf4a$var$canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) return;
    Object.defineProperty(to, property, fromDescriptor);
};
// `Object.defineProperty()` throws if the property exists, is not configurable and either:
// - one its descriptors is changed
// - it is non-writable and its value is changed
const $c529529f3a2ecf4a$var$canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const $c529529f3a2ecf4a$var$changePrototype = (to, from)=>{
    const fromPrototype = Object.getPrototypeOf(from);
    if (fromPrototype === Object.getPrototypeOf(to)) return;
    Object.setPrototypeOf(to, fromPrototype);
};
const $c529529f3a2ecf4a$var$wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
const $c529529f3a2ecf4a$var$toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const $c529529f3a2ecf4a$var$toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.
// We use `bind()` instead of a closure for the same reason.
// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.
const $c529529f3a2ecf4a$var$changeToString = (to, from, name)=>{
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = $c529529f3a2ecf4a$var$wrappedToString.bind(null, withName, from.toString());
    // Ensure `to.toString.toString` is non-enumerable and has the same `same`
    Object.defineProperty(newToString, "name", $c529529f3a2ecf4a$var$toStringName);
    Object.defineProperty(to, "toString", {
        ...$c529529f3a2ecf4a$var$toStringDescriptor,
        value: newToString
    });
};
function $c529529f3a2ecf4a$export$2e2bcd8739ae039(to, from, { ignoreNonConfigurable: ignoreNonConfigurable = false } = {}) {
    const { name: name } = to;
    for (const property of Reflect.ownKeys(from))$c529529f3a2ecf4a$var$copyProperty(to, from, property, ignoreNonConfigurable);
    $c529529f3a2ecf4a$var$changePrototype(to, from);
    $c529529f3a2ecf4a$var$changeToString(to, from, name);
    return to;
}


const $c1aa4a45ee0cdc40$var$calledFunctions = new WeakMap();
const $c1aa4a45ee0cdc40$var$onetime = (function_, options = {})=>{
    if (typeof function_ !== "function") throw new TypeError("Expected a function");
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime = function(...arguments_) {
        $c1aa4a45ee0cdc40$var$calledFunctions.set(onetime, ++callCount);
        if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
        } else if (options.throw === true) throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
    };
    (0, $c529529f3a2ecf4a$export$2e2bcd8739ae039)(onetime, function_);
    $c1aa4a45ee0cdc40$var$calledFunctions.set(onetime, callCount);
    return onetime;
};
$c1aa4a45ee0cdc40$var$onetime.callCount = (function_)=>{
    if (!$c1aa4a45ee0cdc40$var$calledFunctions.has(function_)) throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return $c1aa4a45ee0cdc40$var$calledFunctions.get(function_);
};
var $c1aa4a45ee0cdc40$export$2e2bcd8739ae039 = $c1aa4a45ee0cdc40$var$onetime;




const $d760098e32dac1bf$export$e221a98f4fd84d36 = ()=>{
    const length = $d760098e32dac1bf$export$dc8812f2f8882ff4 - $d760098e32dac1bf$var$SIGRTMIN + 1;
    return Array.from({
        length: length
    }, $d760098e32dac1bf$var$getRealtimeSignal);
};
const $d760098e32dac1bf$var$getRealtimeSignal = (value, index)=>({
        name: `SIGRT${index + 1}`,
        number: $d760098e32dac1bf$var$SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
    });
const $d760098e32dac1bf$var$SIGRTMIN = 34;
const $d760098e32dac1bf$export$dc8812f2f8882ff4 = 64;



const $29d8729639677f44$export$a43bf6822cc694af = [
    {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
    },
    {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
    },
    {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
    },
    {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
    },
    {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
    },
    {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
    },
    {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
    },
    {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
    },
    {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
    },
    {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
    },
    {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
    },
    {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
    },
    {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
    },
    {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
    },
    {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
    },
    {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
    },
    {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
    },
    {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
    },
    {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
    },
    {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
    },
    {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
    },
    {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
    },
    {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
    },
    {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
    },
    {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
    },
    {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
    },
    {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
    },
    {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
    },
    {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
    },
    {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
    },
    {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
    },
    {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
    },
    {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
    },
    {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
    }
];



const $89b457ba110ba681$export$c50078d4faa171f0 = ()=>{
    const realtimeSignals = (0, $d760098e32dac1bf$export$e221a98f4fd84d36)();
    const signals = [
        ...(0, $29d8729639677f44$export$a43bf6822cc694af),
        ...realtimeSignals
    ].map($89b457ba110ba681$var$normalizeSignal);
    return signals;
};
const $89b457ba110ba681$var$normalizeSignal = ({ name: name, number: defaultNumber, description: description, action: action, forced: forced = false, standard: standard })=>{
    const { signals: { [name]: constantSignal } } = (0, $dAk3n$nodeos.constants);
    const supported = constantSignal !== undefined;
    const number = supported ? constantSignal : defaultNumber;
    return {
        name: name,
        number: number,
        description: description,
        supported: supported,
        action: action,
        forced: forced,
        standard: standard
    };
};


const $6e6f6569f5bd0bcb$var$getSignalsByName = ()=>{
    const signals = (0, $89b457ba110ba681$export$c50078d4faa171f0)();
    return Object.fromEntries(signals.map($6e6f6569f5bd0bcb$var$getSignalByName));
};
const $6e6f6569f5bd0bcb$var$getSignalByName = ({ name: name, number: number, description: description, supported: supported, action: action, forced: forced, standard: standard })=>[
        name,
        {
            name: name,
            number: number,
            description: description,
            supported: supported,
            action: action,
            forced: forced,
            standard: standard
        }
    ];
const $6e6f6569f5bd0bcb$export$c3fcb39d6848c78d = $6e6f6569f5bd0bcb$var$getSignalsByName();
const $6e6f6569f5bd0bcb$var$getSignalsByNumber = ()=>{
    const signals = (0, $89b457ba110ba681$export$c50078d4faa171f0)();
    const length = (0, $d760098e32dac1bf$export$dc8812f2f8882ff4) + 1;
    const signalsA = Array.from({
        length: length
    }, (value, number)=>$6e6f6569f5bd0bcb$var$getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
};
const $6e6f6569f5bd0bcb$var$getSignalByNumber = (number, signals)=>{
    const signal = $6e6f6569f5bd0bcb$var$findSignalByNumber(number, signals);
    if (signal === undefined) return {};
    const { name: name, description: description, supported: supported, action: action, forced: forced, standard: standard } = signal;
    return {
        [number]: {
            name: name,
            number: number,
            description: description,
            supported: supported,
            action: action,
            forced: forced,
            standard: standard
        }
    };
};
const $6e6f6569f5bd0bcb$var$findSignalByNumber = (number, signals)=>{
    const signal = signals.find(({ name: name })=>(0, $dAk3n$nodeos.constants).signals[name] === number);
    if (signal !== undefined) return signal;
    return signals.find((signalA)=>signalA.number === number);
};
const $6e6f6569f5bd0bcb$export$12f57f97a08d2468 = $6e6f6569f5bd0bcb$var$getSignalsByNumber();


const $245bea6daf0c3a31$var$getErrorPrefix = ({ timedOut: timedOut, timeout: timeout, errorCode: errorCode, signal: signal, signalDescription: signalDescription, exitCode: exitCode, isCanceled: isCanceled })=>{
    if (timedOut) return `timed out after ${timeout} milliseconds`;
    if (isCanceled) return "was canceled";
    if (errorCode !== undefined) return `failed with ${errorCode}`;
    if (signal !== undefined) return `was killed with ${signal} (${signalDescription})`;
    if (exitCode !== undefined) return `failed with exit code ${exitCode}`;
    return "failed";
};
const $245bea6daf0c3a31$export$5a4bb2b1c89bdce7 = ({ stdout: stdout, stderr: stderr, all: all, error: error, signal: signal, exitCode: exitCode, command: command, escapedCommand: escapedCommand, timedOut: timedOut, isCanceled: isCanceled, killed: killed, parsed: { options: { timeout: timeout, cwd: cwd = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).cwd() } } })=>{
    // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
    // We normalize them to `undefined`
    exitCode = exitCode === null ? undefined : exitCode;
    signal = signal === null ? undefined : signal;
    const signalDescription = signal === undefined ? undefined : (0, $6e6f6569f5bd0bcb$export$c3fcb39d6848c78d)[signal].description;
    const errorCode = error && error.code;
    const prefix = $245bea6daf0c3a31$var$getErrorPrefix({
        timedOut: timedOut,
        timeout: timeout,
        errorCode: errorCode,
        signal: signal,
        signalDescription: signalDescription,
        exitCode: exitCode,
        isCanceled: isCanceled
    });
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [
        shortMessage,
        stderr,
        stdout
    ].filter(Boolean).join("\n");
    if (isError) {
        error.originalMessage = error.message;
        error.message = message;
    } else error = new Error(message);
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    error.cwd = cwd;
    if (all !== undefined) error.all = all;
    if ("bufferedData" in error) delete error.bufferedData;
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
};


const $fb3d481f861f1605$var$aliases = [
    "stdin",
    "stdout",
    "stderr"
];
const $fb3d481f861f1605$var$hasAlias = (options)=>$fb3d481f861f1605$var$aliases.some((alias)=>options[alias] !== undefined);
const $fb3d481f861f1605$export$a581401a57fac02e = (options)=>{
    if (!options) return;
    const { stdio: stdio } = options;
    if (stdio === undefined) return $fb3d481f861f1605$var$aliases.map((alias)=>options[alias]);
    if ($fb3d481f861f1605$var$hasAlias(options)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${$fb3d481f861f1605$var$aliases.map((alias)=>`\`${alias}\``).join(", ")}`);
    if (typeof stdio === "string") return stdio;
    if (!Array.isArray(stdio)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    const length = Math.max(stdio.length, $fb3d481f861f1605$var$aliases.length);
    return Array.from({
        length: length
    }, (value, index)=>stdio[index]);
};
const $fb3d481f861f1605$export$889423b478ae2ba = (options)=>{
    const stdio = $fb3d481f861f1605$export$a581401a57fac02e(options);
    if (stdio === "ipc") return "ipc";
    if (stdio === undefined || typeof stdio === "string") return [
        stdio,
        stdio,
        stdio,
        "ipc"
    ];
    if (stdio.includes("ipc")) return stdio;
    return [
        ...stdio,
        "ipc"
    ];
};



// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */ const $03698c24df621e43$export$d9bf27e17f952bbb = [];
$03698c24df621e43$export$d9bf27e17f952bbb.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") $03698c24df621e43$export$d9bf27e17f952bbb.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
if (process.platform === "linux") $03698c24df621e43$export$d9bf27e17f952bbb.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");


const $beb782e1dc9036a8$var$processOk = (process)=>!!process && typeof process === "object" && typeof process.removeListener === "function" && typeof process.emit === "function" && typeof process.reallyExit === "function" && typeof process.listeners === "function" && typeof process.kill === "function" && typeof process.pid === "number" && typeof process.on === "function";
const $beb782e1dc9036a8$var$kExitEmitter = Symbol.for("signal-exit emitter");
const $beb782e1dc9036a8$var$global = globalThis;
const $beb782e1dc9036a8$var$ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
class $beb782e1dc9036a8$var$Emitter {
    emitted = {
        afterExit: false,
        exit: false
    };
    listeners = {
        afterExit: [],
        exit: []
    };
    count = 0;
    id = Math.random();
    constructor(){
        if ($beb782e1dc9036a8$var$global[$beb782e1dc9036a8$var$kExitEmitter]) return $beb782e1dc9036a8$var$global[$beb782e1dc9036a8$var$kExitEmitter];
        $beb782e1dc9036a8$var$ObjectDefineProperty($beb782e1dc9036a8$var$global, $beb782e1dc9036a8$var$kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */ if (i === -1) return;
        /* c8 ignore stop */ if (i === 0 && list.length === 1) list.length = 0;
        else list.splice(i, 1);
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) return false;
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev])ret = fn(code, signal) === true || ret;
        if (ev === "exit") ret = this.emit("afterExit", code, signal) || ret;
        return ret;
    }
}
class $beb782e1dc9036a8$var$SignalExitBase {
}
const $beb782e1dc9036a8$var$signalExitWrap = (handler)=>{
    return {
        onExit (cb, opts) {
            return handler.onExit(cb, opts);
        },
        load () {
            return handler.load();
        },
        unload () {
            return handler.unload();
        }
    };
};
class $beb782e1dc9036a8$var$SignalExitFallback extends $beb782e1dc9036a8$var$SignalExitBase {
    onExit() {
        return ()=>{};
    }
    load() {}
    unload() {}
}
class $beb782e1dc9036a8$var$SignalExit extends $beb782e1dc9036a8$var$SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */ #hupSig = $beb782e1dc9036a8$var$process.platform === "win32" ? "SIGINT" : "SIGHUP";
    /* c8 ignore stop */ #emitter = new $beb782e1dc9036a8$var$Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process){
        super();
        this.#process = process;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of (0, $03698c24df621e43$export$d9bf27e17f952bbb))this.#sigListeners[sig] = ()=>{
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            const listeners = this.#process.listeners(sig);
            let { count: count } = this.#emitter;
            // This is a workaround for the fact that signal-exit v3 and signal
            // exit v4 are not aware of each other, and each will attempt to let
            // the other handle it, so neither of them do. To correct this, we
            // detect if we're the only handler *except* for previous versions
            // of signal-exit, and increment by the count of listeners it has
            // created.
            /* c8 ignore start */ const p = process;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") count += p.__signal_exit_emitter__.count;
            /* c8 ignore stop */ if (listeners.length === count) {
                this.unload();
                const ret = this.#emitter.emit("exit", null, sig);
                /* c8 ignore start */ const s = sig === "SIGHUP" ? this.#hupSig : sig;
                if (!ret) process.kill(process.pid, s);
            /* c8 ignore stop */ }
        };
        this.#originalProcessReallyExit = process.reallyExit;
        this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */ if (!$beb782e1dc9036a8$var$processOk(this.#process)) return ()=>{};
        /* c8 ignore stop */ if (this.#loaded === false) this.load();
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        this.#emitter.on(ev, cb);
        return ()=>{
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) this.unload();
        };
    }
    load() {
        if (this.#loaded) return;
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of (0, $03698c24df621e43$export$d9bf27e17f952bbb))try {
            const fn = this.#sigListeners[sig];
            if (fn) this.#process.on(sig, fn);
        } catch (_) {}
        this.#process.emit = (ev, ...a)=>{
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code)=>{
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) return;
        this.#loaded = false;
        (0, $03698c24df621e43$export$d9bf27e17f952bbb).forEach((sig)=>{
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */ if (!listener) throw new Error("Listener not defined for signal: " + sig);
            /* c8 ignore stop */ try {
                this.#process.removeListener(sig, listener);
            /* c8 ignore start */ } catch (_) {}
        /* c8 ignore stop */ });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */ if (!$beb782e1dc9036a8$var$processOk(this.#process)) return 0;
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */ this.#emitter.emit("exit", this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === "exit" && $beb782e1dc9036a8$var$processOk(this.#process)) {
            if (typeof args[0] === "number") this.#process.exitCode = args[0];
            /* c8 ignore start */ const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */ this.#emitter.emit("exit", this.#process.exitCode, null);
            /* c8 ignore stop */ return ret;
        } else return og.call(this.#process, ev, ...args);
    }
}
const $beb782e1dc9036a8$var$process = globalThis.process;
const { onExit: /**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */ $beb782e1dc9036a8$export$47a57ed64c292d4f, load: /**
 * Load the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */ $beb782e1dc9036a8$export$11e63f7b0f3d9900, unload: /**
 * Unload the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */ $beb782e1dc9036a8$export$117f7ddab482d006 } = $beb782e1dc9036a8$var$signalExitWrap($beb782e1dc9036a8$var$processOk($beb782e1dc9036a8$var$process) ? new $beb782e1dc9036a8$var$SignalExit($beb782e1dc9036a8$var$process) : new $beb782e1dc9036a8$var$SignalExitFallback());


const $ba81a69748409cf4$var$DEFAULT_FORCE_KILL_TIMEOUT = 5000;
const $ba81a69748409cf4$export$971fa1b57c7f00b = (kill, signal = "SIGTERM", options = {})=>{
    const killResult = kill(signal);
    $ba81a69748409cf4$var$setKillTimeout(kill, signal, options, killResult);
    return killResult;
};
const $ba81a69748409cf4$var$setKillTimeout = (kill, signal, options, killResult)=>{
    if (!$ba81a69748409cf4$var$shouldForceKill(signal, options, killResult)) return;
    const timeout = $ba81a69748409cf4$var$getForceKillAfterTimeout(options);
    const t = setTimeout(()=>{
        kill("SIGKILL");
    }, timeout);
    // Guarded because there's no `.unref()` when `execa` is used in the renderer
    // process in Electron. This cannot be tested since we don't run tests in
    // Electron.
    // istanbul ignore else
    if (t.unref) t.unref();
};
const $ba81a69748409cf4$var$shouldForceKill = (signal, { forceKillAfterTimeout: forceKillAfterTimeout }, killResult)=>$ba81a69748409cf4$var$isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
const $ba81a69748409cf4$var$isSigterm = (signal)=>signal === (0, ($parcel$interopDefault($dAk3n$nodeos))).constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
const $ba81a69748409cf4$var$getForceKillAfterTimeout = ({ forceKillAfterTimeout: forceKillAfterTimeout = true })=>{
    if (forceKillAfterTimeout === true) return $ba81a69748409cf4$var$DEFAULT_FORCE_KILL_TIMEOUT;
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    return forceKillAfterTimeout;
};
const $ba81a69748409cf4$export$667e13cd9b70ca17 = (spawned, context)=>{
    const killResult = spawned.kill();
    if (killResult) context.isCanceled = true;
};
const $ba81a69748409cf4$var$timeoutKill = (spawned, signal, reject)=>{
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {
        timedOut: true,
        signal: signal
    }));
};
const $ba81a69748409cf4$export$6bcc98999eb82896 = (spawned, { timeout: timeout, killSignal: killSignal = "SIGTERM" }, spawnedPromise)=>{
    if (timeout === 0 || timeout === undefined) return spawnedPromise;
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject)=>{
        timeoutId = setTimeout(()=>{
            $ba81a69748409cf4$var$timeoutKill(spawned, killSignal, reject);
        }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(()=>{
        clearTimeout(timeoutId);
    });
    return Promise.race([
        timeoutPromise,
        safeSpawnedPromise
    ]);
};
const $ba81a69748409cf4$export$3186f8866f616f9f = ({ timeout: timeout })=>{
    if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
};
const $ba81a69748409cf4$export$79fc3056c9ca4ada = async (spawned, { cleanup: cleanup, detached: detached }, timedPromise)=>{
    if (!cleanup || detached) return timedPromise;
    const removeExitHandler = (0, $beb782e1dc9036a8$export$47a57ed64c292d4f)(()=>{
        spawned.kill();
    });
    return timedPromise.finally(()=>{
        removeExitHandler();
    });
};




function $66cfbb89b6a89833$export$294a92d8f7b3979(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function $66cfbb89b6a89833$export$b58a61c52edb4f66(stream) {
    return $66cfbb89b6a89833$export$294a92d8f7b3979(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function $66cfbb89b6a89833$export$ac613ff475b69d05(stream) {
    return $66cfbb89b6a89833$export$294a92d8f7b3979(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function $66cfbb89b6a89833$export$f92d8ccfaec172d4(stream) {
    return $66cfbb89b6a89833$export$b58a61c52edb4f66(stream) && $66cfbb89b6a89833$export$ac613ff475b69d05(stream);
}
function $66cfbb89b6a89833$export$3053cdc6f2e088fd(stream) {
    return $66cfbb89b6a89833$export$f92d8ccfaec172d4(stream) && typeof stream._transform === "function";
}


const $5bb4232d9b386f5a$var$isExecaChildProcess = (target)=>target instanceof (0, $dAk3n$nodechild_process.ChildProcess) && typeof target.then === "function";
const $5bb4232d9b386f5a$var$pipeToTarget = (spawned, streamName, target)=>{
    if (typeof target === "string") {
        spawned[streamName].pipe((0, $dAk3n$nodefs.createWriteStream)(target));
        return spawned;
    }
    if ((0, $66cfbb89b6a89833$export$b58a61c52edb4f66)(target)) {
        spawned[streamName].pipe(target);
        return spawned;
    }
    if (!$5bb4232d9b386f5a$var$isExecaChildProcess(target)) throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
    if (!(0, $66cfbb89b6a89833$export$b58a61c52edb4f66)(target.stdin)) throw new TypeError("The target child process's stdin must be available.");
    spawned[streamName].pipe(target.stdin);
    return target;
};
const $5bb4232d9b386f5a$export$14becf8d91886424 = (spawned)=>{
    if (spawned.stdout !== null) spawned.pipeStdout = $5bb4232d9b386f5a$var$pipeToTarget.bind(undefined, spawned, "stdout");
    if (spawned.stderr !== null) spawned.pipeStderr = $5bb4232d9b386f5a$var$pipeToTarget.bind(undefined, spawned, "stderr");
    if (spawned.all !== undefined) spawned.pipeAll = $5bb4232d9b386f5a$var$pipeToTarget.bind(undefined, spawned, "all");
};





const $4c2ffbe9158ead46$export$1c256c35a4a59b42 = async (stream, { init: init, convertChunk: convertChunk, getSize: getSize, truncateChunk: truncateChunk, addChunk: addChunk, getFinalChunk: getFinalChunk, finalize: finalize }, { maxBuffer: maxBuffer = Number.POSITIVE_INFINITY } = {})=>{
    if (!$4c2ffbe9158ead46$var$isAsyncIterable(stream)) throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
    const state = init();
    state.length = 0;
    try {
        for await (const chunk of stream){
            const chunkType = $4c2ffbe9158ead46$var$getChunkType(chunk);
            const convertedChunk = convertChunk[chunkType](chunk, state);
            $4c2ffbe9158ead46$var$appendChunk({
                convertedChunk: convertedChunk,
                state: state,
                getSize: getSize,
                truncateChunk: truncateChunk,
                addChunk: addChunk,
                maxBuffer: maxBuffer
            });
        }
        $4c2ffbe9158ead46$var$appendFinalChunk({
            state: state,
            convertChunk: convertChunk,
            getSize: getSize,
            truncateChunk: truncateChunk,
            addChunk: addChunk,
            getFinalChunk: getFinalChunk,
            maxBuffer: maxBuffer
        });
        return finalize(state);
    } catch (error) {
        error.bufferedData = finalize(state);
        throw error;
    }
};
const $4c2ffbe9158ead46$var$appendFinalChunk = ({ state: state, getSize: getSize, truncateChunk: truncateChunk, addChunk: addChunk, getFinalChunk: getFinalChunk, maxBuffer: maxBuffer })=>{
    const convertedChunk = getFinalChunk(state);
    if (convertedChunk !== undefined) $4c2ffbe9158ead46$var$appendChunk({
        convertedChunk: convertedChunk,
        state: state,
        getSize: getSize,
        truncateChunk: truncateChunk,
        addChunk: addChunk,
        maxBuffer: maxBuffer
    });
};
const $4c2ffbe9158ead46$var$appendChunk = ({ convertedChunk: convertedChunk, state: state, getSize: getSize, truncateChunk: truncateChunk, addChunk: addChunk, maxBuffer: maxBuffer })=>{
    const chunkSize = getSize(convertedChunk);
    const newLength = state.length + chunkSize;
    if (newLength <= maxBuffer) {
        $4c2ffbe9158ead46$var$addNewChunk(convertedChunk, state, addChunk, newLength);
        return;
    }
    const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
    if (truncatedChunk !== undefined) $4c2ffbe9158ead46$var$addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
    throw new $4c2ffbe9158ead46$export$8b174020ca647416();
};
const $4c2ffbe9158ead46$var$addNewChunk = (convertedChunk, state, addChunk, newLength)=>{
    state.contents = addChunk(convertedChunk, state, newLength);
    state.length = newLength;
};
const $4c2ffbe9158ead46$var$isAsyncIterable = (stream)=>typeof stream === "object" && stream !== null && typeof stream[Symbol.asyncIterator] === "function";
const $4c2ffbe9158ead46$var$getChunkType = (chunk)=>{
    const typeOfChunk = typeof chunk;
    if (typeOfChunk === "string") return "string";
    if (typeOfChunk !== "object" || chunk === null) return "others";
    // eslint-disable-next-line n/prefer-global/buffer
    if (globalThis.Buffer?.isBuffer(chunk)) return "buffer";
    const prototypeName = $4c2ffbe9158ead46$var$objectToString.call(chunk);
    if (prototypeName === "[object ArrayBuffer]") return "arrayBuffer";
    if (prototypeName === "[object DataView]") return "dataView";
    if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && $4c2ffbe9158ead46$var$objectToString.call(chunk.buffer) === "[object ArrayBuffer]") return "typedArray";
    return "others";
};
const { toString: $4c2ffbe9158ead46$var$objectToString } = Object.prototype;
class $4c2ffbe9158ead46$export$8b174020ca647416 extends Error {
    name = "MaxBufferError";
    constructor(){
        super("maxBuffer exceeded");
    }
}


const $5ee40b0a39bb1c5f$export$f0954fd7d5368655 = (value)=>value;
const $5ee40b0a39bb1c5f$export$8793edee2d425525 = ()=>undefined;
const $5ee40b0a39bb1c5f$export$a4ed46a44adba17a = ({ contents: contents })=>contents;
const $5ee40b0a39bb1c5f$export$b45a875019f2a051 = (chunk)=>{
    throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
const $5ee40b0a39bb1c5f$export$65adf12c35d668dc = (convertedChunk)=>convertedChunk.length;


async function $3052b9b80c7a6a78$export$a7494c5d4dd4a66a(stream, options) {
    return (0, $4c2ffbe9158ead46$export$1c256c35a4a59b42)(stream, $3052b9b80c7a6a78$var$arrayMethods, options);
}
const $3052b9b80c7a6a78$var$initArray = ()=>({
        contents: []
    });
const $3052b9b80c7a6a78$var$increment = ()=>1;
const $3052b9b80c7a6a78$var$addArrayChunk = (convertedChunk, { contents: contents })=>{
    contents.push(convertedChunk);
    return contents;
};
const $3052b9b80c7a6a78$var$arrayMethods = {
    init: $3052b9b80c7a6a78$var$initArray,
    convertChunk: {
        string: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655),
        buffer: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655),
        arrayBuffer: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655),
        dataView: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655),
        typedArray: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655),
        others: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655)
    },
    getSize: $3052b9b80c7a6a78$var$increment,
    truncateChunk: (0, $5ee40b0a39bb1c5f$export$8793edee2d425525),
    addChunk: $3052b9b80c7a6a78$var$addArrayChunk,
    getFinalChunk: (0, $5ee40b0a39bb1c5f$export$8793edee2d425525),
    finalize: (0, $5ee40b0a39bb1c5f$export$a4ed46a44adba17a)
};




async function $6ba69c89f185a10c$export$6f73525037c6bf50(stream, options) {
    return (0, $4c2ffbe9158ead46$export$1c256c35a4a59b42)(stream, $6ba69c89f185a10c$var$arrayBufferMethods, options);
}
const $6ba69c89f185a10c$var$initArrayBuffer = ()=>({
        contents: new ArrayBuffer(0)
    });
const $6ba69c89f185a10c$var$useTextEncoder = (chunk)=>$6ba69c89f185a10c$var$textEncoder.encode(chunk);
const $6ba69c89f185a10c$var$textEncoder = new TextEncoder();
const $6ba69c89f185a10c$var$useUint8Array = (chunk)=>new Uint8Array(chunk);
const $6ba69c89f185a10c$var$useUint8ArrayWithOffset = (chunk)=>new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
const $6ba69c89f185a10c$var$truncateArrayBufferChunk = (convertedChunk, chunkSize)=>convertedChunk.slice(0, chunkSize);
// `contents` is an increasingly growing `Uint8Array`.
const $6ba69c89f185a10c$var$addArrayBufferChunk = (convertedChunk, { contents: contents, length: previousLength }, length)=>{
    const newContents = $6ba69c89f185a10c$var$hasArrayBufferResize() ? $6ba69c89f185a10c$var$resizeArrayBuffer(contents, length) : $6ba69c89f185a10c$var$resizeArrayBufferSlow(contents, length);
    new Uint8Array(newContents).set(convertedChunk, previousLength);
    return newContents;
};
// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.
// This means its last bytes are zeroes (not stream data), which need to be
// trimmed at the end with `ArrayBuffer.slice()`.
const $6ba69c89f185a10c$var$resizeArrayBufferSlow = (contents, length)=>{
    if (length <= contents.byteLength) return contents;
    const arrayBuffer = new ArrayBuffer($6ba69c89f185a10c$var$getNewContentsLength(length));
    new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
    return arrayBuffer;
};
// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of
// the stream data. It does not include extraneous zeroes to trim at the end.
// The underlying `ArrayBuffer` does allocate a number of bytes that is a power
// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.
const $6ba69c89f185a10c$var$resizeArrayBuffer = (contents, length)=>{
    if (length <= contents.maxByteLength) {
        contents.resize(length);
        return contents;
    }
    const arrayBuffer = new ArrayBuffer(length, {
        maxByteLength: $6ba69c89f185a10c$var$getNewContentsLength(length)
    });
    new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
    return arrayBuffer;
};
// Retrieve the closest `length` that is both >= and a power of 2
const $6ba69c89f185a10c$var$getNewContentsLength = (length)=>$6ba69c89f185a10c$var$SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log($6ba69c89f185a10c$var$SCALE_FACTOR));
const $6ba69c89f185a10c$var$SCALE_FACTOR = 2;
const $6ba69c89f185a10c$var$finalizeArrayBuffer = ({ contents: contents, length: length })=>$6ba69c89f185a10c$var$hasArrayBufferResize() ? contents : contents.slice(0, length);
// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available
// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.
// eslint-disable-next-line no-warning-comments
// TODO: remove after dropping support for Node 20.
// eslint-disable-next-line no-warning-comments
// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available
const $6ba69c89f185a10c$var$hasArrayBufferResize = ()=>"resize" in ArrayBuffer.prototype;
const $6ba69c89f185a10c$var$arrayBufferMethods = {
    init: $6ba69c89f185a10c$var$initArrayBuffer,
    convertChunk: {
        string: $6ba69c89f185a10c$var$useTextEncoder,
        buffer: $6ba69c89f185a10c$var$useUint8Array,
        arrayBuffer: $6ba69c89f185a10c$var$useUint8Array,
        dataView: $6ba69c89f185a10c$var$useUint8ArrayWithOffset,
        typedArray: $6ba69c89f185a10c$var$useUint8ArrayWithOffset,
        others: (0, $5ee40b0a39bb1c5f$export$b45a875019f2a051)
    },
    getSize: (0, $5ee40b0a39bb1c5f$export$65adf12c35d668dc),
    truncateChunk: $6ba69c89f185a10c$var$truncateArrayBufferChunk,
    addChunk: $6ba69c89f185a10c$var$addArrayBufferChunk,
    getFinalChunk: (0, $5ee40b0a39bb1c5f$export$8793edee2d425525),
    finalize: $6ba69c89f185a10c$var$finalizeArrayBuffer
};



async function $71a07105f89a05cf$export$7043a390e4973a6(stream, options) {
    if (!("Buffer" in globalThis)) throw new Error("getStreamAsBuffer() is only supported in Node.js");
    try {
        return $71a07105f89a05cf$var$arrayBufferToNodeBuffer(await (0, $6ba69c89f185a10c$export$6f73525037c6bf50)(stream, options));
    } catch (error) {
        if (error.bufferedData !== undefined) error.bufferedData = $71a07105f89a05cf$var$arrayBufferToNodeBuffer(error.bufferedData);
        throw error;
    }
}
// eslint-disable-next-line n/prefer-global/buffer
const $71a07105f89a05cf$var$arrayBufferToNodeBuffer = (arrayBuffer)=>globalThis.Buffer.from(arrayBuffer);




async function $61bd305dd67296e1$export$555b886bc6905a7c(stream, options) {
    return (0, $4c2ffbe9158ead46$export$1c256c35a4a59b42)(stream, $61bd305dd67296e1$var$stringMethods, options);
}
const $61bd305dd67296e1$var$initString = ()=>({
        contents: "",
        textDecoder: new TextDecoder()
    });
const $61bd305dd67296e1$var$useTextDecoder = (chunk, { textDecoder: textDecoder })=>textDecoder.decode(chunk, {
        stream: true
    });
const $61bd305dd67296e1$var$addStringChunk = (convertedChunk, { contents: contents })=>contents + convertedChunk;
const $61bd305dd67296e1$var$truncateStringChunk = (convertedChunk, chunkSize)=>convertedChunk.slice(0, chunkSize);
const $61bd305dd67296e1$var$getFinalStringChunk = ({ textDecoder: textDecoder })=>{
    const finalChunk = textDecoder.decode();
    return finalChunk === "" ? undefined : finalChunk;
};
const $61bd305dd67296e1$var$stringMethods = {
    init: $61bd305dd67296e1$var$initString,
    convertChunk: {
        string: (0, $5ee40b0a39bb1c5f$export$f0954fd7d5368655),
        buffer: $61bd305dd67296e1$var$useTextDecoder,
        arrayBuffer: $61bd305dd67296e1$var$useTextDecoder,
        dataView: $61bd305dd67296e1$var$useTextDecoder,
        typedArray: $61bd305dd67296e1$var$useTextDecoder,
        others: (0, $5ee40b0a39bb1c5f$export$b45a875019f2a051)
    },
    getSize: (0, $5ee40b0a39bb1c5f$export$65adf12c35d668dc),
    truncateChunk: $61bd305dd67296e1$var$truncateStringChunk,
    addChunk: $61bd305dd67296e1$var$addStringChunk,
    getFinalChunk: $61bd305dd67296e1$var$getFinalStringChunk,
    finalize: (0, $5ee40b0a39bb1c5f$export$a4ed46a44adba17a)
};





var $b2f93a5f72bbb56b$exports = {};
"use strict";

var $b2f93a5f72bbb56b$require$PassThrough = $dAk3n$stream.PassThrough;
$b2f93a5f72bbb56b$exports = function() {
    var sources = [];
    var output = new $b2f93a5f72bbb56b$require$PassThrough({
        objectMode: true
    });
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    function add(source) {
        if (Array.isArray(source)) {
            source.forEach(add);
            return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, {
            end: false
        });
        return this;
    }
    function isEmpty() {
        return sources.length == 0;
    }
    function remove(source) {
        sources = sources.filter(function(it) {
            return it !== source;
        });
        if (!sources.length && output.readable) output.end();
    }
};


const $6a3766c1e90a911a$var$validateInputOptions = (input)=>{
    if (input !== undefined) throw new TypeError("The `input` and `inputFile` options cannot be both set.");
};
const $6a3766c1e90a911a$var$getInputSync = ({ input: input, inputFile: inputFile })=>{
    if (typeof inputFile !== "string") return input;
    $6a3766c1e90a911a$var$validateInputOptions(input);
    return (0, $dAk3n$nodefs.readFileSync)(inputFile);
};
const $6a3766c1e90a911a$export$7f2f9b6457412b41 = (options)=>{
    const input = $6a3766c1e90a911a$var$getInputSync(options);
    if ((0, $66cfbb89b6a89833$export$294a92d8f7b3979)(input)) throw new TypeError("The `input` option cannot be a stream in sync mode");
    return input;
};
const $6a3766c1e90a911a$var$getInput = ({ input: input, inputFile: inputFile })=>{
    if (typeof inputFile !== "string") return input;
    $6a3766c1e90a911a$var$validateInputOptions(input);
    return (0, $dAk3n$nodefs.createReadStream)(inputFile);
};
const $6a3766c1e90a911a$export$412508d679148d5c = (spawned, options)=>{
    const input = $6a3766c1e90a911a$var$getInput(options);
    if (input === undefined) return;
    if ((0, $66cfbb89b6a89833$export$294a92d8f7b3979)(input)) input.pipe(spawned.stdin);
    else spawned.stdin.end(input);
};
const $6a3766c1e90a911a$export$41f5c0c12dadd6ae = (spawned, { all: all })=>{
    if (!all || !spawned.stdout && !spawned.stderr) return;
    const mixed = (0, (/*@__PURE__*/$parcel$interopDefault($b2f93a5f72bbb56b$exports)))();
    if (spawned.stdout) mixed.add(spawned.stdout);
    if (spawned.stderr) mixed.add(spawned.stderr);
    return mixed;
};
// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const $6a3766c1e90a911a$var$getBufferedData = async (stream, streamPromise)=>{
    // When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve
    if (!stream || streamPromise === undefined) return;
    // Wait for the `all` stream to receive the last chunk before destroying the stream
    await (0, $dAk3n$nodetimerspromises.setTimeout)(0);
    stream.destroy();
    try {
        return await streamPromise;
    } catch (error) {
        return error.bufferedData;
    }
};
const $6a3766c1e90a911a$var$getStreamPromise = (stream, { encoding: encoding, buffer: buffer, maxBuffer: maxBuffer })=>{
    if (!stream || !buffer) return;
    // eslint-disable-next-line unicorn/text-encoding-identifier-case
    if (encoding === "utf8" || encoding === "utf-8") return (0, $61bd305dd67296e1$export$555b886bc6905a7c)(stream, {
        maxBuffer: maxBuffer
    });
    if (encoding === null || encoding === "buffer") return (0, $71a07105f89a05cf$export$7043a390e4973a6)(stream, {
        maxBuffer: maxBuffer
    });
    return $6a3766c1e90a911a$var$applyEncoding(stream, maxBuffer, encoding);
};
const $6a3766c1e90a911a$var$applyEncoding = async (stream, maxBuffer, encoding)=>{
    const buffer = await (0, $71a07105f89a05cf$export$7043a390e4973a6)(stream, {
        maxBuffer: maxBuffer
    });
    return buffer.toString(encoding);
};
const $6a3766c1e90a911a$export$67b768ac9e1c70fa = async ({ stdout: stdout, stderr: stderr, all: all }, { encoding: encoding, buffer: buffer, maxBuffer: maxBuffer }, processDone)=>{
    const stdoutPromise = $6a3766c1e90a911a$var$getStreamPromise(stdout, {
        encoding: encoding,
        buffer: buffer,
        maxBuffer: maxBuffer
    });
    const stderrPromise = $6a3766c1e90a911a$var$getStreamPromise(stderr, {
        encoding: encoding,
        buffer: buffer,
        maxBuffer: maxBuffer
    });
    const allPromise = $6a3766c1e90a911a$var$getStreamPromise(all, {
        encoding: encoding,
        buffer: buffer,
        maxBuffer: maxBuffer * 2
    });
    try {
        return await Promise.all([
            processDone,
            stdoutPromise,
            stderrPromise,
            allPromise
        ]);
    } catch (error) {
        return Promise.all([
            {
                error: error,
                signal: error.signal,
                timedOut: error.timedOut
            },
            $6a3766c1e90a911a$var$getBufferedData(stdout, stdoutPromise),
            $6a3766c1e90a911a$var$getBufferedData(stderr, stderrPromise),
            $6a3766c1e90a911a$var$getBufferedData(all, allPromise)
        ]);
    }
};


// eslint-disable-next-line unicorn/prefer-top-level-await
const $072f1f84c2620a36$var$nativePromisePrototype = (async ()=>{})().constructor.prototype;
const $072f1f84c2620a36$var$descriptors = [
    "then",
    "catch",
    "finally"
].map((property)=>[
        property,
        Reflect.getOwnPropertyDescriptor($072f1f84c2620a36$var$nativePromisePrototype, property)
    ]);
const $072f1f84c2620a36$export$e6eb0007fd542aba = (spawned, promise)=>{
    for (const [property, descriptor] of $072f1f84c2620a36$var$descriptors){
        // Starting the main `promise` is deferred to avoid consuming streams
        const value = typeof promise === "function" ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, {
            ...descriptor,
            value: value
        });
    }
};
const $072f1f84c2620a36$export$6e3a9b5342d42997 = (spawned)=>new Promise((resolve, reject)=>{
        spawned.on("exit", (exitCode, signal)=>{
            resolve({
                exitCode: exitCode,
                signal: signal
            });
        });
        spawned.on("error", (error)=>{
            reject(error);
        });
        if (spawned.stdin) spawned.stdin.on("error", (error)=>{
            reject(error);
        });
    });




const $80156d4e1f8fe918$var$normalizeArgs = (file, args = [])=>{
    if (!Array.isArray(args)) return [
        file
    ];
    return [
        file,
        ...args
    ];
};
const $80156d4e1f8fe918$var$NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const $80156d4e1f8fe918$var$escapeArg = (arg)=>{
    if (typeof arg !== "string" || $80156d4e1f8fe918$var$NO_ESCAPE_REGEXP.test(arg)) return arg;
    return `"${arg.replaceAll('"', '\\"')}"`;
};
const $80156d4e1f8fe918$export$ab3db8fe5ebf3a1 = (file, args)=>$80156d4e1f8fe918$var$normalizeArgs(file, args).join(" ");
const $80156d4e1f8fe918$export$9d3099014bd914f8 = (file, args)=>$80156d4e1f8fe918$var$normalizeArgs(file, args).map((arg)=>$80156d4e1f8fe918$var$escapeArg(arg)).join(" ");
const $80156d4e1f8fe918$var$SPACES_REGEXP = / +/g;
const $80156d4e1f8fe918$export$78bcee23e0849f6a = (command)=>{
    const tokens = [];
    for (const token of command.trim().split($80156d4e1f8fe918$var$SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens.at(-1);
        if (previousToken && previousToken.endsWith("\\")) // Merge previous token with current one
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        else tokens.push(token);
    }
    return tokens;
};
const $80156d4e1f8fe918$var$parseExpression = (expression)=>{
    const typeOfExpression = typeof expression;
    if (typeOfExpression === "string") return expression;
    if (typeOfExpression === "number") return String(expression);
    if (typeOfExpression === "object" && expression !== null && !(expression instanceof (0, $dAk3n$nodechild_process.ChildProcess)) && "stdout" in expression) {
        const typeOfStdout = typeof expression.stdout;
        if (typeOfStdout === "string") return expression.stdout;
        if ((0, $dAk3n$nodebuffer.Buffer).isBuffer(expression.stdout)) return expression.stdout.toString();
        throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
    }
    throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
const $80156d4e1f8fe918$var$concatTokens = (tokens, nextTokens, isNew)=>isNew || tokens.length === 0 || nextTokens.length === 0 ? [
        ...tokens,
        ...nextTokens
    ] : [
        ...tokens.slice(0, -1),
        `${tokens.at(-1)}${nextTokens[0]}`,
        ...nextTokens.slice(1)
    ];
const $80156d4e1f8fe918$var$parseTemplate = ({ templates: templates, expressions: expressions, tokens: tokens, index: index, template: template })=>{
    const templateString = template ?? templates.raw[index];
    const templateTokens = templateString.split($80156d4e1f8fe918$var$SPACES_REGEXP).filter(Boolean);
    const newTokens = $80156d4e1f8fe918$var$concatTokens(tokens, templateTokens, templateString.startsWith(" "));
    if (index === expressions.length) return newTokens;
    const expression = expressions[index];
    const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>$80156d4e1f8fe918$var$parseExpression(expression)) : [
        $80156d4e1f8fe918$var$parseExpression(expression)
    ];
    return $80156d4e1f8fe918$var$concatTokens(newTokens, expressionTokens, templateString.endsWith(" "));
};
const $80156d4e1f8fe918$export$4a6ee54de9b0f25d = (templates, expressions)=>{
    let tokens = [];
    for (const [index, template] of templates.entries())tokens = $80156d4e1f8fe918$var$parseTemplate({
        templates: templates,
        expressions: expressions,
        tokens: tokens,
        index: index,
        template: template
    });
    return tokens;
};




const $9d8c1f98f3296b14$export$38bb3c1fbaa0bdcf = (0, $dAk3n$nodeutil.debuglog)("execa").enabled;
const $9d8c1f98f3296b14$var$padField = (field, padding)=>String(field).padStart(padding, "0");
const $9d8c1f98f3296b14$var$getTimestamp = ()=>{
    const date = new Date();
    return `${$9d8c1f98f3296b14$var$padField(date.getHours(), 2)}:${$9d8c1f98f3296b14$var$padField(date.getMinutes(), 2)}:${$9d8c1f98f3296b14$var$padField(date.getSeconds(), 2)}.${$9d8c1f98f3296b14$var$padField(date.getMilliseconds(), 3)}`;
};
const $9d8c1f98f3296b14$export$3bb886c4c1352118 = (escapedCommand, { verbose: verbose })=>{
    if (!verbose) return;
    (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stderr.write(`[${$9d8c1f98f3296b14$var$getTimestamp()}] ${escapedCommand}\n`);
};


const $dd3803b97d87fa97$var$DEFAULT_MAX_BUFFER = 100000000;
const $dd3803b97d87fa97$var$getEnv = ({ env: envOption, extendEnv: extendEnv, preferLocal: preferLocal, localDir: localDir, execPath: execPath })=>{
    const env = extendEnv ? {
        ...(0, ($parcel$interopDefault($dAk3n$nodeprocess))).env,
        ...envOption
    } : envOption;
    if (preferLocal) return (0, $66683530f9da98f2$export$340e1fbaac04248b)({
        env: env,
        cwd: localDir,
        execPath: execPath
    });
    return env;
};
const $dd3803b97d87fa97$var$handleArguments = (file, args, options = {})=>{
    const parsed = (0, (/*@__PURE__*/$parcel$interopDefault($ec8669dea71015f9$exports)))._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
        maxBuffer: $dd3803b97d87fa97$var$DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).cwd(),
        execPath: (0, ($parcel$interopDefault($dAk3n$nodeprocess))).execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        verbose: (0, $9d8c1f98f3296b14$export$38bb3c1fbaa0bdcf),
        ...options
    };
    options.env = $dd3803b97d87fa97$var$getEnv(options);
    options.stdio = (0, $fb3d481f861f1605$export$a581401a57fac02e)(options);
    if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).platform === "win32" && (0, ($parcel$interopDefault($dAk3n$nodepath))).basename(file, ".exe") === "cmd") // #116
    args.unshift("/q");
    return {
        file: file,
        args: args,
        options: options,
        parsed: parsed
    };
};
const $dd3803b97d87fa97$var$handleOutput = (options, value, error)=>{
    if (typeof value !== "string" && !(0, $dAk3n$nodebuffer.Buffer).isBuffer(value)) // When `execaSync()` errors, we normalize it to '' to mimic `execa()`
    return error === undefined ? undefined : "";
    if (options.stripFinalNewline) return (0, $7aaedcc1d0c00e6c$export$2e2bcd8739ae039)(value);
    return value;
};
function $dd3803b97d87fa97$export$db6b1668e3758717(file, args, options) {
    const parsed = $dd3803b97d87fa97$var$handleArguments(file, args, options);
    const command = (0, $80156d4e1f8fe918$export$ab3db8fe5ebf3a1)(file, args);
    const escapedCommand = (0, $80156d4e1f8fe918$export$9d3099014bd914f8)(file, args);
    (0, $9d8c1f98f3296b14$export$3bb886c4c1352118)(escapedCommand, parsed.options);
    (0, $ba81a69748409cf4$export$3186f8866f616f9f)(parsed.options);
    let spawned;
    try {
        spawned = (0, ($parcel$interopDefault($dAk3n$nodechild_process))).spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
        // Ensure the returned error is always both a promise and a child process
        const dummySpawned = new (0, ($parcel$interopDefault($dAk3n$nodechild_process))).ChildProcess();
        const errorPromise = Promise.reject((0, $245bea6daf0c3a31$export$5a4bb2b1c89bdce7)({
            error: error,
            stdout: "",
            stderr: "",
            all: "",
            command: command,
            escapedCommand: escapedCommand,
            parsed: parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        }));
        (0, $072f1f84c2620a36$export$e6eb0007fd542aba)(dummySpawned, errorPromise);
        return dummySpawned;
    }
    const spawnedPromise = (0, $072f1f84c2620a36$export$6e3a9b5342d42997)(spawned);
    const timedPromise = (0, $ba81a69748409cf4$export$6bcc98999eb82896)(spawned, parsed.options, spawnedPromise);
    const processDone = (0, $ba81a69748409cf4$export$79fc3056c9ca4ada)(spawned, parsed.options, timedPromise);
    const context = {
        isCanceled: false
    };
    spawned.kill = (0, $ba81a69748409cf4$export$971fa1b57c7f00b).bind(null, spawned.kill.bind(spawned));
    spawned.cancel = (0, $ba81a69748409cf4$export$667e13cd9b70ca17).bind(null, spawned, context);
    const handlePromise = async ()=>{
        const [{ error: error, exitCode: exitCode, signal: signal, timedOut: timedOut }, stdoutResult, stderrResult, allResult] = await (0, $6a3766c1e90a911a$export$67b768ac9e1c70fa)(spawned, parsed.options, processDone);
        const stdout = $dd3803b97d87fa97$var$handleOutput(parsed.options, stdoutResult);
        const stderr = $dd3803b97d87fa97$var$handleOutput(parsed.options, stderrResult);
        const all = $dd3803b97d87fa97$var$handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
            const returnedError = (0, $245bea6daf0c3a31$export$5a4bb2b1c89bdce7)({
                error: error,
                exitCode: exitCode,
                signal: signal,
                stdout: stdout,
                stderr: stderr,
                all: all,
                command: command,
                escapedCommand: escapedCommand,
                parsed: parsed,
                timedOut: timedOut,
                isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
                killed: spawned.killed
            });
            if (!parsed.options.reject) return returnedError;
            throw returnedError;
        }
        return {
            command: command,
            escapedCommand: escapedCommand,
            exitCode: 0,
            stdout: stdout,
            stderr: stderr,
            all: all,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    };
    const handlePromiseOnce = (0, $c1aa4a45ee0cdc40$export$2e2bcd8739ae039)(handlePromise);
    (0, $6a3766c1e90a911a$export$412508d679148d5c)(spawned, parsed.options);
    spawned.all = (0, $6a3766c1e90a911a$export$41f5c0c12dadd6ae)(spawned, parsed.options);
    (0, $5bb4232d9b386f5a$export$14becf8d91886424)(spawned);
    (0, $072f1f84c2620a36$export$e6eb0007fd542aba)(spawned, handlePromiseOnce);
    return spawned;
}
function $dd3803b97d87fa97$export$28823a701bb5a12d(file, args, options) {
    const parsed = $dd3803b97d87fa97$var$handleArguments(file, args, options);
    const command = (0, $80156d4e1f8fe918$export$ab3db8fe5ebf3a1)(file, args);
    const escapedCommand = (0, $80156d4e1f8fe918$export$9d3099014bd914f8)(file, args);
    (0, $9d8c1f98f3296b14$export$3bb886c4c1352118)(escapedCommand, parsed.options);
    const input = (0, $6a3766c1e90a911a$export$7f2f9b6457412b41)(parsed.options);
    let result;
    try {
        result = (0, ($parcel$interopDefault($dAk3n$nodechild_process))).spawnSync(parsed.file, parsed.args, {
            ...parsed.options,
            input: input
        });
    } catch (error) {
        throw (0, $245bea6daf0c3a31$export$5a4bb2b1c89bdce7)({
            error: error,
            stdout: "",
            stderr: "",
            all: "",
            command: command,
            escapedCommand: escapedCommand,
            parsed: parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
        });
    }
    const stdout = $dd3803b97d87fa97$var$handleOutput(parsed.options, result.stdout, result.error);
    const stderr = $dd3803b97d87fa97$var$handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
        const error = (0, $245bea6daf0c3a31$export$5a4bb2b1c89bdce7)({
            stdout: stdout,
            stderr: stderr,
            error: result.error,
            signal: result.signal,
            exitCode: result.status,
            command: command,
            escapedCommand: escapedCommand,
            parsed: parsed,
            timedOut: result.error && result.error.code === "ETIMEDOUT",
            isCanceled: false,
            killed: result.signal !== null
        });
        if (!parsed.options.reject) return error;
        throw error;
    }
    return {
        command: command,
        escapedCommand: escapedCommand,
        exitCode: 0,
        stdout: stdout,
        stderr: stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
    };
}
const $dd3803b97d87fa97$var$normalizeScriptStdin = ({ input: input, inputFile: inputFile, stdio: stdio })=>input === undefined && inputFile === undefined && stdio === undefined ? {
        stdin: "inherit"
    } : {};
const $dd3803b97d87fa97$var$normalizeScriptOptions = (options = {})=>({
        preferLocal: true,
        ...$dd3803b97d87fa97$var$normalizeScriptStdin(options),
        ...options
    });
function $dd3803b97d87fa97$var$create$(options) {
    function $(templatesOrOptions, ...expressions) {
        if (!Array.isArray(templatesOrOptions)) return $dd3803b97d87fa97$var$create$({
            ...options,
            ...templatesOrOptions
        });
        const [file, ...args] = (0, $80156d4e1f8fe918$export$4a6ee54de9b0f25d)(templatesOrOptions, expressions);
        return $dd3803b97d87fa97$export$db6b1668e3758717(file, args, $dd3803b97d87fa97$var$normalizeScriptOptions(options));
    }
    $.sync = (templates, ...expressions)=>{
        if (!Array.isArray(templates)) throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
        const [file, ...args] = (0, $80156d4e1f8fe918$export$4a6ee54de9b0f25d)(templates, expressions);
        return $dd3803b97d87fa97$export$28823a701bb5a12d(file, args, $dd3803b97d87fa97$var$normalizeScriptOptions(options));
    };
    return $;
}
const $dd3803b97d87fa97$export$3d8c2f653ac9d0b9 = $dd3803b97d87fa97$var$create$();
function $dd3803b97d87fa97$export$eb9ed1222071f2f6(command, options) {
    const [file, ...args] = (0, $80156d4e1f8fe918$export$78bcee23e0849f6a)(command);
    return $dd3803b97d87fa97$export$db6b1668e3758717(file, args, options);
}
function $dd3803b97d87fa97$export$5c60dbe76a54db4(command, options) {
    const [file, ...args] = (0, $80156d4e1f8fe918$export$78bcee23e0849f6a)(command);
    return $dd3803b97d87fa97$export$28823a701bb5a12d(file, args, options);
}
function $dd3803b97d87fa97$export$c004ac68fdb98119(scriptPath, args, options = {}) {
    if (args && !Array.isArray(args) && typeof args === "object") {
        options = args;
        args = [];
    }
    const stdio = (0, $fb3d481f861f1605$export$889423b478ae2ba)(options);
    const defaultExecArgv = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).execArgv.filter((arg)=>!arg.startsWith("--inspect"));
    const { nodePath: nodePath = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).execPath, nodeOptions: nodeOptions = defaultExecArgv } = options;
    return $dd3803b97d87fa97$export$db6b1668e3758717(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
    ], {
        ...options,
        stdin: undefined,
        stdout: undefined,
        stderr: undefined,
        stdio: stdio,
        shell: false
    });
}




const $23048e7f833b5d93$var$typedArrayTypeNames = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
];
function $23048e7f833b5d93$var$isTypedArrayName(name) {
    return $23048e7f833b5d93$var$typedArrayTypeNames.includes(name);
}
const $23048e7f833b5d93$var$objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "WeakRef",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    "NaN",
    ...$23048e7f833b5d93$var$typedArrayTypeNames
];
function $23048e7f833b5d93$var$isObjectTypeName(name) {
    return $23048e7f833b5d93$var$objectTypeNames.includes(name);
}
const $23048e7f833b5d93$var$primitiveTypeNames = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
];
function $23048e7f833b5d93$var$isPrimitiveTypeName(name) {
    return $23048e7f833b5d93$var$primitiveTypeNames.includes(name);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function $23048e7f833b5d93$var$isOfType(type) {
    return (value)=>typeof value === type;
}
const { toString: $23048e7f833b5d93$var$toString } = Object.prototype;
const $23048e7f833b5d93$var$getObjectType = (value)=>{
    const objectTypeName = $23048e7f833b5d93$var$toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && $23048e7f833b5d93$var$is.domElement(value)) return "HTMLElement";
    if ($23048e7f833b5d93$var$isObjectTypeName(objectTypeName)) return objectTypeName;
    return undefined;
};
const $23048e7f833b5d93$var$isObjectOfType = (type)=>(value)=>$23048e7f833b5d93$var$getObjectType(value) === type;
function $23048e7f833b5d93$var$is(value) {
    if (value === null) return "null";
    switch(typeof value){
        case "undefined":
            return "undefined";
        case "string":
            return "string";
        case "number":
            return Number.isNaN(value) ? "NaN" : "number";
        case "boolean":
            return "boolean";
        case "function":
            return "Function";
        case "bigint":
            return "bigint";
        case "symbol":
            return "symbol";
        default:
    }
    if ($23048e7f833b5d93$var$is.observable(value)) return "Observable";
    if ($23048e7f833b5d93$var$is.array(value)) return "Array";
    if ($23048e7f833b5d93$var$is.buffer(value)) return "Buffer";
    const tagType = $23048e7f833b5d93$var$getObjectType(value);
    if (tagType) return tagType;
    if (value instanceof String || value instanceof Boolean || value instanceof Number) throw new TypeError("Please don't use object wrappers for primitive types");
    return "Object";
}
$23048e7f833b5d93$var$is.undefined = $23048e7f833b5d93$var$isOfType("undefined");
$23048e7f833b5d93$var$is.string = $23048e7f833b5d93$var$isOfType("string");
const $23048e7f833b5d93$var$isNumberType = $23048e7f833b5d93$var$isOfType("number");
$23048e7f833b5d93$var$is.number = (value)=>$23048e7f833b5d93$var$isNumberType(value) && !$23048e7f833b5d93$var$is.nan(value);
$23048e7f833b5d93$var$is.positiveNumber = (value)=>$23048e7f833b5d93$var$is.number(value) && value > 0;
$23048e7f833b5d93$var$is.negativeNumber = (value)=>$23048e7f833b5d93$var$is.number(value) && value < 0;
$23048e7f833b5d93$var$is.bigint = $23048e7f833b5d93$var$isOfType("bigint");
// eslint-disable-next-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.function_ = $23048e7f833b5d93$var$isOfType("function");
// eslint-disable-next-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.null_ = (value)=>value === null;
$23048e7f833b5d93$var$is.class_ = (value)=>$23048e7f833b5d93$var$is.function_(value) && value.toString().startsWith("class ");
$23048e7f833b5d93$var$is.boolean = (value)=>value === true || value === false;
$23048e7f833b5d93$var$is.symbol = $23048e7f833b5d93$var$isOfType("symbol");
$23048e7f833b5d93$var$is.numericString = (value)=>$23048e7f833b5d93$var$is.string(value) && !$23048e7f833b5d93$var$is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
$23048e7f833b5d93$var$is.array = (value, assertion)=>{
    if (!Array.isArray(value)) return false;
    if (!$23048e7f833b5d93$var$is.function_(assertion)) return true;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    return value.every((element)=>assertion(element));
};
// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call
$23048e7f833b5d93$var$is.buffer = (value)=>value?.constructor?.isBuffer?.(value) ?? false;
$23048e7f833b5d93$var$is.blob = (value)=>$23048e7f833b5d93$var$isObjectOfType("Blob")(value);
$23048e7f833b5d93$var$is.nullOrUndefined = (value)=>$23048e7f833b5d93$var$is.null_(value) || $23048e7f833b5d93$var$is.undefined(value); // eslint-disable-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.object = (value)=>!$23048e7f833b5d93$var$is.null_(value) && (typeof value === "object" || $23048e7f833b5d93$var$is.function_(value)); // eslint-disable-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.iterable = (value)=>$23048e7f833b5d93$var$is.function_(value?.[Symbol.iterator]);
$23048e7f833b5d93$var$is.asyncIterable = (value)=>$23048e7f833b5d93$var$is.function_(value?.[Symbol.asyncIterator]);
$23048e7f833b5d93$var$is.generator = (value)=>$23048e7f833b5d93$var$is.iterable(value) && $23048e7f833b5d93$var$is.function_(value?.next) && $23048e7f833b5d93$var$is.function_(value?.throw);
$23048e7f833b5d93$var$is.asyncGenerator = (value)=>$23048e7f833b5d93$var$is.asyncIterable(value) && $23048e7f833b5d93$var$is.function_(value.next) && $23048e7f833b5d93$var$is.function_(value.throw);
$23048e7f833b5d93$var$is.nativePromise = (value)=>$23048e7f833b5d93$var$isObjectOfType("Promise")(value);
const $23048e7f833b5d93$var$hasPromiseApi = (value)=>$23048e7f833b5d93$var$is.function_(value?.then) && $23048e7f833b5d93$var$is.function_(value?.catch);
$23048e7f833b5d93$var$is.promise = (value)=>$23048e7f833b5d93$var$is.nativePromise(value) || $23048e7f833b5d93$var$hasPromiseApi(value);
$23048e7f833b5d93$var$is.generatorFunction = $23048e7f833b5d93$var$isObjectOfType("GeneratorFunction");
$23048e7f833b5d93$var$is.asyncGeneratorFunction = (value)=>$23048e7f833b5d93$var$getObjectType(value) === "AsyncGeneratorFunction";
$23048e7f833b5d93$var$is.asyncFunction = (value)=>$23048e7f833b5d93$var$getObjectType(value) === "AsyncFunction";
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.boundFunction = (value)=>$23048e7f833b5d93$var$is.function_(value) && !value.hasOwnProperty("prototype");
$23048e7f833b5d93$var$is.regExp = $23048e7f833b5d93$var$isObjectOfType("RegExp");
$23048e7f833b5d93$var$is.date = $23048e7f833b5d93$var$isObjectOfType("Date");
$23048e7f833b5d93$var$is.error = $23048e7f833b5d93$var$isObjectOfType("Error");
$23048e7f833b5d93$var$is.map = (value)=>$23048e7f833b5d93$var$isObjectOfType("Map")(value);
$23048e7f833b5d93$var$is.set = (value)=>$23048e7f833b5d93$var$isObjectOfType("Set")(value);
$23048e7f833b5d93$var$is.weakMap = (value)=>$23048e7f833b5d93$var$isObjectOfType("WeakMap")(value); // eslint-disable-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.weakSet = (value)=>$23048e7f833b5d93$var$isObjectOfType("WeakSet")(value); // eslint-disable-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.weakRef = (value)=>$23048e7f833b5d93$var$isObjectOfType("WeakRef")(value); // eslint-disable-line @typescript-eslint/ban-types
$23048e7f833b5d93$var$is.int8Array = $23048e7f833b5d93$var$isObjectOfType("Int8Array");
$23048e7f833b5d93$var$is.uint8Array = $23048e7f833b5d93$var$isObjectOfType("Uint8Array");
$23048e7f833b5d93$var$is.uint8ClampedArray = $23048e7f833b5d93$var$isObjectOfType("Uint8ClampedArray");
$23048e7f833b5d93$var$is.int16Array = $23048e7f833b5d93$var$isObjectOfType("Int16Array");
$23048e7f833b5d93$var$is.uint16Array = $23048e7f833b5d93$var$isObjectOfType("Uint16Array");
$23048e7f833b5d93$var$is.int32Array = $23048e7f833b5d93$var$isObjectOfType("Int32Array");
$23048e7f833b5d93$var$is.uint32Array = $23048e7f833b5d93$var$isObjectOfType("Uint32Array");
$23048e7f833b5d93$var$is.float32Array = $23048e7f833b5d93$var$isObjectOfType("Float32Array");
$23048e7f833b5d93$var$is.float64Array = $23048e7f833b5d93$var$isObjectOfType("Float64Array");
$23048e7f833b5d93$var$is.bigInt64Array = $23048e7f833b5d93$var$isObjectOfType("BigInt64Array");
$23048e7f833b5d93$var$is.bigUint64Array = $23048e7f833b5d93$var$isObjectOfType("BigUint64Array");
$23048e7f833b5d93$var$is.arrayBuffer = $23048e7f833b5d93$var$isObjectOfType("ArrayBuffer");
$23048e7f833b5d93$var$is.sharedArrayBuffer = $23048e7f833b5d93$var$isObjectOfType("SharedArrayBuffer");
$23048e7f833b5d93$var$is.dataView = $23048e7f833b5d93$var$isObjectOfType("DataView");
// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
$23048e7f833b5d93$var$is.enumCase = (value, targetEnum)=>Object.values(targetEnum).includes(value);
$23048e7f833b5d93$var$is.directInstanceOf = (instance, class_)=>Object.getPrototypeOf(instance) === class_.prototype;
$23048e7f833b5d93$var$is.urlInstance = (value)=>$23048e7f833b5d93$var$isObjectOfType("URL")(value);
$23048e7f833b5d93$var$is.urlString = (value)=>{
    if (!$23048e7f833b5d93$var$is.string(value)) return false;
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    } catch  {
        return false;
    }
};
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
$23048e7f833b5d93$var$is.truthy = (value)=>Boolean(value); // eslint-disable-line unicorn/prefer-native-coercion-functions
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
$23048e7f833b5d93$var$is.falsy = (value)=>!value;
$23048e7f833b5d93$var$is.nan = (value)=>Number.isNaN(value);
$23048e7f833b5d93$var$is.primitive = (value)=>$23048e7f833b5d93$var$is.null_(value) || $23048e7f833b5d93$var$isPrimitiveTypeName(typeof value);
$23048e7f833b5d93$var$is.integer = (value)=>Number.isInteger(value);
$23048e7f833b5d93$var$is.safeInteger = (value)=>Number.isSafeInteger(value);
$23048e7f833b5d93$var$is.plainObject = (value)=>{
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (typeof value !== "object" || value === null) return false;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
$23048e7f833b5d93$var$is.typedArray = (value)=>$23048e7f833b5d93$var$isTypedArrayName($23048e7f833b5d93$var$getObjectType(value));
const $23048e7f833b5d93$var$isValidLength = (value)=>$23048e7f833b5d93$var$is.safeInteger(value) && value >= 0;
$23048e7f833b5d93$var$is.arrayLike = (value)=>!$23048e7f833b5d93$var$is.nullOrUndefined(value) && !$23048e7f833b5d93$var$is.function_(value) && $23048e7f833b5d93$var$isValidLength(value.length);
$23048e7f833b5d93$var$is.tupleLike = (value, guards)=>{
    if ($23048e7f833b5d93$var$is.array(guards) && $23048e7f833b5d93$var$is.array(value) && guards.length === value.length) return guards.every((guard, index)=>guard(value[index]));
    return false;
};
$23048e7f833b5d93$var$is.inRange = (value, range)=>{
    if ($23048e7f833b5d93$var$is.number(range)) return value >= Math.min(0, range) && value <= Math.max(range, 0);
    if ($23048e7f833b5d93$var$is.array(range) && range.length === 2) return value >= Math.min(...range) && value <= Math.max(...range);
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
// eslint-disable-next-line @typescript-eslint/naming-convention
const $23048e7f833b5d93$var$NODE_TYPE_ELEMENT = 1;
// eslint-disable-next-line @typescript-eslint/naming-convention
const $23048e7f833b5d93$var$DOM_PROPERTIES_TO_CHECK = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
];
$23048e7f833b5d93$var$is.domElement = (value)=>$23048e7f833b5d93$var$is.object(value) && value.nodeType === $23048e7f833b5d93$var$NODE_TYPE_ELEMENT && $23048e7f833b5d93$var$is.string(value.nodeName) && !$23048e7f833b5d93$var$is.plainObject(value) && $23048e7f833b5d93$var$DOM_PROPERTIES_TO_CHECK.every((property)=>property in value);
$23048e7f833b5d93$var$is.observable = (value)=>{
    if (!value) return false;
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native, @typescript-eslint/no-unsafe-call
    if (value === value[Symbol.observable]?.()) return true;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    if (value === value["@@observable"]?.()) return true;
    return false;
};
$23048e7f833b5d93$var$is.nodeStream = (value)=>$23048e7f833b5d93$var$is.object(value) && $23048e7f833b5d93$var$is.function_(value.pipe) && !$23048e7f833b5d93$var$is.observable(value);
$23048e7f833b5d93$var$is.infinite = (value)=>value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
const $23048e7f833b5d93$var$isAbsoluteMod2 = (remainder)=>(value)=>$23048e7f833b5d93$var$is.integer(value) && Math.abs(value % 2) === remainder;
$23048e7f833b5d93$var$is.evenInteger = $23048e7f833b5d93$var$isAbsoluteMod2(0);
$23048e7f833b5d93$var$is.oddInteger = $23048e7f833b5d93$var$isAbsoluteMod2(1);
$23048e7f833b5d93$var$is.emptyArray = (value)=>$23048e7f833b5d93$var$is.array(value) && value.length === 0;
$23048e7f833b5d93$var$is.nonEmptyArray = (value)=>$23048e7f833b5d93$var$is.array(value) && value.length > 0;
$23048e7f833b5d93$var$is.emptyString = (value)=>$23048e7f833b5d93$var$is.string(value) && value.length === 0;
const $23048e7f833b5d93$var$isWhiteSpaceString = (value)=>$23048e7f833b5d93$var$is.string(value) && !/\S/.test(value);
$23048e7f833b5d93$var$is.emptyStringOrWhitespace = (value)=>$23048e7f833b5d93$var$is.emptyString(value) || $23048e7f833b5d93$var$isWhiteSpaceString(value);
// TODO: Use `not ''` when the `not` operator is available.
$23048e7f833b5d93$var$is.nonEmptyString = (value)=>$23048e7f833b5d93$var$is.string(value) && value.length > 0;
// TODO: Use `not ''` when the `not` operator is available.
$23048e7f833b5d93$var$is.nonEmptyStringAndNotWhitespace = (value)=>$23048e7f833b5d93$var$is.string(value) && !$23048e7f833b5d93$var$is.emptyStringOrWhitespace(value);
// eslint-disable-next-line unicorn/no-array-callback-reference
$23048e7f833b5d93$var$is.emptyObject = (value)=>$23048e7f833b5d93$var$is.object(value) && !$23048e7f833b5d93$var$is.map(value) && !$23048e7f833b5d93$var$is.set(value) && Object.keys(value).length === 0;
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
// eslint-disable-next-line unicorn/no-array-callback-reference
$23048e7f833b5d93$var$is.nonEmptyObject = (value)=>$23048e7f833b5d93$var$is.object(value) && !$23048e7f833b5d93$var$is.map(value) && !$23048e7f833b5d93$var$is.set(value) && Object.keys(value).length > 0;
$23048e7f833b5d93$var$is.emptySet = (value)=>$23048e7f833b5d93$var$is.set(value) && value.size === 0;
$23048e7f833b5d93$var$is.nonEmptySet = (value)=>$23048e7f833b5d93$var$is.set(value) && value.size > 0;
// eslint-disable-next-line unicorn/no-array-callback-reference
$23048e7f833b5d93$var$is.emptyMap = (value)=>$23048e7f833b5d93$var$is.map(value) && value.size === 0;
// eslint-disable-next-line unicorn/no-array-callback-reference
$23048e7f833b5d93$var$is.nonEmptyMap = (value)=>$23048e7f833b5d93$var$is.map(value) && value.size > 0;
// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
$23048e7f833b5d93$var$is.propertyKey = (value)=>$23048e7f833b5d93$var$is.any([
        $23048e7f833b5d93$var$is.string,
        $23048e7f833b5d93$var$is.number,
        $23048e7f833b5d93$var$is.symbol
    ], value);
$23048e7f833b5d93$var$is.formData = (value)=>$23048e7f833b5d93$var$isObjectOfType("FormData")(value);
$23048e7f833b5d93$var$is.urlSearchParams = (value)=>$23048e7f833b5d93$var$isObjectOfType("URLSearchParams")(value);
const $23048e7f833b5d93$var$predicateOnArray = (method, predicate, values)=>{
    if (!$23048e7f833b5d93$var$is.function_(predicate)) throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    if (values.length === 0) throw new TypeError("Invalid number of values");
    return method.call(values, predicate);
};
$23048e7f833b5d93$var$is.any = (predicate, ...values)=>{
    const predicates = $23048e7f833b5d93$var$is.array(predicate) ? predicate : [
        predicate
    ];
    return predicates.some((singlePredicate)=>$23048e7f833b5d93$var$predicateOnArray(Array.prototype.some, singlePredicate, values));
};
$23048e7f833b5d93$var$is.all = (predicate, ...values)=>$23048e7f833b5d93$var$predicateOnArray(Array.prototype.every, predicate, values);
const $23048e7f833b5d93$var$assertType = (condition, description, value, options = {})=>{
    if (!condition) {
        const { multipleValues: multipleValues } = options;
        const valuesMessage = multipleValues ? `received values of types ${[
            ...new Set(value.map((singleValue)=>`\`${$23048e7f833b5d93$var$is(singleValue)}\``))
        ].join(", ")}` : `received value of type \`${$23048e7f833b5d93$var$is(value)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
};
const $23048e7f833b5d93$export$a7a9523472993e97 = {
    // Unknowns.
    undefined: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.undefined(value), "undefined", value),
    string: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.string(value), "string", value),
    number: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.number(value), "number", value),
    positiveNumber: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.positiveNumber(value), "positive number" /* AssertionTypeDescription.positiveNumber */ , value),
    negativeNumber: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.negativeNumber(value), "negative number" /* AssertionTypeDescription.negativeNumber */ , value),
    bigint: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.bigint(value), "bigint", value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.function_(value), "Function", value),
    null_: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.null_(value), "null", value),
    class_: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.class_(value), "Class" /* AssertionTypeDescription.class_ */ , value),
    boolean: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.boolean(value), "boolean", value),
    symbol: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.symbol(value), "symbol", value),
    numericString: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.numericString(value), "string with a number" /* AssertionTypeDescription.numericString */ , value),
    array: (value, assertion)=>{
        const assert = $23048e7f833b5d93$var$assertType;
        assert($23048e7f833b5d93$var$is.array(value), "Array", value);
        if (assertion) // eslint-disable-next-line unicorn/no-array-for-each, unicorn/no-array-callback-reference
        value.forEach(assertion);
    },
    buffer: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.buffer(value), "Buffer", value),
    blob: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.blob(value), "Blob", value),
    nullOrUndefined: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nullOrUndefined(value), "null or undefined" /* AssertionTypeDescription.nullOrUndefined */ , value),
    object: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.object(value), "Object", value),
    iterable: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.iterable(value), "Iterable" /* AssertionTypeDescription.iterable */ , value),
    asyncIterable: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.asyncIterable(value), "AsyncIterable" /* AssertionTypeDescription.asyncIterable */ , value),
    generator: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.generator(value), "Generator", value),
    asyncGenerator: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.asyncGenerator(value), "AsyncGenerator", value),
    nativePromise: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nativePromise(value), "native Promise" /* AssertionTypeDescription.nativePromise */ , value),
    promise: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.promise(value), "Promise", value),
    generatorFunction: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.generatorFunction(value), "GeneratorFunction", value),
    asyncGeneratorFunction: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.asyncFunction(value), "AsyncFunction", value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.boundFunction(value), "Function", value),
    regExp: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.regExp(value), "RegExp", value),
    date: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.date(value), "Date", value),
    error: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.error(value), "Error", value),
    map: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.map(value), "Map", value),
    set: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.set(value), "Set", value),
    weakMap: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.weakMap(value), "WeakMap", value),
    weakSet: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.weakSet(value), "WeakSet", value),
    weakRef: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.weakRef(value), "WeakRef", value),
    int8Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.int8Array(value), "Int8Array", value),
    uint8Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.uint8Array(value), "Uint8Array", value),
    uint8ClampedArray: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.uint8ClampedArray(value), "Uint8ClampedArray", value),
    int16Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.int16Array(value), "Int16Array", value),
    uint16Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.uint16Array(value), "Uint16Array", value),
    int32Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.int32Array(value), "Int32Array", value),
    uint32Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.uint32Array(value), "Uint32Array", value),
    float32Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.float32Array(value), "Float32Array", value),
    float64Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.float64Array(value), "Float64Array", value),
    bigInt64Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.bigInt64Array(value), "BigInt64Array", value),
    bigUint64Array: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.bigUint64Array(value), "BigUint64Array", value),
    arrayBuffer: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.arrayBuffer(value), "ArrayBuffer", value),
    sharedArrayBuffer: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
    dataView: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.dataView(value), "DataView", value),
    enumCase: (value, targetEnum)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.enumCase(value, targetEnum), "EnumCase", value),
    urlInstance: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.urlInstance(value), "URL", value),
    urlString: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.urlString(value), "string with a URL" /* AssertionTypeDescription.urlString */ , value),
    truthy: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.truthy(value), "truthy" /* AssertionTypeDescription.truthy */ , value),
    falsy: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.falsy(value), "falsy" /* AssertionTypeDescription.falsy */ , value),
    nan: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nan(value), "NaN" /* AssertionTypeDescription.nan */ , value),
    primitive: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.primitive(value), "primitive" /* AssertionTypeDescription.primitive */ , value),
    integer: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.integer(value), "integer" /* AssertionTypeDescription.integer */ , value),
    safeInteger: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.safeInteger(value), "integer" /* AssertionTypeDescription.safeInteger */ , value),
    plainObject: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.plainObject(value), "plain object" /* AssertionTypeDescription.plainObject */ , value),
    typedArray: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.typedArray(value), "TypedArray" /* AssertionTypeDescription.typedArray */ , value),
    arrayLike: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.arrayLike(value), "array-like" /* AssertionTypeDescription.arrayLike */ , value),
    tupleLike: (value, guards)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.tupleLike(value, guards), "tuple-like" /* AssertionTypeDescription.tupleLike */ , value),
    domElement: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.domElement(value), "HTMLElement" /* AssertionTypeDescription.domElement */ , value),
    observable: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.observable(value), "Observable", value),
    nodeStream: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nodeStream(value), "Node.js Stream" /* AssertionTypeDescription.nodeStream */ , value),
    infinite: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.infinite(value), "infinite number" /* AssertionTypeDescription.infinite */ , value),
    emptyArray: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.emptyArray(value), "empty array" /* AssertionTypeDescription.emptyArray */ , value),
    nonEmptyArray: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nonEmptyArray(value), "non-empty array" /* AssertionTypeDescription.nonEmptyArray */ , value),
    emptyString: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.emptyString(value), "empty string" /* AssertionTypeDescription.emptyString */ , value),
    emptyStringOrWhitespace: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.emptyStringOrWhitespace(value), "empty string or whitespace" /* AssertionTypeDescription.emptyStringOrWhitespace */ , value),
    nonEmptyString: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nonEmptyString(value), "non-empty string" /* AssertionTypeDescription.nonEmptyString */ , value),
    nonEmptyStringAndNotWhitespace: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace" /* AssertionTypeDescription.nonEmptyStringAndNotWhitespace */ , value),
    emptyObject: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.emptyObject(value), "empty object" /* AssertionTypeDescription.emptyObject */ , value),
    nonEmptyObject: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nonEmptyObject(value), "non-empty object" /* AssertionTypeDescription.nonEmptyObject */ , value),
    emptySet: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.emptySet(value), "empty set" /* AssertionTypeDescription.emptySet */ , value),
    nonEmptySet: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nonEmptySet(value), "non-empty set" /* AssertionTypeDescription.nonEmptySet */ , value),
    emptyMap: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.emptyMap(value), "empty map" /* AssertionTypeDescription.emptyMap */ , value),
    nonEmptyMap: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.nonEmptyMap(value), "non-empty map" /* AssertionTypeDescription.nonEmptyMap */ , value),
    propertyKey: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.propertyKey(value), "PropertyKey", value),
    formData: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.formData(value), "FormData", value),
    urlSearchParams: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.urlSearchParams(value), "URLSearchParams", value),
    // Numbers.
    evenInteger: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.evenInteger(value), "even integer" /* AssertionTypeDescription.evenInteger */ , value),
    oddInteger: (value)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.oddInteger(value), "odd integer" /* AssertionTypeDescription.oddInteger */ , value),
    // Two arguments.
    directInstanceOf: (instance, class_)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.directInstanceOf(instance, class_), "T" /* AssertionTypeDescription.directInstanceOf */ , instance),
    inRange: (value, range)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.inRange(value, range), "in range" /* AssertionTypeDescription.inRange */ , value),
    // Variadic functions.
    any: (predicate, ...values)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.any(predicate, ...values), "predicate returns truthy for any value" /* AssertionTypeDescription.any */ , values, {
            multipleValues: true
        }),
    all: (predicate, ...values)=>$23048e7f833b5d93$var$assertType($23048e7f833b5d93$var$is.all(predicate, ...values), "predicate returns truthy for all values" /* AssertionTypeDescription.all */ , values, {
            multipleValues: true
        })
};
/* eslint-enable @typescript-eslint/no-confusing-void-expression */ // Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties($23048e7f833b5d93$var$is, {
    class: {
        value: $23048e7f833b5d93$var$is.class_
    },
    function: {
        value: $23048e7f833b5d93$var$is.function_
    },
    null: {
        value: $23048e7f833b5d93$var$is.null_
    }
});
Object.defineProperties($23048e7f833b5d93$export$a7a9523472993e97, {
    class: {
        value: $23048e7f833b5d93$export$a7a9523472993e97.class_
    },
    function: {
        value: $23048e7f833b5d93$export$a7a9523472993e97.function_
    },
    null: {
        value: $23048e7f833b5d93$export$a7a9523472993e97.null_
    }
});
var $23048e7f833b5d93$export$2e2bcd8739ae039 = $23048e7f833b5d93$var$is;




class $9f256715eaead164$export$d7f5e52d091a66db extends Error {
    constructor(reason){
        super(reason || "Promise was canceled");
        this.name = "CancelError";
    }
    get isCanceled() {
        return true;
    }
}
class $9f256715eaead164$export$2e2bcd8739ae039 {
    static fn(userFunction) {
        return (...arguments_)=>{
            return new $9f256715eaead164$export$2e2bcd8739ae039((resolve, reject, onCancel)=>{
                arguments_.push(onCancel);
                // eslint-disable-next-line promise/prefer-await-to-then
                userFunction(...arguments_).then(resolve, reject);
            });
        };
    }
    constructor(executor){
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve, reject)=>{
            this._reject = reject;
            const onResolve = (value)=>{
                if (!this._isCanceled || !onCancel.shouldReject) {
                    this._isPending = false;
                    resolve(value);
                }
            };
            const onReject = (error)=>{
                this._isPending = false;
                reject(error);
            };
            const onCancel = (handler)=>{
                if (!this._isPending) throw new Error("The `onCancel` handler was attached after the promise settled.");
                this._cancelHandlers.push(handler);
            };
            Object.defineProperties(onCancel, {
                shouldReject: {
                    get: ()=>this._rejectOnCancel,
                    set: (boolean)=>{
                        this._rejectOnCancel = boolean;
                    }
                }
            });
            executor(onResolve, onReject, onCancel);
        });
    }
    then(onFulfilled, onRejected) {
        // eslint-disable-next-line promise/prefer-await-to-then
        return this._promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        // eslint-disable-next-line promise/prefer-await-to-then
        return this._promise.catch(onRejected);
    }
    finally(onFinally) {
        // eslint-disable-next-line promise/prefer-await-to-then
        return this._promise.finally(onFinally);
    }
    cancel(reason) {
        if (!this._isPending || this._isCanceled) return;
        this._isCanceled = true;
        if (this._cancelHandlers.length > 0) try {
            for (const handler of this._cancelHandlers)handler();
        } catch (error) {
            this._reject(error);
            return;
        }
        if (this._rejectOnCancel) this._reject(new $9f256715eaead164$export$d7f5e52d091a66db(reason));
    }
    get isCanceled() {
        return this._isCanceled;
    }
}
Object.setPrototypeOf($9f256715eaead164$export$2e2bcd8739ae039.prototype, Promise.prototype);



// A hacky check to prevent circular references.
function $a5bde8c0d43bf4db$var$isRequest(x) {
    return (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(x) && "_onResponse" in x;
}
class $a5bde8c0d43bf4db$export$43ee7d0e4f429743 extends Error {
    constructor(message, error, self){
        super(message);
        Object.defineProperty(this, "input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.code = error.code ?? "ERR_GOT_REQUEST_ERROR";
        this.input = error.input;
        if ($a5bde8c0d43bf4db$var$isRequest(self)) {
            Object.defineProperty(this, "request", {
                enumerable: false,
                value: self
            });
            Object.defineProperty(this, "response", {
                enumerable: false,
                value: self.response
            });
            this.options = self.options;
        } else this.options = self;
        this.timings = this.request?.timings;
        // Recover the original stacktrace
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(error.stack) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(this.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
            // Remove duplicated traces
            while(errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0])thisStackTrace.shift();
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
        }
    }
}
class $a5bde8c0d43bf4db$export$a34d7acee3cbcf76 extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(request){
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = "MaxRedirectsError";
        this.code = "ERR_TOO_MANY_REDIRECTS";
    }
}
class $a5bde8c0d43bf4db$export$aa9d629c530f62a7 extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(response){
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = "HTTPError";
        this.code = "ERR_NON_2XX_3XX_RESPONSE";
    }
}
class $a5bde8c0d43bf4db$export$78ff06e91c3de382 extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(error, request){
        super(error.message, error, request);
        this.name = "CacheError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
    }
}
class $a5bde8c0d43bf4db$export$137ec66182ed30ea extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(error, request){
        super(error.message, error, request);
        this.name = "UploadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
    }
}
class $a5bde8c0d43bf4db$export$66d311bf29d5c89c extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(error, timings, request){
        super(error.message, error, request);
        Object.defineProperty(this, "timings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = "TimeoutError";
        this.event = error.event;
        this.timings = timings;
    }
}
class $a5bde8c0d43bf4db$export$e5f2fbba71434b55 extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(error, request){
        super(error.message, error, request);
        this.name = "ReadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
    }
}
class $a5bde8c0d43bf4db$export$aa6cf8a4f695f0ee extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(request){
        super("Retrying", {}, request);
        this.name = "RetryError";
        this.code = "ERR_RETRYING";
    }
}
class $a5bde8c0d43bf4db$export$18b052ffd8c84d7 extends $a5bde8c0d43bf4db$export$43ee7d0e4f429743 {
    constructor(request){
        super("This operation was aborted.", {}, request);
        this.code = "ERR_ABORTED";
        this.name = "AbortError";
    }
}









var $67a49c88bb8cb165$exports = {};
"use strict";
Object.defineProperty($67a49c88bb8cb165$exports, "__esModule", {
    value: true
});
function $67a49c88bb8cb165$var$isTLSSocket(socket) {
    return socket.encrypted;
}
const $67a49c88bb8cb165$var$deferToConnect = (socket, fn)=>{
    let listeners;
    if (typeof fn === "function") {
        const connect = fn;
        listeners = {
            connect: connect
        };
    } else listeners = fn;
    const hasConnectListener = typeof listeners.connect === "function";
    const hasSecureConnectListener = typeof listeners.secureConnect === "function";
    const hasCloseListener = typeof listeners.close === "function";
    const onConnect = ()=>{
        if (hasConnectListener) listeners.connect();
        if ($67a49c88bb8cb165$var$isTLSSocket(socket) && hasSecureConnectListener) {
            if (socket.authorized) listeners.secureConnect();
            else if (!socket.authorizationError) socket.once("secureConnect", listeners.secureConnect);
        }
        if (hasCloseListener) socket.once("close", listeners.close);
    };
    if (socket.writable && !socket.connecting) onConnect();
    else if (socket.connecting) socket.once("connect", onConnect);
    else if (socket.destroyed && hasCloseListener) listeners.close(socket._hadError);
};
$67a49c88bb8cb165$exports.default = $67a49c88bb8cb165$var$deferToConnect;
// For CommonJS default export support
$67a49c88bb8cb165$exports = $67a49c88bb8cb165$var$deferToConnect;
$67a49c88bb8cb165$exports.default = $67a49c88bb8cb165$var$deferToConnect;


const $263dfae12a4c70a4$var$timer = (request)=>{
    if (request.timings) return request.timings;
    const timings = {
        start: Date.now(),
        socket: undefined,
        lookup: undefined,
        connect: undefined,
        secureConnect: undefined,
        upload: undefined,
        response: undefined,
        end: undefined,
        error: undefined,
        abort: undefined,
        phases: {
            wait: undefined,
            dns: undefined,
            tcp: undefined,
            tls: undefined,
            request: undefined,
            firstByte: undefined,
            download: undefined,
            total: undefined
        }
    };
    request.timings = timings;
    const handleError = (origin)=>{
        origin.once((0, $dAk3n$events.errorMonitor), ()=>{
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
        });
    };
    handleError(request);
    const onAbort = ()=>{
        timings.abort = Date.now();
        timings.phases.total = timings.abort - timings.start;
    };
    request.prependOnceListener("abort", onAbort);
    const onSocket = (socket)=>{
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if ((0, $dAk3n$util.types).isProxy(socket)) return;
        const lookupListener = ()=>{
            timings.lookup = Date.now();
            timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener("lookup", lookupListener);
        (0, (/*@__PURE__*/$parcel$interopDefault($67a49c88bb8cb165$exports)))(socket, {
            connect: ()=>{
                timings.connect = Date.now();
                if (timings.lookup === undefined) {
                    socket.removeListener("lookup", lookupListener);
                    timings.lookup = timings.connect;
                    timings.phases.dns = timings.lookup - timings.socket;
                }
                timings.phases.tcp = timings.connect - timings.lookup;
            },
            secureConnect: ()=>{
                timings.secureConnect = Date.now();
                timings.phases.tls = timings.secureConnect - timings.connect;
            }
        });
    };
    if (request.socket) onSocket(request.socket);
    else request.prependOnceListener("socket", onSocket);
    const onUpload = ()=>{
        timings.upload = Date.now();
        timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
    };
    if (request.writableFinished) onUpload();
    else request.prependOnceListener("finish", onUpload);
    request.prependOnceListener("response", (response)=>{
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener("end", ()=>{
            request.off("abort", onAbort);
            response.off("aborted", onAbort);
            if (timings.phases.total) // Aborted or errored
            return;
            timings.end = Date.now();
            timings.phases.download = timings.end - timings.response;
            timings.phases.total = timings.end - timings.start;
        });
        response.prependOnceListener("aborted", onAbort);
    });
    return timings;
};
var $263dfae12a4c70a4$export$2e2bcd8739ae039 = $263dfae12a4c70a4$var$timer;






// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const $68ed5fede653613a$var$DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
const $68ed5fede653613a$var$DATA_URL_DEFAULT_CHARSET = "us-ascii";
const $68ed5fede653613a$var$testParameter = (name, filters)=>filters.some((filter)=>filter instanceof RegExp ? filter.test(name) : filter === name);
const $68ed5fede653613a$var$supportedProtocols = new Set([
    "https:",
    "http:",
    "file:"
]);
const $68ed5fede653613a$var$hasCustomProtocol = (urlString)=>{
    try {
        const { protocol: protocol } = new URL(urlString);
        return protocol.endsWith(":") && !$68ed5fede653613a$var$supportedProtocols.has(protocol);
    } catch  {
        return false;
    }
};
const $68ed5fede653613a$var$normalizeDataURL = (urlString, { stripHash: stripHash })=>{
    const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
    if (!match) throw new Error(`Invalid URL: ${urlString}`);
    let { type: type, data: data, hash: hash } = match.groups;
    const mediaType = type.split(";");
    hash = stripHash ? "" : hash;
    let isBase64 = false;
    if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        isBase64 = true;
    }
    // Lowercase MIME type
    const mimeType = mediaType.shift()?.toLowerCase() ?? "";
    const attributes = mediaType.map((attribute)=>{
        let [key, value = ""] = attribute.split("=").map((string)=>string.trim());
        // Lowercase `charset`
        if (key === "charset") {
            value = value.toLowerCase();
            if (value === $68ed5fede653613a$var$DATA_URL_DEFAULT_CHARSET) return "";
        }
        return `${key}${value ? `=${value}` : ""}`;
    }).filter(Boolean);
    const normalizedMediaType = [
        ...attributes
    ];
    if (isBase64) normalizedMediaType.push("base64");
    if (normalizedMediaType.length > 0 || mimeType && mimeType !== $68ed5fede653613a$var$DATA_URL_DEFAULT_MIME_TYPE) normalizedMediaType.unshift(mimeType);
    return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function $68ed5fede653613a$export$2e2bcd8739ae039(urlString, options) {
    options = {
        defaultProtocol: "http",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripTextFragment: true,
        stripWWW: true,
        removeQueryParameters: [
            /^utm_\w+/i
        ],
        removeTrailingSlash: true,
        removeSingleSlash: true,
        removeDirectoryIndex: false,
        removeExplicitPort: false,
        sortQueryParameters: true,
        ...options
    };
    // Legacy: Append `:` to the protocol if missing.
    if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) options.defaultProtocol = `${options.defaultProtocol}:`;
    urlString = urlString.trim();
    // Data URL
    if (/^data:/i.test(urlString)) return $68ed5fede653613a$var$normalizeDataURL(urlString, options);
    if ($68ed5fede653613a$var$hasCustomProtocol(urlString)) return urlString;
    const hasRelativeProtocol = urlString.startsWith("//");
    const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
    // Prepend protocol
    if (!isRelativeUrl) urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
    const urlObject = new URL(urlString);
    if (options.forceHttp && options.forceHttps) throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    if (options.forceHttp && urlObject.protocol === "https:") urlObject.protocol = "http:";
    if (options.forceHttps && urlObject.protocol === "http:") urlObject.protocol = "https:";
    // Remove auth
    if (options.stripAuthentication) {
        urlObject.username = "";
        urlObject.password = "";
    }
    // Remove hash
    if (options.stripHash) urlObject.hash = "";
    else if (options.stripTextFragment) urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
    // Remove duplicate slashes if not preceded by a protocol
    // NOTE: This could be implemented using a single negative lookbehind
    // regex, but we avoid that to maintain compatibility with older js engines
    // which do not have support for that feature.
    if (urlObject.pathname) {
        // TODO: Replace everything below with `urlObject.pathname = urlObject.pathname.replace(/(?<!\b[a-z][a-z\d+\-.]{1,50}:)\/{2,}/g, '/');` when Safari supports negative lookbehind.
        // Split the string by occurrences of this protocol regex, and perform
        // duplicate-slash replacement on the strings between those occurrences
        // (if any).
        const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
        let lastIndex = 0;
        let result = "";
        for(;;){
            const match = protocolRegex.exec(urlObject.pathname);
            if (!match) break;
            const protocol = match[0];
            const protocolAtIndex = match.index;
            const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
            result += intermediate.replace(/\/{2,}/g, "/");
            result += protocol;
            lastIndex = protocolAtIndex + protocol.length;
        }
        const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
        result += remnant.replace(/\/{2,}/g, "/");
        urlObject.pathname = result;
    }
    // Decode URI octets
    if (urlObject.pathname) try {
        urlObject.pathname = decodeURI(urlObject.pathname);
    } catch  {}
    // Remove directory index
    if (options.removeDirectoryIndex === true) options.removeDirectoryIndex = [
        /^index\.[a-z]+$/
    ];
    if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObject.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if ($68ed5fede653613a$var$testParameter(lastComponent, options.removeDirectoryIndex)) {
            pathComponents = pathComponents.slice(0, -1);
            urlObject.pathname = pathComponents.slice(1).join("/") + "/";
        }
    }
    if (urlObject.hostname) {
        // Remove trailing dot
        urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
        // Remove `www.`
        if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) // Each label should be max 63 at length (min: 1).
        // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
        // Each TLD should be up to 63 characters long (min: 2).
        // It is technically possible to have a single character TLD, but none currently exist.
        urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
    // Remove query unwanted parameters
    if (Array.isArray(options.removeQueryParameters)) {
        // eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.
        for (const key of [
            ...urlObject.searchParams.keys()
        ])if ($68ed5fede653613a$var$testParameter(key, options.removeQueryParameters)) urlObject.searchParams.delete(key);
    }
    if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) urlObject.search = "";
    // Keep wanted query parameters
    if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
        // eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.
        for (const key of [
            ...urlObject.searchParams.keys()
        ])if (!$68ed5fede653613a$var$testParameter(key, options.keepQueryParameters)) urlObject.searchParams.delete(key);
    }
    // Sort query parameters
    if (options.sortQueryParameters) {
        urlObject.searchParams.sort();
        // Calling `.sort()` encodes the search parameters, so we need to decode them again.
        try {
            urlObject.search = decodeURIComponent(urlObject.search);
        } catch  {}
    }
    if (options.removeTrailingSlash) urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
    // Remove an explicit port number, excluding a default port number, if applicable
    if (options.removeExplicitPort && urlObject.port) urlObject.port = "";
    const oldUrlString = urlString;
    // Take advantage of many of the Node `url` normalizations
    urlString = urlObject.toString();
    if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") urlString = urlString.replace(/\/$/, "");
    // Remove ending `/` unless removeSingleSlash is false
    if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) urlString = urlString.replace(/\/$/, "");
    // Restore relative protocol, if applicable
    if (hasRelativeProtocol && !options.normalizeProtocol) urlString = urlString.replace(/^http:\/\//, "//");
    // Remove http/https
    if (options.stripProtocol) urlString = urlString.replace(/^(?:https?:)?\/\//, "");
    return urlString;
}


var $d62fd2c5965796dc$exports = {};
"use strict";

var $d62fd2c5965796dc$require$BufferConstants = $dAk3n$buffer.constants;


var $d62fd2c5965796dc$require$promisify = $dAk3n$util.promisify;
var $d73487e1d0d1e61a$exports = {};
"use strict";

var $d73487e1d0d1e61a$require$PassThroughStream = $dAk3n$stream.PassThrough;
$d73487e1d0d1e61a$exports = (options)=>{
    options = {
        ...options
    };
    const { array: array } = options;
    let { encoding: encoding } = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) objectMode = !(encoding || isBuffer);
    else encoding = encoding || "utf8";
    if (isBuffer) encoding = null;
    const stream = new $d73487e1d0d1e61a$require$PassThroughStream({
        objectMode: objectMode
    });
    if (encoding) stream.setEncoding(encoding);
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk)=>{
        chunks.push(chunk);
        if (objectMode) length = chunks.length;
        else length += chunk.length;
    });
    stream.getBufferedValue = ()=>{
        if (array) return chunks;
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = ()=>length;
    return stream;
};


const $d62fd2c5965796dc$var$streamPipelinePromisified = $d62fd2c5965796dc$require$promisify($dAk3n$stream.pipeline);
class $d62fd2c5965796dc$var$MaxBufferError extends Error {
    constructor(){
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
    }
}
async function $d62fd2c5965796dc$var$getStream(inputStream, options) {
    if (!inputStream) throw new Error("Expected a stream");
    options = {
        maxBuffer: Infinity,
        ...options
    };
    const { maxBuffer: maxBuffer } = options;
    const stream = $d73487e1d0d1e61a$exports(options);
    await new Promise((resolve, reject)=>{
        const rejectPromise = (error)=>{
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= $d62fd2c5965796dc$require$BufferConstants.MAX_LENGTH) error.bufferedData = stream.getBufferedValue();
            reject(error);
        };
        (async ()=>{
            try {
                await $d62fd2c5965796dc$var$streamPipelinePromisified(inputStream, stream);
                resolve();
            } catch (error) {
                rejectPromise(error);
            }
        })();
        stream.on("data", ()=>{
            if (stream.getBufferedLength() > maxBuffer) rejectPromise(new $d62fd2c5965796dc$var$MaxBufferError());
        });
    });
    return stream.getBufferedValue();
}
$d62fd2c5965796dc$exports = $d62fd2c5965796dc$var$getStream;
$d62fd2c5965796dc$exports.buffer = (stream, options)=>$d62fd2c5965796dc$var$getStream(stream, {
        ...options,
        encoding: "buffer"
    });
$d62fd2c5965796dc$exports.array = (stream, options)=>$d62fd2c5965796dc$var$getStream(stream, {
        ...options,
        array: true
    });
$d62fd2c5965796dc$exports.MaxBufferError = $d62fd2c5965796dc$var$MaxBufferError;


var $e3bd37dd0801a28c$exports = {};
"use strict";
// rfc7231 6.1
const $e3bd37dd0801a28c$var$statusCodeCacheableByDefault = new Set([
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501
]);
// This implementation does not understand partial responses (206)
const $e3bd37dd0801a28c$var$understoodStatuses = new Set([
    200,
    203,
    204,
    300,
    301,
    302,
    303,
    307,
    308,
    404,
    405,
    410,
    414,
    501
]);
const $e3bd37dd0801a28c$var$errorStatusCodes = new Set([
    500,
    502,
    503,
    504
]);
const $e3bd37dd0801a28c$var$hopByHopHeaders = {
    date: true,
    connection: true,
    "keep-alive": true,
    "proxy-authenticate": true,
    "proxy-authorization": true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true
};
const $e3bd37dd0801a28c$var$excludedFromRevalidationUpdate = {
    // Since the old body is reused, it doesn't make sense to change properties of the body
    "content-length": true,
    "content-encoding": true,
    "transfer-encoding": true,
    "content-range": true
};
function $e3bd37dd0801a28c$var$toNumberOrZero(s) {
    const n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
}
// RFC 5861
function $e3bd37dd0801a28c$var$isErrorResponse(response) {
    // consider undefined response as faulty
    if (!response) return true;
    return $e3bd37dd0801a28c$var$errorStatusCodes.has(response.status);
}
function $e3bd37dd0801a28c$var$parseCacheControl(header) {
    const cc = {};
    if (!header) return cc;
    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
    const parts = header.trim().split(/,/);
    for (const part of parts){
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^"|"$/g, "");
    }
    return cc;
}
function $e3bd37dd0801a28c$var$formatCacheControl(cc) {
    let parts = [];
    for(const k in cc){
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
    }
    if (!parts.length) return undefined;
    return parts.join(", ");
}
$e3bd37dd0801a28c$exports = class CachePolicy {
    constructor(req, res, { shared: shared, cacheHeuristic: cacheHeuristic, immutableMinTimeToLive: immutableMinTimeToLive, ignoreCargoCult: ignoreCargoCult, _fromObject: _fromObject } = {}){
        if (_fromObject) {
            this._fromObject(_fromObject);
            return;
        }
        if (!res || !res.headers) throw Error("Response headers missing");
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
        this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 86400000;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = $e3bd37dd0801a28c$var$parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
        this._reqcc = $e3bd37dd0801a28c$var$parseCacheControl(req.headers["cache-control"]);
        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
        // so there's no point stricly adhering to the blindly copy&pasted directives.
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
            delete this._rescc["pre-check"];
            delete this._rescc["post-check"];
            delete this._rescc["no-cache"];
            delete this._rescc["no-store"];
            delete this._rescc["must-revalidate"];
            this._resHeaders = Object.assign({}, this._resHeaders, {
                "cache-control": $e3bd37dd0801a28c$var$formatCacheControl(this._rescc)
            });
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
        }
        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
        // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) this._rescc["no-cache"] = true;
    }
    now() {
        return Date.now();
    }
    storable() {
        // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        $e3bd37dd0801a28c$var$understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        $e3bd37dd0801a28c$var$statusCodeCacheableByDefault.has(this._status)));
    }
    _hasExplicitExpiration() {
        // 4.2.1 Calculating Freshness Lifetime
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
    }
    _assertRequestHasHeaders(req) {
        if (!req || !req.headers) throw Error("Request headers missing");
    }
    satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        // When presented with a request, a cache MUST NOT reuse a stored response, unless:
        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
        // unless the stored response is successfully validated (Section 4.3), and
        const requestCC = $e3bd37dd0801a28c$var$parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) return false;
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) return false;
        if (requestCC["min-fresh"] && this.timeToLive() < 1000 * requestCC["min-fresh"]) return false;
        // the stored response is either:
        // fresh, or allowed to be served stale
        if (this.stale()) {
            const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
            if (!allowsStale) return false;
        }
        return this._requestMatches(req, false);
    }
    _requestMatches(req, allowHeadMethod) {
        // The presented effective request URI and that of the stored response match, and
        return (!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req);
    }
    _allowsStoringAuthenticated() {
        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
    }
    _varyMatches(req) {
        if (!this._resHeaders.vary) return true;
        // A Vary header field-value of "*" always fails to match
        if (this._resHeaders.vary === "*") return false;
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields){
            if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
    }
    _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for(const name in inHeaders){
            if ($e3bd37dd0801a28c$var$hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
        }
        // 9.1.  Connection
        if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for (const name of tokens)delete headers[name];
        }
        if (headers.warning) {
            const warnings = headers.warning.split(/,/).filter((warning)=>{
                return !/^\s*1[0-9][0-9]/.test(warning);
            });
            if (!warnings.length) delete headers.warning;
            else headers.warning = warnings.join(",").trim();
        }
        return headers;
    }
    responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        // A cache SHOULD generate 113 warning if it heuristically chose a freshness
        // lifetime greater than 24 hours and the response's age is greater than 24 hours.
        if (age > 86400 && !this._hasExplicitExpiration() && this.maxAge() > 86400) headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
    }
    /**
     * Value of the Date response header or current time if Date was invalid
     * @return timestamp
     */ date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) return serverDate;
        return this._responseTime;
    }
    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */ age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1000;
        return age + residentTime;
    }
    _ageValue() {
        return $e3bd37dd0801a28c$var$toNumberOrZero(this._resHeaders.age);
    }
    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */ maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) return 0;
        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
        // so this implementation requires explicit opt-in via public header
        if (this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable) return 0;
        if (this._resHeaders.vary === "*") return 0;
        if (this._isShared) {
            if (this._rescc["proxy-revalidate"]) return 0;
            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
            if (this._rescc["s-maxage"]) return $e3bd37dd0801a28c$var$toNumberOrZero(this._rescc["s-maxage"]);
        }
        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
        if (this._rescc["max-age"]) return $e3bd37dd0801a28c$var$toNumberOrZero(this._rescc["max-age"]);
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
            if (Number.isNaN(expires) || expires < serverDate) return 0;
            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
        }
        if (this._resHeaders["last-modified"]) {
            const lastModified = Date.parse(this._resHeaders["last-modified"]);
            if (isFinite(lastModified) && serverDate > lastModified) return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);
        }
        return defaultMinTtl;
    }
    timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + $e3bd37dd0801a28c$var$toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + $e3bd37dd0801a28c$var$toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;
    }
    stale() {
        return this.maxAge() <= this.age();
    }
    _useStaleIfError() {
        return this.maxAge() + $e3bd37dd0801a28c$var$toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
    }
    useStaleWhileRevalidate() {
        return this.maxAge() + $e3bd37dd0801a28c$var$toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
    }
    static fromObject(obj) {
        return new this(undefined, undefined, {
            _fromObject: obj
        });
    }
    _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 86400000;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
    }
    toObject() {
        return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc
        };
    }
    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */ revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        // This implementation does not understand range requests
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
            // revalidation allowed via HEAD
            // not for the same resource, or wasn't allowed to be cached anyway
            delete headers["if-none-match"];
            delete headers["if-modified-since"];
            return headers;
        }
        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */ if (this._resHeaders.etag) headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */ if (forbidsWeakValidators) {
            delete headers["if-modified-since"];
            if (headers["if-none-match"]) {
                const etags = headers["if-none-match"].split(/,/).filter((etag)=>{
                    return !/^\s*W\//.test(etag);
                });
                if (!etags.length) delete headers["if-none-match"];
                else headers["if-none-match"] = etags.join(",").trim();
            }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) headers["if-modified-since"] = this._resHeaders["last-modified"];
        return headers;
    }
    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */ revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (this._useStaleIfError() && $e3bd37dd0801a28c$var$isErrorResponse(response)) return {
            modified: false,
            matches: false,
            policy: this
        };
        if (!response || !response.headers) throw Error("Response headers missing");
        // These aren't going to be supported exactly, since one CachePolicy object
        // doesn't know about all the other cached objects.
        let matches = false;
        if (response.status !== undefined && response.status != 304) matches = false;
        else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) // "All of the stored responses with the same strong validator are selected.
        // If none of the stored responses contain the same strong validator,
        // then the cache MUST NOT use the new response to update any stored responses."
        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        else if (this._resHeaders.etag && response.headers.etag) // "If the new response contains a weak validator and that validator corresponds
        // to one of the cache's stored responses,
        // then the most recent of those matching stored responses is selected for update."
        matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        else if (this._resHeaders["last-modified"]) matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        else // If the new response does not include any form of validator (such as in the case where
        // a client generates an If-Modified-Since request from a source other than the Last-Modified
        // response header field), and there is only one stored response, and that stored response also
        // lacks a validator, then that stored response is selected for update.
        if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) matches = true;
        if (!matches) return {
            policy: new this.constructor(request, response),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response.status != 304,
            matches: false
        };
        // use other header fields provided in the 304 (Not Modified) response to replace all instances
        // of the corresponding header fields in the stored response.
        const headers = {};
        for(const k in this._resHeaders)headers[k] = k in response.headers && !$e3bd37dd0801a28c$var$excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers: headers
        });
        return {
            policy: new this.constructor(request, newResponse, {
                shared: this._isShared,
                cacheHeuristic: this._cacheHeuristic,
                immutableMinTimeToLive: this._immutableMinTtl
            }),
            modified: false,
            matches: true
        };
    }
};



function $cc1220db54f967ea$export$2e2bcd8739ae039(object) {
    return Object.fromEntries(Object.entries(object).map(([key, value])=>[
            key.toLowerCase(),
            value
        ]));
}


class $c49fc643257501f1$export$2e2bcd8739ae039 extends (0, $dAk3n$nodestream.Readable) {
    statusCode;
    headers;
    body;
    url;
    constructor({ statusCode: statusCode, headers: headers, body: body, url: url }){
        if (typeof statusCode !== "number") throw new TypeError("Argument `statusCode` should be a number");
        if (typeof headers !== "object") throw new TypeError("Argument `headers` should be an object");
        if (!(body instanceof Uint8Array)) throw new TypeError("Argument `body` should be a buffer");
        if (typeof url !== "string") throw new TypeError("Argument `url` should be a string");
        super({
            read () {
                this.push(body);
                this.push(null);
            }
        });
        this.statusCode = statusCode;
        this.headers = (0, $cc1220db54f967ea$export$2e2bcd8739ae039)(headers);
        this.body = body;
        this.url = url;
    }
}


var $f0837960445c532c$exports = {};
"use strict";

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.
var $86d05e13dd406d39$export$fac44ee5b035f737;
var $86d05e13dd406d39$export$98e6a39c04603d36;
$86d05e13dd406d39$export$fac44ee5b035f737 = function stringify(o) {
    if ("undefined" == typeof o) return o;
    if (o && Buffer.isBuffer(o)) return JSON.stringify(":base64:" + o.toString("base64"));
    if (o && o.toJSON) o = o.toJSON();
    if (o && "object" === typeof o) {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = true;
        for(var k in o){
            var ignore = "function" == typeof o[k] || !array && "undefined" === typeof o[k];
            if (Object.hasOwnProperty.call(o, k) && !ignore) {
                if (!first) s += ",";
                first = false;
                if (array) {
                    if (o[k] == undefined) s += "null";
                    else s += stringify(o[k]);
                } else if (o[k] !== void 0) s += stringify(k) + ":" + stringify(o[k]);
            }
        }
        s += array ? "]" : "}";
        return s;
    } else if ("string" === typeof o) return JSON.stringify(/^:/.test(o) ? ":" + o : o);
    else if ("undefined" === typeof o) return "null";
    else return JSON.stringify(o);
};
$86d05e13dd406d39$export$98e6a39c04603d36 = function(s) {
    return JSON.parse(s, function(key, value) {
        if ("string" === typeof value) {
            if (/^:base64:/.test(value)) return Buffer.from(value.substring(8), "base64");
            else return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
    });
};


const $f0837960445c532c$var$loadStore = (options)=>{
    const adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
    };
    if (options.adapter || options.uri) {
        const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (require(adapters[adapter]))(options);
    }
    return new Map();
};
const $f0837960445c532c$var$iterableAdapters = [
    "sqlite",
    "postgres",
    "mysql",
    "mongo",
    "redis",
    "tiered"
];
class $f0837960445c532c$var$Keyv extends $dAk3n$events {
    constructor(uri, { emitErrors: emitErrors = true, ...options } = {}){
        super();
        this.opts = {
            namespace: "keyv",
            serialize: $86d05e13dd406d39$export$fac44ee5b035f737,
            deserialize: $86d05e13dd406d39$export$98e6a39c04603d36,
            ...typeof uri === "string" ? {
                uri: uri
            } : uri,
            ...options
        };
        if (!this.opts.store) {
            const adapterOptions = {
                ...this.opts
            };
            this.opts.store = $f0837960445c532c$var$loadStore(adapterOptions);
        }
        if (this.opts.compression) {
            const compression = this.opts.compression;
            this.opts.serialize = compression.serialize.bind(compression);
            this.opts.deserialize = compression.deserialize.bind(compression);
        }
        if (typeof this.opts.store.on === "function" && emitErrors) this.opts.store.on("error", (error)=>this.emit("error", error));
        this.opts.store.namespace = this.opts.namespace;
        const generateIterator = (iterator)=>async function*() {
                for await (const [key, raw] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator){
                    const data = await this.opts.deserialize(raw);
                    if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) continue;
                    if (typeof data.expires === "number" && Date.now() > data.expires) {
                        this.delete(key);
                        continue;
                    }
                    yield [
                        this._getKeyUnprefix(key),
                        data.value
                    ];
                }
            };
        // Attach iterators
        if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) this.iterator = generateIterator(this.opts.store);
        else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
    }
    _checkIterableAdaptar() {
        return $f0837960445c532c$var$iterableAdapters.includes(this.opts.store.opts.dialect) || $f0837960445c532c$var$iterableAdapters.findIndex((element)=>this.opts.store.opts.url.includes(element)) >= 0;
    }
    _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
    }
    _getKeyPrefixArray(keys) {
        return keys.map((key)=>`${this.opts.namespace}:${key}`);
    }
    _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
    }
    get(key, options) {
        const { store: store } = this.opts;
        const isArray = Array.isArray(key);
        const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray && store.getMany === undefined) {
            const promises = [];
            for (const key of keyPrefixed)promises.push(Promise.resolve().then(()=>store.get(key)).then((data)=>typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data)=>{
                if (data === undefined || data === null) return undefined;
                if (typeof data.expires === "number" && Date.now() > data.expires) return this.delete(key).then(()=>undefined);
                return options && options.raw ? data : data.value;
            }));
            return Promise.allSettled(promises).then((values)=>{
                const data = [];
                for (const value of values)data.push(value.value);
                return data;
            });
        }
        return Promise.resolve().then(()=>isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data)=>typeof data === "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data)=>{
            if (data === undefined || data === null) return undefined;
            if (isArray) {
                const result = [];
                for (let row of data){
                    if (typeof row === "string") row = this.opts.deserialize(row);
                    if (row === undefined || row === null) {
                        result.push(undefined);
                        continue;
                    }
                    if (typeof row.expires === "number" && Date.now() > row.expires) {
                        this.delete(key).then(()=>undefined);
                        result.push(undefined);
                    } else result.push(options && options.raw ? row : row.value);
                }
                return result;
            }
            if (typeof data.expires === "number" && Date.now() > data.expires) return this.delete(key).then(()=>undefined);
            return options && options.raw ? data : data.value;
        });
    }
    set(key, value, ttl) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") ttl = this.opts.ttl;
        if (ttl === 0) ttl = undefined;
        const { store: store } = this.opts;
        return Promise.resolve().then(()=>{
            const expires = typeof ttl === "number" ? Date.now() + ttl : null;
            if (typeof value === "symbol") this.emit("error", "symbol cannot be serialized");
            value = {
                value: value,
                expires: expires
            };
            return this.opts.serialize(value);
        }).then((value)=>store.set(keyPrefixed, value, ttl)).then(()=>true);
    }
    delete(key) {
        const { store: store } = this.opts;
        if (Array.isArray(key)) {
            const keyPrefixed = this._getKeyPrefixArray(key);
            if (store.deleteMany === undefined) {
                const promises = [];
                for (const key of keyPrefixed)promises.push(store.delete(key));
                return Promise.allSettled(promises).then((values)=>values.every((x)=>x.value === true));
            }
            return Promise.resolve().then(()=>store.deleteMany(keyPrefixed));
        }
        const keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(()=>store.delete(keyPrefixed));
    }
    clear() {
        const { store: store } = this.opts;
        return Promise.resolve().then(()=>store.clear());
    }
    has(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store: store } = this.opts;
        return Promise.resolve().then(async ()=>{
            if (typeof store.has === "function") return store.has(keyPrefixed);
            const value = await store.get(keyPrefixed);
            return value !== undefined;
        });
    }
    disconnect() {
        const { store: store } = this.opts;
        if (typeof store.disconnect === "function") return store.disconnect();
    }
}
$f0837960445c532c$exports = $f0837960445c532c$var$Keyv;


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const $82581e8f56b38cb0$var$knownProperties = [
    "aborted",
    "complete",
    "headers",
    "httpVersion",
    "httpVersionMinor",
    "httpVersionMajor",
    "method",
    "rawHeaders",
    "rawTrailers",
    "setTimeout",
    "socket",
    "statusCode",
    "statusMessage",
    "trailers",
    "url"
];
function $82581e8f56b38cb0$export$2e2bcd8739ae039(fromStream, toStream) {
    if (toStream._readableState.autoDestroy) throw new Error("The second stream must have the `autoDestroy` option set to `false`");
    const fromProperties = new Set([
        ...Object.keys(fromStream),
        ...$82581e8f56b38cb0$var$knownProperties
    ]);
    const properties = {};
    for (const property of fromProperties){
        // Don't overwrite existing properties.
        if (property in toStream) continue;
        properties[property] = {
            get () {
                const value = fromStream[property];
                const isFunction = typeof value === "function";
                return isFunction ? value.bind(fromStream) : value;
            },
            set (value) {
                fromStream[property] = value;
            },
            enumerable: true,
            configurable: false
        };
    }
    Object.defineProperties(toStream, properties);
    fromStream.once("aborted", ()=>{
        toStream.destroy();
        toStream.emit("aborted");
    });
    fromStream.once("close", ()=>{
        if (fromStream.complete) {
            if (toStream.readable) toStream.once("end", ()=>{
                toStream.emit("close");
            });
            else toStream.emit("close");
        } else toStream.emit("close");
    });
    return toStream;
}


// Type definitions for cacheable-request 6.0
// Project: https://github.com/lukechilds/cacheable-request#readme
// Definitions by: BendingBender <https://github.com/BendingBender>
//                 Paul Melnikow <https://github.com/paulmelnikow>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3
class $0cd45e613d0af170$export$43ee7d0e4f429743 extends Error {
    constructor(error){
        super(error.message);
        Object.assign(this, error);
    }
}
class $0cd45e613d0af170$export$78ff06e91c3de382 extends Error {
    constructor(error){
        super(error.message);
        Object.assign(this, error);
    }
}


class $a6de8cfd72a6dad5$var$CacheableRequest {
    constructor(cacheRequest, cacheAdapter){
        this.hooks = new Map();
        this.request = ()=>(options, cb)=>{
                let url;
                if (typeof options === "string") {
                    url = $a6de8cfd72a6dad5$var$normalizeUrlObject((0, ($parcel$interopDefault($dAk3n$nodeurl))).parse(options));
                    options = {};
                } else if (options instanceof (0, ($parcel$interopDefault($dAk3n$nodeurl))).URL) {
                    url = $a6de8cfd72a6dad5$var$normalizeUrlObject((0, ($parcel$interopDefault($dAk3n$nodeurl))).parse(options.toString()));
                    options = {};
                } else {
                    const [pathname, ...searchParts] = (options.path ?? "").split("?");
                    const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
                    url = $a6de8cfd72a6dad5$var$normalizeUrlObject({
                        ...options,
                        pathname: pathname,
                        search: search
                    });
                }
                options = {
                    headers: {},
                    method: "GET",
                    cache: true,
                    strictTtl: false,
                    automaticFailover: false,
                    ...options,
                    ...$a6de8cfd72a6dad5$var$urlObjectToRequestOptions(url)
                };
                options.headers = Object.fromEntries($a6de8cfd72a6dad5$var$entries(options.headers).map(([key, value])=>[
                        key.toLowerCase(),
                        value
                    ]));
                const ee = new (0, ($parcel$interopDefault($dAk3n$nodeevents)))();
                const normalizedUrlString = (0, $68ed5fede653613a$export$2e2bcd8739ae039)((0, ($parcel$interopDefault($dAk3n$nodeurl))).format(url), {
                    stripWWW: false,
                    removeTrailingSlash: false,
                    stripAuthentication: false
                });
                let key = `${options.method}:${normalizedUrlString}`;
                // POST, PATCH, and PUT requests may be cached, depending on the response
                // cache-control headers. As a result, the body of the request should be
                // added to the cache key in order to avoid collisions.
                if (options.body && options.method !== undefined && [
                    "POST",
                    "PATCH",
                    "PUT"
                ].includes(options.method)) {
                    if (options.body instanceof (0, ($parcel$interopDefault($dAk3n$nodestream))).Readable) // Streamed bodies should completely skip the cache because they may
                    // or may not be hashable and in either case the stream would need to
                    // close before the cache key could be generated.
                    options.cache = false;
                    else key += `:${(0, ($parcel$interopDefault($dAk3n$nodecrypto))).createHash("md5").update(options.body).digest("hex")}`;
                }
                let revalidate = false;
                let madeRequest = false;
                const makeRequest = (options_)=>{
                    madeRequest = true;
                    let requestErrored = false;
                    let requestErrorCallback = ()=>{};
                    const requestErrorPromise = new Promise((resolve)=>{
                        requestErrorCallback = ()=>{
                            if (!requestErrored) {
                                requestErrored = true;
                                resolve();
                            }
                        };
                    });
                    const handler = async (response)=>{
                        if (revalidate) {
                            response.status = response.statusCode;
                            const revalidatedPolicy = (0, (/*@__PURE__*/$parcel$interopDefault($e3bd37dd0801a28c$exports))).fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
                            if (!revalidatedPolicy.modified) {
                                response.resume();
                                await new Promise((resolve)=>{
                                    // Skipping 'error' handler cause 'error' event should't be emitted for 304 response
                                    response.once("end", resolve);
                                });
                                const headers = $a6de8cfd72a6dad5$var$convertHeaders(revalidatedPolicy.policy.responseHeaders());
                                response = new (0, $c49fc643257501f1$export$2e2bcd8739ae039)({
                                    statusCode: revalidate.statusCode,
                                    headers: headers,
                                    body: revalidate.body,
                                    url: revalidate.url
                                });
                                response.cachePolicy = revalidatedPolicy.policy;
                                response.fromCache = true;
                            }
                        }
                        if (!response.fromCache) {
                            response.cachePolicy = new (0, (/*@__PURE__*/$parcel$interopDefault($e3bd37dd0801a28c$exports)))(options_, response, options_);
                            response.fromCache = false;
                        }
                        let clonedResponse;
                        if (options_.cache && response.cachePolicy.storable()) {
                            clonedResponse = $a6de8cfd72a6dad5$var$cloneResponse(response);
                            (async ()=>{
                                try {
                                    const bodyPromise = (0, (/*@__PURE__*/$parcel$interopDefault($d62fd2c5965796dc$exports))).buffer(response);
                                    await Promise.race([
                                        requestErrorPromise,
                                        new Promise((resolve)=>response.once("end", resolve)),
                                        new Promise((resolve)=>response.once("close", resolve))
                                    ]);
                                    const body = await bodyPromise;
                                    let value = {
                                        url: response.url,
                                        statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                                        body: body,
                                        cachePolicy: response.cachePolicy.toObject()
                                    };
                                    let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;
                                    if (options_.maxTtl) ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;
                                    if (this.hooks.size > 0) /* eslint-disable no-await-in-loop */ for (const key_ of this.hooks.keys())value = await this.runHook(key_, value, response);
                                    await this.cache.set(key, value, ttl);
                                } catch (error) {
                                    ee.emit("error", new (0, $0cd45e613d0af170$export$78ff06e91c3de382)(error));
                                }
                            })();
                        } else if (options_.cache && revalidate) (async ()=>{
                            try {
                                await this.cache.delete(key);
                            } catch (error) {
                                ee.emit("error", new (0, $0cd45e613d0af170$export$78ff06e91c3de382)(error));
                            }
                        })();
                        ee.emit("response", clonedResponse ?? response);
                        if (typeof cb === "function") cb(clonedResponse ?? response);
                    };
                    try {
                        const request_ = this.cacheRequest(options_, handler);
                        request_.once("error", requestErrorCallback);
                        request_.once("abort", requestErrorCallback);
                        request_.once("destroy", requestErrorCallback);
                        ee.emit("request", request_);
                    } catch (error) {
                        ee.emit("error", new (0, $0cd45e613d0af170$export$43ee7d0e4f429743)(error));
                    }
                };
                (async ()=>{
                    const get = async (options_)=>{
                        await Promise.resolve();
                        const cacheEntry = options_.cache ? await this.cache.get(key) : undefined;
                        if (cacheEntry === undefined && !options_.forceRefresh) {
                            makeRequest(options_);
                            return;
                        }
                        const policy = (0, (/*@__PURE__*/$parcel$interopDefault($e3bd37dd0801a28c$exports))).fromObject(cacheEntry.cachePolicy);
                        if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
                            const headers = $a6de8cfd72a6dad5$var$convertHeaders(policy.responseHeaders());
                            const response = new (0, $c49fc643257501f1$export$2e2bcd8739ae039)({
                                statusCode: cacheEntry.statusCode,
                                headers: headers,
                                body: cacheEntry.body,
                                url: cacheEntry.url
                            });
                            response.cachePolicy = policy;
                            response.fromCache = true;
                            ee.emit("response", response);
                            if (typeof cb === "function") cb(response);
                        } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {
                            await this.cache.delete(key);
                            options_.headers = policy.revalidationHeaders(options_);
                            makeRequest(options_);
                        } else {
                            revalidate = cacheEntry;
                            options_.headers = policy.revalidationHeaders(options_);
                            makeRequest(options_);
                        }
                    };
                    const errorHandler = (error)=>ee.emit("error", new (0, $0cd45e613d0af170$export$78ff06e91c3de382)(error));
                    if (this.cache instanceof (0, (/*@__PURE__*/$parcel$interopDefault($f0837960445c532c$exports)))) {
                        const cachek = this.cache;
                        cachek.once("error", errorHandler);
                        ee.on("error", ()=>cachek.removeListener("error", errorHandler));
                        ee.on("response", ()=>cachek.removeListener("error", errorHandler));
                    }
                    try {
                        await get(options);
                    } catch (error) {
                        if (options.automaticFailover && !madeRequest) makeRequest(options);
                        ee.emit("error", new (0, $0cd45e613d0af170$export$78ff06e91c3de382)(error));
                    }
                })();
                return ee;
            };
        this.addHook = (name, fn)=>{
            if (!this.hooks.has(name)) this.hooks.set(name, fn);
        };
        this.removeHook = (name)=>this.hooks.delete(name);
        this.getHook = (name)=>this.hooks.get(name);
        this.runHook = async (name, ...args)=>this.hooks.get(name)?.(...args);
        if (cacheAdapter instanceof (0, (/*@__PURE__*/$parcel$interopDefault($f0837960445c532c$exports)))) this.cache = cacheAdapter;
        else if (typeof cacheAdapter === "string") this.cache = new (0, (/*@__PURE__*/$parcel$interopDefault($f0837960445c532c$exports)))({
            uri: cacheAdapter,
            namespace: "cacheable-request"
        });
        else this.cache = new (0, (/*@__PURE__*/$parcel$interopDefault($f0837960445c532c$exports)))({
            store: cacheAdapter,
            namespace: "cacheable-request"
        });
        this.request = this.request.bind(this);
        this.cacheRequest = cacheRequest;
    }
}
const $a6de8cfd72a6dad5$var$entries = Object.entries;
const $a6de8cfd72a6dad5$var$cloneResponse = (response)=>{
    const clone = new (0, $dAk3n$nodestream.PassThrough)({
        autoDestroy: false
    });
    (0, $82581e8f56b38cb0$export$2e2bcd8739ae039)(response, clone);
    return response.pipe(clone);
};
const $a6de8cfd72a6dad5$var$urlObjectToRequestOptions = (url)=>{
    const options = {
        ...url
    };
    options.path = `${url.pathname || "/"}${url.search || ""}`;
    delete options.pathname;
    delete options.search;
    return options;
};
const $a6de8cfd72a6dad5$var$normalizeUrlObject = (url)=>// If url was parsed by url.parse or new URL:
    // - hostname will be set
    // - host will be hostname[:port]
    // - port will be set if it was explicit in the parsed string
    // Otherwise, url was from request options:
    // - hostname or host may be set
    // - host shall not have port encoded
    ({
        protocol: url.protocol,
        auth: url.auth,
        hostname: url.hostname || url.host || "localhost",
        port: url.port,
        pathname: url.pathname,
        search: url.search
    });
const $a6de8cfd72a6dad5$var$convertHeaders = (headers)=>{
    const result = [];
    for (const name of Object.keys(headers))result[name.toLowerCase()] = headers[name];
    return result;
};
var $a6de8cfd72a6dad5$export$2e2bcd8739ae039 = $a6de8cfd72a6dad5$var$CacheableRequest;
const $a6de8cfd72a6dad5$export$e9cd337c777578e7 = "onResponse";


var $4b1f68885d6f9646$exports = {};
"use strict";

var $4b1f68885d6f9646$require$Transform = $dAk3n$stream.Transform;
var $4b1f68885d6f9646$require$PassThrough = $dAk3n$stream.PassThrough;

var $59b28f09ad1d36af$exports = {};
"use strict";
// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const $59b28f09ad1d36af$var$knownProperties = [
    "aborted",
    "complete",
    "headers",
    "httpVersion",
    "httpVersionMinor",
    "httpVersionMajor",
    "method",
    "rawHeaders",
    "rawTrailers",
    "setTimeout",
    "socket",
    "statusCode",
    "statusMessage",
    "trailers",
    "url"
];
$59b28f09ad1d36af$exports = (fromStream, toStream)=>{
    if (toStream._readableState.autoDestroy) throw new Error("The second stream must have the `autoDestroy` option set to `false`");
    const fromProperties = new Set(Object.keys(fromStream).concat($59b28f09ad1d36af$var$knownProperties));
    const properties = {};
    for (const property of fromProperties){
        // Don't overwrite existing properties.
        if (property in toStream) continue;
        properties[property] = {
            get () {
                const value = fromStream[property];
                const isFunction = typeof value === "function";
                return isFunction ? value.bind(fromStream) : value;
            },
            set (value) {
                fromStream[property] = value;
            },
            enumerable: true,
            configurable: false
        };
    }
    Object.defineProperties(toStream, properties);
    fromStream.once("aborted", ()=>{
        toStream.destroy();
        toStream.emit("aborted");
    });
    fromStream.once("close", ()=>{
        if (fromStream.complete) {
            if (toStream.readable) toStream.once("end", ()=>{
                toStream.emit("close");
            });
            else toStream.emit("close");
        } else toStream.emit("close");
    });
    return toStream;
};


$4b1f68885d6f9646$exports = (response)=>{
    const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
    if (![
        "gzip",
        "deflate",
        "br"
    ].includes(contentEncoding)) return response;
    // TODO: Remove this when targeting Node.js 12.
    const isBrotli = contentEncoding === "br";
    if (isBrotli && typeof $dAk3n$zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
    }
    let isEmpty = true;
    const checker = new $4b1f68885d6f9646$require$Transform({
        transform (data, _encoding, callback) {
            isEmpty = false;
            callback(null, data);
        },
        flush (callback) {
            callback();
        }
    });
    const finalStream = new $4b1f68885d6f9646$require$PassThrough({
        autoDestroy: false,
        destroy (error, callback) {
            response.destroy();
            callback(error);
        }
    });
    const decompressStream = isBrotli ? $dAk3n$zlib.createBrotliDecompress() : $dAk3n$zlib.createUnzip();
    decompressStream.once("error", (error)=>{
        if (isEmpty && !response.readable) {
            finalStream.end();
            return;
        }
        finalStream.destroy(error);
    });
    $59b28f09ad1d36af$exports(response, finalStream);
    response.pipe(checker).pipe(decompressStream).pipe(finalStream);
    return finalStream;
};




var $06ae1ff7b4cdf2fd$exports = {};

$parcel$export($06ae1ff7b4cdf2fd$exports, "FormDataEncoder", () => $06ae1ff7b4cdf2fd$export$46728e25b8089e1b);
const $7b5d6903e09d6cc0$export$f6e2535fb5126e54 = (value)=>typeof value === "function";


const $b1af1dd4f2ddb276$var$isAsyncIterable = (value)=>(0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value[Symbol.asyncIterator]);
async function* $b1af1dd4f2ddb276$var$readStream(readable) {
    const reader = readable.getReader();
    while(true){
        const { done: done, value: value } = await reader.read();
        if (done) break;
        yield value;
    }
}
const $b1af1dd4f2ddb276$export$218db486b61781c0 = (source)=>{
    if ($b1af1dd4f2ddb276$var$isAsyncIterable(source)) return source;
    if ((0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(source.getReader)) return $b1af1dd4f2ddb276$var$readStream(source);
    throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
};


const $1bb8b2a7f193d3e9$var$alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function $1bb8b2a7f193d3e9$export$6cfc2d1b06699e89() {
    let size = 16;
    let res = "";
    while(size--)res += $1bb8b2a7f193d3e9$var$alphabet[Math.random() * $1bb8b2a7f193d3e9$var$alphabet.length << 0];
    return res;
}


const $1dcc194bc5e2e19f$export$3626aedd0f1137ab = (value)=>String(value).replace(/\r|\n/g, (match, i, str)=>{
        if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") return "\r\n";
        return match;
    });


const $18e0f8e7618f8323$var$getType = (value)=>Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function $18e0f8e7618f8323$export$53b83ca8eaab0383(value) {
    if ($18e0f8e7618f8323$var$getType(value) !== "object") return false;
    const pp = Object.getPrototypeOf(value);
    if (pp === null || pp === undefined) return true;
    const Ctor = pp.constructor && pp.constructor.toString();
    return Ctor === Object.toString();
}


function $1dfa66105c3c0c40$var$getProperty(target, prop) {
    if (typeof prop === "string") for (const [name, value] of Object.entries(target)){
        if (prop.toLowerCase() === name.toLowerCase()) return value;
    }
    return undefined;
}
const $1dfa66105c3c0c40$export$7ee4d91ffaffde7d = (object)=>new Proxy(object, {
        get: (target, prop)=>$1dfa66105c3c0c40$var$getProperty(target, prop),
        has: (target, prop)=>$1dfa66105c3c0c40$var$getProperty(target, prop) !== undefined
    });



const $3217e51b94272cab$export$67a42df2b7ab73bc = (value)=>Boolean(value && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value.constructor) && value[Symbol.toStringTag] === "FormData" && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value.append) && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value.getAll) && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value.entries) && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value[Symbol.iterator]));


const $87808ed1825d4d3a$export$a43839c3429fc510 = (name)=>String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");



const $a1ced48774b1aeb2$export$be78b3111c50efdd = (value)=>Boolean(value && typeof value === "object" && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value.constructor) && value[Symbol.toStringTag] === "File" && (0, $7b5d6903e09d6cc0$export$f6e2535fb5126e54)(value.stream) && value.name != null);
const $a1ced48774b1aeb2$export$f523b67034c5a6de = $a1ced48774b1aeb2$export$be78b3111c50efdd;


var $06ae1ff7b4cdf2fd$var$__classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var $06ae1ff7b4cdf2fd$var$_FormDataEncoder_instances, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES_LENGTH, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_DASHES, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_footer, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_form, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_options, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getFieldHeader, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getContentLength;
const $06ae1ff7b4cdf2fd$var$defaultOptions = {
    enableAdditionalHeaders: false
};
const $06ae1ff7b4cdf2fd$var$readonlyProp = {
    writable: false,
    configurable: false
};
class $06ae1ff7b4cdf2fd$export$46728e25b8089e1b {
    constructor(form, boundaryOrOptions, options){
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_instances.add(this);
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF.set(this, "\r\n");
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES.set(this, void 0);
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_DASHES.set(this, "-".repeat(2));
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder.set(this, new TextEncoder());
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_footer.set(this, void 0);
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_form.set(this, void 0);
        $06ae1ff7b4cdf2fd$var$_FormDataEncoder_options.set(this, void 0);
        if (!(0, $3217e51b94272cab$export$67a42df2b7ab73bc)(form)) throw new TypeError("Expected first argument to be a FormData instance.");
        let boundary;
        if ((0, $18e0f8e7618f8323$export$53b83ca8eaab0383)(boundaryOrOptions)) options = boundaryOrOptions;
        else boundary = boundaryOrOptions;
        if (!boundary) boundary = (0, $1bb8b2a7f193d3e9$export$6cfc2d1b06699e89)();
        if (typeof boundary !== "string") throw new TypeError("Expected boundary argument to be a string.");
        if (options && !(0, $18e0f8e7618f8323$export$53b83ca8eaab0383)(options)) throw new TypeError("Expected options argument to be an object.");
        $06ae1ff7b4cdf2fd$var$__classPrivateFieldSet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_form, Array.from(form.entries()), "f");
        $06ae1ff7b4cdf2fd$var$__classPrivateFieldSet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_options, {
            ...$06ae1ff7b4cdf2fd$var$defaultOptions,
            ...options
        }, "f");
        $06ae1ff7b4cdf2fd$var$__classPrivateFieldSet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES, $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder, "f").encode($06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, "f")), "f");
        $06ae1ff7b4cdf2fd$var$__classPrivateFieldSet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES_LENGTH, $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
        this.boundary = `form-data-boundary-${boundary}`;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        $06ae1ff7b4cdf2fd$var$__classPrivateFieldSet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_footer, $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder, "f").encode(`${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_DASHES, "f")}${this.boundary}${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_DASHES, "f")}${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
        const headers = {
            "Content-Type": this.contentType
        };
        const contentLength = $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_instances, "m", $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getContentLength).call(this);
        if (contentLength) {
            this.contentLength = contentLength;
            headers["Content-Length"] = contentLength;
        }
        this.headers = (0, $1dfa66105c3c0c40$export$7ee4d91ffaffde7d)(Object.freeze(headers));
        Object.defineProperties(this, {
            boundary: $06ae1ff7b4cdf2fd$var$readonlyProp,
            contentType: $06ae1ff7b4cdf2fd$var$readonlyProp,
            contentLength: $06ae1ff7b4cdf2fd$var$readonlyProp,
            headers: $06ae1ff7b4cdf2fd$var$readonlyProp
        });
    }
    getContentLength() {
        return this.contentLength == null ? undefined : Number(this.contentLength);
    }
    *values() {
        for (const [name, raw] of $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_form, "f")){
            const value = (0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(raw) ? raw : $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder, "f").encode((0, $1dcc194bc5e2e19f$export$3626aedd0f1137ab)(raw));
            yield $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_instances, "m", $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getFieldHeader).call(this, name, value);
            yield value;
            yield $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES, "f");
        }
        yield $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_footer, "f");
    }
    async *encode() {
        for (const part of this.values())if ((0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(part)) yield* (0, $b1af1dd4f2ddb276$export$218db486b61781c0)(part.stream());
        else yield part;
    }
    [($06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_DASHES = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_footer = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_form = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_options = new WeakMap(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_instances = new WeakSet(), $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {
        let header = "";
        header += `${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_DASHES, "f")}${this.boundary}${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${(0, $87808ed1825d4d3a$export$a43839c3429fc510)(name)}"`;
        if ((0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(value)) {
            header += `; filename="${(0, $87808ed1825d4d3a$export$a43839c3429fc510)(value.name)}"${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, "f")}`;
            header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        const size = (0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(value) ? value.size : value.byteLength;
        if ($06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_options, "f").enableAdditionalHeaders === true && size != null && !isNaN(size)) header += `${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, "f")}Content-Length: ${(0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(value) ? value.size : value.byteLength}`;
        return $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder, "f").encode(`${header}${$06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF, "f").repeat(2)}`);
    }, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getContentLength = function _FormDataEncoder_getContentLength() {
        let length = 0;
        for (const [name, raw] of $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_form, "f")){
            const value = (0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(raw) ? raw : $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_encoder, "f").encode((0, $1dcc194bc5e2e19f$export$3626aedd0f1137ab)(raw));
            const size = (0, $a1ced48774b1aeb2$export$be78b3111c50efdd)(value) ? value.size : value.byteLength;
            if (size == null || isNaN(size)) return undefined;
            length += $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_instances, "m", $06ae1ff7b4cdf2fd$var$_FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
            length += size;
            length += $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_CRLF_BYTES_LENGTH, "f");
        }
        return String(length + $06ae1ff7b4cdf2fd$var$__classPrivateFieldGet(this, $06ae1ff7b4cdf2fd$var$_FormDataEncoder_footer, "f").byteLength);
    }, Symbol.iterator)]() {
        return this.values();
    }
    [Symbol.asyncIterator]() {
        return this.encode();
    }
}

var $db4d66d2f14e6ec8$exports = {};
$parcel$export($db4d66d2f14e6ec8$exports, "isFormData", () => $3217e51b94272cab$export$67a42df2b7ab73bc);





$parcel$exportWildcard($db4d66d2f14e6ec8$exports, $06ae1ff7b4cdf2fd$exports);






function $6d4fe112227e5d6d$export$2e2bcd8739ae039(body) {
    return (0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_(body.getBoundary);
}


async function $5fdb580cd56326d4$export$2e2bcd8739ae039(body, headers) {
    if (headers && "content-length" in headers) return Number(headers["content-length"]);
    if (!body) return 0;
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(body)) return (0, $dAk3n$nodebuffer.Buffer).byteLength(body);
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer(body)) return body.length;
    if ((0, $6d4fe112227e5d6d$export$2e2bcd8739ae039)(body)) return (0, $dAk3n$nodeutil.promisify)(body.getLength.bind(body))();
    return undefined;
}



function $1ee1def4a53dcdc4$export$2e2bcd8739ae039(from, to, events) {
    const eventFunctions = {};
    for (const event of events){
        const eventFunction = (...args)=>{
            to.emit(event, ...args);
        };
        eventFunctions[event] = eventFunction;
        from.on(event, eventFunction);
    }
    return ()=>{
        for (const [event, eventFunction] of Object.entries(eventFunctions))from.off(event, eventFunction);
    };
}



// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
function $e124791f9b025201$export$2e2bcd8739ae039() {
    const handlers = [];
    return {
        once (origin, event, fn) {
            origin.once(event, fn);
            handlers.push({
                origin: origin,
                event: event,
                fn: fn
            });
        },
        unhandleAll () {
            for (const handler of handlers){
                const { origin: origin, event: event, fn: fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
}


const $2ffcdd5ca9812885$var$reentry = Symbol("reentry");
const $2ffcdd5ca9812885$var$noop = ()=>{};
class $2ffcdd5ca9812885$export$66d311bf29d5c89c extends Error {
    constructor(threshold, event){
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: event
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
    }
}
function $2ffcdd5ca9812885$export$2e2bcd8739ae039(request, delays, options) {
    if ($2ffcdd5ca9812885$var$reentry in request) return $2ffcdd5ca9812885$var$noop;
    request[$2ffcdd5ca9812885$var$reentry] = true;
    const cancelers = [];
    const { once: once, unhandleAll: unhandleAll } = (0, $e124791f9b025201$export$2e2bcd8739ae039)();
    const addTimeout = (delay, callback, event)=>{
        const timeout = setTimeout(callback, delay, delay, event);
        timeout.unref?.();
        const cancel = ()=>{
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host: host, hostname: hostname } = options;
    const timeoutHandler = (delay, event)=>{
        request.destroy(new $2ffcdd5ca9812885$export$66d311bf29d5c89c(delay, event));
    };
    const cancelTimeouts = ()=>{
        for (const cancel of cancelers)cancel();
        unhandleAll();
    };
    request.once("error", (error)=>{
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */ if (request.listenerCount("error") === 0) throw error;
    });
    if (typeof delays.request !== "undefined") {
        const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
        once(request, "response", (response)=>{
            once(response, "end", cancelTimeout);
        });
    }
    if (typeof delays.socket !== "undefined") {
        const { socket: socket } = delays;
        const socketTimeoutHandler = ()=>{
            timeoutHandler(socket, "socket");
        };
        request.setTimeout(socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(()=>{
            request.removeListener("timeout", socketTimeoutHandler);
        });
    }
    const hasLookup = typeof delays.lookup !== "undefined";
    const hasConnect = typeof delays.connect !== "undefined";
    const hasSecureConnect = typeof delays.secureConnect !== "undefined";
    const hasSend = typeof delays.send !== "undefined";
    if (hasLookup || hasConnect || hasSecureConnect || hasSend) once(request, "socket", (socket)=>{
        const { socketPath: socketPath } = request;
        /* istanbul ignore next: hard to test */ if (socket.connecting) {
            const hasPath = Boolean(socketPath ?? (0, ($parcel$interopDefault($dAk3n$nodenet))).isIP(hostname ?? host ?? "") !== 0);
            if (hasLookup && !hasPath && typeof socket.address().address === "undefined") {
                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
                once(socket, "lookup", cancelTimeout);
            }
            if (hasConnect) {
                const timeConnect = ()=>addTimeout(delays.connect, timeoutHandler, "connect");
                if (hasPath) once(socket, "connect", timeConnect());
                else once(socket, "lookup", (error)=>{
                    if (error === null) once(socket, "connect", timeConnect());
                });
            }
            if (hasSecureConnect && options.protocol === "https:") once(socket, "connect", ()=>{
                const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
                once(socket, "secureConnect", cancelTimeout);
            });
        }
        if (hasSend) {
            const timeRequest = ()=>addTimeout(delays.send, timeoutHandler, "send");
            /* istanbul ignore next: hard to test */ if (socket.connecting) once(socket, "connect", ()=>{
                once(request, "upload-complete", timeRequest());
            });
            else once(request, "upload-complete", timeRequest());
        }
    });
    if (typeof delays.response !== "undefined") once(request, "upload-complete", ()=>{
        const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
        once(request, "response", cancelTimeout);
    });
    if (typeof delays.read !== "undefined") once(request, "response", (response)=>{
        const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
        once(response, "end", cancelTimeout);
    });
    return cancelTimeouts;
}



function $d96cf451135558de$export$2e2bcd8739ae039(url) {
    url;
    const options = {
        protocol: url.protocol,
        hostname: (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(url.port) && url.port.length > 0) options.port = Number(url.port);
    if (url.username || url.password) options.auth = `${url.username || ""}:${url.password || ""}`;
    return options;
}


class $3fee59244baa25fc$export$2e2bcd8739ae039 {
    constructor(){
        Object.defineProperty(this, "weakMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "map", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === "object") this.weakMap.set(key, value);
        else this.map.set(key, value);
    }
    get(key) {
        if (typeof key === "object") return this.weakMap.get(key);
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === "object") return this.weakMap.has(key);
        return this.map.has(key);
    }
}


const $4b7363a0144183fb$var$calculateRetryDelay = ({ attemptCount: attemptCount, retryOptions: retryOptions, error: error, retryAfter: retryAfter, computedValue: computedValue })=>{
    if (error.name === "RetryError") return 1;
    if (attemptCount > retryOptions.limit) return 0;
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || !hasErrorCode && !hasStatusCode) return 0;
    if (error.response) {
        if (retryAfter) {
            // In this case `computedValue` is `options.request.timeout`
            if (retryAfter > computedValue) return 0;
            return retryAfter;
        }
        if (error.response.statusCode === 413) return 0;
    }
    const noise = Math.random() * retryOptions.noise;
    return Math.min(2 ** (attemptCount - 1) * 1000, retryOptions.backoffLimit) + noise;
};
var $4b7363a0144183fb$export$2e2bcd8739ae039 = $4b7363a0144183fb$var$calculateRetryDelay;













const { Resolver: $c3c5a2a4f023bf43$var$AsyncResolver } = (0, $dAk3n$nodedns.promises);
const $c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
const $c3c5a2a4f023bf43$var$kCacheableLookupInstance = Symbol("cacheableLookupInstance");
const $c3c5a2a4f023bf43$var$kExpires = Symbol("expires");
const $c3c5a2a4f023bf43$var$supportsALL = typeof (0, $dAk3n$nodedns.ALL) === "number";
const $c3c5a2a4f023bf43$var$verifyAgent = (agent)=>{
    if (!(agent && typeof agent.createConnection === "function")) throw new Error("Expected an Agent instance as the first argument");
};
const $c3c5a2a4f023bf43$var$map4to6 = (entries)=>{
    for (const entry of entries){
        if (entry.family === 6) continue;
        entry.address = `::ffff:${entry.address}`;
        entry.family = 6;
    }
};
const $c3c5a2a4f023bf43$var$getIfaceInfo = ()=>{
    let has4 = false;
    let has6 = false;
    for (const device of Object.values((0, ($parcel$interopDefault($dAk3n$nodeos))).networkInterfaces()))for (const iface of device){
        if (iface.internal) continue;
        if (iface.family === "IPv6") has6 = true;
        else has4 = true;
        if (has4 && has6) return {
            has4: has4,
            has6: has6
        };
    }
    return {
        has4: has4,
        has6: has6
    };
};
const $c3c5a2a4f023bf43$var$isIterable = (map)=>{
    return Symbol.iterator in map;
};
const $c3c5a2a4f023bf43$var$ignoreNoResultErrors = (dnsPromise)=>{
    return dnsPromise.catch((error)=>{
        if (error.code === "ENODATA" || error.code === "ENOTFOUND" || error.code === "ENOENT" // Windows: name exists, but not this record type
        ) return [];
        throw error;
    });
};
const $c3c5a2a4f023bf43$var$ttl = {
    ttl: true
};
const $c3c5a2a4f023bf43$var$all = {
    all: true
};
const $c3c5a2a4f023bf43$var$all4 = {
    all: true,
    family: 4
};
const $c3c5a2a4f023bf43$var$all6 = {
    all: true,
    family: 6
};
class $c3c5a2a4f023bf43$export$2e2bcd8739ae039 {
    constructor({ cache: cache = new Map(), maxTtl: maxTtl = Infinity, fallbackDuration: fallbackDuration = 3600, errorTtl: errorTtl = 0.15, resolver: resolver = new $c3c5a2a4f023bf43$var$AsyncResolver(), lookup: lookup = (0, $dAk3n$nodedns.lookup) } = {}){
        this.maxTtl = maxTtl;
        this.errorTtl = errorTtl;
        this._cache = cache;
        this._resolver = resolver;
        this._dnsLookup = lookup && (0, $dAk3n$nodeutil.promisify)(lookup);
        this.stats = {
            cache: 0,
            query: 0
        };
        if (this._resolver instanceof $c3c5a2a4f023bf43$var$AsyncResolver) {
            this._resolve4 = this._resolver.resolve4.bind(this._resolver);
            this._resolve6 = this._resolver.resolve6.bind(this._resolver);
        } else {
            this._resolve4 = (0, $dAk3n$nodeutil.promisify)(this._resolver.resolve4.bind(this._resolver));
            this._resolve6 = (0, $dAk3n$nodeutil.promisify)(this._resolver.resolve6.bind(this._resolver));
        }
        this._iface = $c3c5a2a4f023bf43$var$getIfaceInfo();
        this._pending = {};
        this._nextRemovalTime = false;
        this._hostnamesToFallback = new Set();
        this.fallbackDuration = fallbackDuration;
        if (fallbackDuration > 0) {
            const interval = setInterval(()=>{
                this._hostnamesToFallback.clear();
            }, fallbackDuration * 1000);
            /* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */ if (interval.unref) interval.unref();
            this._fallbackInterval = interval;
        }
        this.lookup = this.lookup.bind(this);
        this.lookupAsync = this.lookupAsync.bind(this);
    }
    set servers(servers) {
        this.clear();
        this._resolver.setServers(servers);
    }
    get servers() {
        return this._resolver.getServers();
    }
    lookup(hostname, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {};
        } else if (typeof options === "number") options = {
            family: options
        };
        if (!callback) throw new Error("Callback must be a function.");
        // eslint-disable-next-line promise/prefer-await-to-then
        this.lookupAsync(hostname, options).then((result)=>{
            if (options.all) callback(null, result);
            else callback(null, result.address, result.family, result.expires, result.ttl, result.source);
        }, callback);
    }
    async lookupAsync(hostname, options = {}) {
        if (typeof options === "number") options = {
            family: options
        };
        let cached = await this.query(hostname);
        if (options.family === 6) {
            const filtered = cached.filter((entry)=>entry.family === 6);
            if (options.hints & (0, $dAk3n$nodedns.V4MAPPED)) {
                if ($c3c5a2a4f023bf43$var$supportsALL && options.hints & (0, $dAk3n$nodedns.ALL) || filtered.length === 0) $c3c5a2a4f023bf43$var$map4to6(cached);
                else cached = filtered;
            } else cached = filtered;
        } else if (options.family === 4) cached = cached.filter((entry)=>entry.family === 4);
        if (options.hints & (0, $dAk3n$nodedns.ADDRCONFIG)) {
            const { _iface: _iface } = this;
            cached = cached.filter((entry)=>entry.family === 6 ? _iface.has6 : _iface.has4);
        }
        if (cached.length === 0) {
            const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
            error.code = "ENOTFOUND";
            error.hostname = hostname;
            throw error;
        }
        if (options.all) return cached;
        return cached[0];
    }
    async query(hostname) {
        let source = "cache";
        let cached = await this._cache.get(hostname);
        if (cached) this.stats.cache++;
        if (!cached) {
            const pending = this._pending[hostname];
            if (pending) {
                this.stats.cache++;
                cached = await pending;
            } else {
                source = "query";
                const newPromise = this.queryAndCache(hostname);
                this._pending[hostname] = newPromise;
                this.stats.query++;
                try {
                    cached = await newPromise;
                } finally{
                    delete this._pending[hostname];
                }
            }
        }
        cached = cached.map((entry)=>{
            return {
                ...entry,
                source: source
            };
        });
        return cached;
    }
    async _resolve(hostname) {
        // ANY is unsafe as it doesn't trigger new queries in the underlying server.
        const [A, AAAA] = await Promise.all([
            $c3c5a2a4f023bf43$var$ignoreNoResultErrors(this._resolve4(hostname, $c3c5a2a4f023bf43$var$ttl)),
            $c3c5a2a4f023bf43$var$ignoreNoResultErrors(this._resolve6(hostname, $c3c5a2a4f023bf43$var$ttl))
        ]);
        let aTtl = 0;
        let aaaaTtl = 0;
        let cacheTtl = 0;
        const now = Date.now();
        for (const entry of A){
            entry.family = 4;
            entry.expires = now + entry.ttl * 1000;
            aTtl = Math.max(aTtl, entry.ttl);
        }
        for (const entry of AAAA){
            entry.family = 6;
            entry.expires = now + entry.ttl * 1000;
            aaaaTtl = Math.max(aaaaTtl, entry.ttl);
        }
        if (A.length > 0) {
            if (AAAA.length > 0) cacheTtl = Math.min(aTtl, aaaaTtl);
            else cacheTtl = aTtl;
        } else cacheTtl = aaaaTtl;
        return {
            entries: [
                ...A,
                ...AAAA
            ],
            cacheTtl: cacheTtl
        };
    }
    async _lookup(hostname) {
        try {
            const [A, AAAA] = await Promise.all([
                // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
                // See https://github.com/szmarczak/cacheable-lookup/issues/42
                $c3c5a2a4f023bf43$var$ignoreNoResultErrors(this._dnsLookup(hostname, $c3c5a2a4f023bf43$var$all4)),
                $c3c5a2a4f023bf43$var$ignoreNoResultErrors(this._dnsLookup(hostname, $c3c5a2a4f023bf43$var$all6))
            ]);
            return {
                entries: [
                    ...A,
                    ...AAAA
                ],
                cacheTtl: 0
            };
        } catch  {
            return {
                entries: [],
                cacheTtl: 0
            };
        }
    }
    async _set(hostname, data, cacheTtl) {
        if (this.maxTtl > 0 && cacheTtl > 0) {
            cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
            data[$c3c5a2a4f023bf43$var$kExpires] = Date.now() + cacheTtl;
            try {
                await this._cache.set(hostname, data, cacheTtl);
            } catch (error) {
                this.lookupAsync = async ()=>{
                    const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
                    cacheError.cause = error;
                    throw cacheError;
                };
            }
            if ($c3c5a2a4f023bf43$var$isIterable(this._cache)) this._tick(cacheTtl);
        }
    }
    async queryAndCache(hostname) {
        if (this._hostnamesToFallback.has(hostname)) return this._dnsLookup(hostname, $c3c5a2a4f023bf43$var$all);
        let query = await this._resolve(hostname);
        if (query.entries.length === 0 && this._dnsLookup) {
            query = await this._lookup(hostname);
            if (query.entries.length !== 0 && this.fallbackDuration > 0) // Use `dns.lookup(...)` for that particular hostname
            this._hostnamesToFallback.add(hostname);
        }
        const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
        await this._set(hostname, query.entries, cacheTtl);
        return query.entries;
    }
    _tick(ms) {
        const nextRemovalTime = this._nextRemovalTime;
        if (!nextRemovalTime || ms < nextRemovalTime) {
            clearTimeout(this._removalTimeout);
            this._nextRemovalTime = ms;
            this._removalTimeout = setTimeout(()=>{
                this._nextRemovalTime = false;
                let nextExpiry = Infinity;
                const now = Date.now();
                for (const [hostname, entries] of this._cache){
                    const expires = entries[$c3c5a2a4f023bf43$var$kExpires];
                    if (now >= expires) this._cache.delete(hostname);
                    else if (expires < nextExpiry) nextExpiry = expires;
                }
                if (nextExpiry !== Infinity) this._tick(nextExpiry - now);
            }, ms);
            /* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */ if (this._removalTimeout.unref) this._removalTimeout.unref();
        }
    }
    install(agent) {
        $c3c5a2a4f023bf43$var$verifyAgent(agent);
        if ($c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection in agent) throw new Error("CacheableLookup has been already installed");
        agent[$c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection] = agent.createConnection;
        agent[$c3c5a2a4f023bf43$var$kCacheableLookupInstance] = this;
        agent.createConnection = (options, callback)=>{
            if (!("lookup" in options)) options.lookup = this.lookup;
            return agent[$c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection](options, callback);
        };
    }
    uninstall(agent) {
        $c3c5a2a4f023bf43$var$verifyAgent(agent);
        if (agent[$c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection]) {
            if (agent[$c3c5a2a4f023bf43$var$kCacheableLookupInstance] !== this) throw new Error("The agent is not owned by this CacheableLookup instance");
            agent.createConnection = agent[$c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection];
            delete agent[$c3c5a2a4f023bf43$var$kCacheableLookupCreateConnection];
            delete agent[$c3c5a2a4f023bf43$var$kCacheableLookupInstance];
        }
    }
    updateInterfaceInfo() {
        const { _iface: _iface } = this;
        this._iface = $c3c5a2a4f023bf43$var$getIfaceInfo();
        if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) this._cache.clear();
    }
    clear(hostname) {
        if (hostname) {
            this._cache.delete(hostname);
            return;
        }
        this._cache.clear();
    }
}


var $2a024f368552c192$exports = {};
"use strict";

var $f27a9ba7f5496a52$exports = {};
"use strict";

var $f27a9ba7f5496a52$require$URL = $dAk3n$url.URL;



var $40a8e476d2ca8d4c$exports = {};
"use strict";
class $40a8e476d2ca8d4c$var$QuickLRU {
    constructor(options = {}){
        if (!(options.maxSize && options.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
    }
    _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
            this._size = 0;
            if (typeof this.onEviction === "function") for (const [key, value] of this.oldCache.entries())this.onEviction(key, value);
            this.oldCache = this.cache;
            this.cache = new Map();
        }
    }
    get(key) {
        if (this.cache.has(key)) return this.cache.get(key);
        if (this.oldCache.has(key)) {
            const value = this.oldCache.get(key);
            this.oldCache.delete(key);
            this._set(key, value);
            return value;
        }
    }
    set(key, value) {
        if (this.cache.has(key)) this.cache.set(key, value);
        else this._set(key, value);
        return this;
    }
    has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
    }
    peek(key) {
        if (this.cache.has(key)) return this.cache.get(key);
        if (this.oldCache.has(key)) return this.oldCache.get(key);
    }
    delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) this._size--;
        return this.oldCache.delete(key) || deleted;
    }
    clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
    }
    *keys() {
        for (const [key] of this)yield key;
    }
    *values() {
        for (const [, value] of this)yield value;
    }
    *[Symbol.iterator]() {
        for (const item of this.cache)yield item;
        for (const item of this.oldCache){
            const [key] = item;
            if (!this.cache.has(key)) yield item;
        }
    }
    get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys())if (!this.cache.has(key)) oldCacheSize++;
        return Math.min(this._size + oldCacheSize, this.maxSize);
    }
}
$40a8e476d2ca8d4c$exports = $40a8e476d2ca8d4c$var$QuickLRU;


var $a74a06cdc7c0a760$exports = {};
"use strict";
$a74a06cdc7c0a760$exports = (stream)=>{
    if (stream.listenerCount("error") !== 0) return stream;
    stream.__destroy = stream._destroy;
    stream._destroy = (...args)=>{
        const callback = args.pop();
        stream.__destroy(...args, async (error)=>{
            await Promise.resolve();
            callback(error);
        });
    };
    const onError = (error)=>{
        // eslint-disable-next-line promise/prefer-await-to-then
        Promise.resolve().then(()=>{
            stream.emit("error", error);
        });
    };
    stream.once("error", onError);
    // eslint-disable-next-line promise/prefer-await-to-then
    Promise.resolve().then(()=>{
        stream.off("error", onError);
    });
    return stream;
};


const $f27a9ba7f5496a52$var$kCurrentStreamCount = Symbol("currentStreamCount");
const $f27a9ba7f5496a52$var$kRequest = Symbol("request");
const $f27a9ba7f5496a52$var$kOriginSet = Symbol("cachedOriginSet");
const $f27a9ba7f5496a52$var$kGracefullyClosing = Symbol("gracefullyClosing");
const $f27a9ba7f5496a52$var$kLength = Symbol("length");
const $f27a9ba7f5496a52$var$nameKeys = [
    // Not an Agent option actually
    "createConnection",
    // `http2.connect()` options
    "maxDeflateDynamicTableSize",
    "maxSettings",
    "maxSessionMemory",
    "maxHeaderListPairs",
    "maxOutstandingPings",
    "maxReservedRemoteStreams",
    "maxSendHeaderBlockLength",
    "paddingStrategy",
    "peerMaxConcurrentStreams",
    "settings",
    // `tls.connect()` source options
    "family",
    "localAddress",
    "rejectUnauthorized",
    // `tls.connect()` secure context options
    "pskCallback",
    "minDHSize",
    // `tls.connect()` destination options
    // - `servername` is automatically validated, skip it
    // - `host` and `port` just describe the destination server,
    "path",
    "socket",
    // `tls.createSecureContext()` options
    "ca",
    "cert",
    "sigalgs",
    "ciphers",
    "clientCertEngine",
    "crl",
    "dhparam",
    "ecdhCurve",
    "honorCipherOrder",
    "key",
    "privateKeyEngine",
    "privateKeyIdentifier",
    "maxVersion",
    "minVersion",
    "pfx",
    "secureOptions",
    "secureProtocol",
    "sessionIdContext",
    "ticketKeys"
];
const $f27a9ba7f5496a52$var$getSortedIndex = (array, value, compare)=>{
    let low = 0;
    let high = array.length;
    while(low < high){
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) low = mid + 1;
        else high = mid;
    }
    return low;
};
const $f27a9ba7f5496a52$var$compareSessions = (a, b)=>a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
// See https://tools.ietf.org/html/rfc8336
const $f27a9ba7f5496a52$var$closeCoveredSessions = (where, session)=>{
    // Clients SHOULD NOT emit new requests on any connection whose Origin
    // Set is a proper subset of another connection's Origin Set, and they
    // SHOULD close it once all outstanding requests are satisfied.
    for(let index = 0; index < where.length; index++){
        const coveredSession = where[index];
        if (// Unfortunately `.every()` returns true for an empty array
        coveredSession[$f27a9ba7f5496a52$var$kOriginSet].length > 0 && coveredSession[$f27a9ba7f5496a52$var$kOriginSet].length < session[$f27a9ba7f5496a52$var$kOriginSet].length && coveredSession[$f27a9ba7f5496a52$var$kOriginSet].every((origin)=>session[$f27a9ba7f5496a52$var$kOriginSet].includes(origin)) && coveredSession[$f27a9ba7f5496a52$var$kCurrentStreamCount] + session[$f27a9ba7f5496a52$var$kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) // This allows pending requests to finish and prevents making new requests.
        $f27a9ba7f5496a52$var$gracefullyClose(coveredSession);
    }
};
// This is basically inverted `closeCoveredSessions(...)`.
const $f27a9ba7f5496a52$var$closeSessionIfCovered = (where, coveredSession)=>{
    for(let index = 0; index < where.length; index++){
        const session = where[index];
        if (coveredSession[$f27a9ba7f5496a52$var$kOriginSet].length > 0 && coveredSession[$f27a9ba7f5496a52$var$kOriginSet].length < session[$f27a9ba7f5496a52$var$kOriginSet].length && coveredSession[$f27a9ba7f5496a52$var$kOriginSet].every((origin)=>session[$f27a9ba7f5496a52$var$kOriginSet].includes(origin)) && coveredSession[$f27a9ba7f5496a52$var$kCurrentStreamCount] + session[$f27a9ba7f5496a52$var$kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
            $f27a9ba7f5496a52$var$gracefullyClose(coveredSession);
            return true;
        }
    }
    return false;
};
const $f27a9ba7f5496a52$var$gracefullyClose = (session)=>{
    session[$f27a9ba7f5496a52$var$kGracefullyClosing] = true;
    if (session[$f27a9ba7f5496a52$var$kCurrentStreamCount] === 0) session.close();
};
class $f27a9ba7f5496a52$var$Agent extends $dAk3n$events {
    constructor({ timeout: timeout = 0, maxSessions: maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions: maxEmptySessions = 10, maxCachedTlsSessions: maxCachedTlsSessions = 100 } = {}){
        super();
        // SESSIONS[NORMALIZED_OPTIONS] = [];
        this.sessions = {};
        // The queue for creating new sessions. It looks like this:
        // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
        //
        // It's faster when there are many origins. If there's only one, then QUEUE[`${options}:${origin}`] is faster.
        // I guess object creation / deletion is causing the slowdown.
        //
        // The entry function has `listeners`, `completed` and `destroyed` properties.
        // `listeners` is an array of objects containing `resolve` and `reject` functions.
        // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
        // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
        this.queue = {};
        // Each session will use this timeout value.
        this.timeout = timeout;
        // Max sessions in total
        this.maxSessions = maxSessions;
        // Max empty sessions in total
        this.maxEmptySessions = maxEmptySessions;
        this._emptySessionCount = 0;
        this._sessionCount = 0;
        // We don't support push streams by default.
        this.settings = {
            enablePush: false,
            initialWindowSize: 33554432 // 32MB, see https://github.com/nodejs/node/issues/38426
        };
        // Reusing TLS sessions increases performance.
        this.tlsSessionCache = new $40a8e476d2ca8d4c$exports({
            maxSize: maxCachedTlsSessions
        });
    }
    get protocol() {
        return "https:";
    }
    normalizeOptions(options) {
        let normalized = "";
        for(let index = 0; index < $f27a9ba7f5496a52$var$nameKeys.length; index++){
            const key = $f27a9ba7f5496a52$var$nameKeys[index];
            normalized += ":";
            if (options && options[key] !== undefined) normalized += options[key];
        }
        return normalized;
    }
    _processQueue() {
        if (this._sessionCount >= this.maxSessions) {
            this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
            return;
        }
        // eslint-disable-next-line guard-for-in
        for(const normalizedOptions in this.queue)// eslint-disable-next-line guard-for-in
        for(const normalizedOrigin in this.queue[normalizedOptions]){
            const item = this.queue[normalizedOptions][normalizedOrigin];
            // The entry function can be run only once.
            if (!item.completed) {
                item.completed = true;
                item();
            }
        }
    }
    _isBetterSession(thisStreamCount, thatStreamCount) {
        return thisStreamCount > thatStreamCount;
    }
    _accept(session, listeners, normalizedOrigin, options) {
        let index = 0;
        while(index < listeners.length && session[$f27a9ba7f5496a52$var$kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams){
            // We assume `resolve(...)` calls `request(...)` *directly*,
            // otherwise the session will get overloaded.
            listeners[index].resolve(session);
            index++;
        }
        listeners.splice(0, index);
        if (listeners.length > 0) {
            this.getSession(normalizedOrigin, options, listeners);
            listeners.length = 0;
        }
    }
    getSession(origin, options, listeners) {
        return new Promise((resolve, reject)=>{
            if (Array.isArray(listeners) && listeners.length > 0) {
                listeners = [
                    ...listeners
                ];
                // Resolve the current promise ASAP, we're just moving the listeners.
                // They will be executed at a different time.
                resolve();
            } else listeners = [
                {
                    resolve: resolve,
                    reject: reject
                }
            ];
            try {
                // Parse origin
                if (typeof origin === "string") origin = new $f27a9ba7f5496a52$require$URL(origin);
                else if (!(origin instanceof $f27a9ba7f5496a52$require$URL)) throw new TypeError("The `origin` argument needs to be a string or an URL object");
                if (options) {
                    // Validate servername
                    const { servername: servername } = options;
                    const { hostname: hostname } = origin;
                    if (servername && hostname !== servername) throw new Error(`Origin ${hostname} differs from servername ${servername}`);
                }
            } catch (error) {
                for(let index = 0; index < listeners.length; index++)listeners[index].reject(error);
                return;
            }
            const normalizedOptions = this.normalizeOptions(options);
            const normalizedOrigin = origin.origin;
            if (normalizedOptions in this.sessions) {
                const sessions = this.sessions[normalizedOptions];
                let maxConcurrentStreams = -1;
                let currentStreamsCount = -1;
                let optimalSession;
                // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
                // Additionally, we are looking for session which has biggest current pending streams count.
                //
                // |------------| |------------| |------------| |------------|
                // | Session: A | | Session: B | | Session: C | | Session: D |
                // | Pending: 5 |-| Pending: 8 |-| Pending: 9 |-| Pending: 4 |
                // | Max:    10 | | Max:    10 | | Max:     9 | | Max:     5 |
                // |------------| |------------| |------------| |------------|
                //                     ^
                //                     |
                //     pick this one  --
                //
                for(let index = 0; index < sessions.length; index++){
                    const session = sessions[index];
                    const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
                    if (sessionMaxConcurrentStreams < maxConcurrentStreams) break;
                    if (!session[$f27a9ba7f5496a52$var$kOriginSet].includes(normalizedOrigin)) continue;
                    const sessionCurrentStreamsCount = session[$f27a9ba7f5496a52$var$kCurrentStreamCount];
                    if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[$f27a9ba7f5496a52$var$kGracefullyClosing] || session.destroyed) continue;
                    // We only need set this once.
                    if (!optimalSession) maxConcurrentStreams = sessionMaxConcurrentStreams;
                    // Either get the session which has biggest current stream count or the lowest.
                    if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
                        optimalSession = session;
                        currentStreamsCount = sessionCurrentStreamsCount;
                    }
                }
                if (optimalSession) {
                    this._accept(optimalSession, listeners, normalizedOrigin, options);
                    return;
                }
            }
            if (normalizedOptions in this.queue) {
                if (normalizedOrigin in this.queue[normalizedOptions]) {
                    // There's already an item in the queue, just attach ourselves to it.
                    this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
                    return;
                }
            } else this.queue[normalizedOptions] = {
                [$f27a9ba7f5496a52$var$kLength]: 0
            };
            // The entry must be removed from the queue IMMEDIATELY when:
            // 1. the session connects successfully,
            // 2. an error occurs.
            const removeFromQueue = ()=>{
                // Our entry can be replaced. We cannot remove the new one.
                if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
                    delete this.queue[normalizedOptions][normalizedOrigin];
                    if (--this.queue[normalizedOptions][$f27a9ba7f5496a52$var$kLength] === 0) delete this.queue[normalizedOptions];
                }
            };
            // The main logic is here
            const entry = async ()=>{
                this._sessionCount++;
                const name = `${normalizedOrigin}:${normalizedOptions}`;
                let receivedSettings = false;
                let socket;
                try {
                    const computedOptions = {
                        ...options
                    };
                    if (computedOptions.settings === undefined) computedOptions.settings = this.settings;
                    if (computedOptions.session === undefined) computedOptions.session = this.tlsSessionCache.get(name);
                    const createConnection = computedOptions.createConnection || this.createConnection;
                    // A hacky workaround to enable async `createConnection`
                    socket = await createConnection.call(this, origin, computedOptions);
                    computedOptions.createConnection = ()=>socket;
                    const session = $dAk3n$http2.connect(origin, computedOptions);
                    session[$f27a9ba7f5496a52$var$kCurrentStreamCount] = 0;
                    session[$f27a9ba7f5496a52$var$kGracefullyClosing] = false;
                    // Node.js return https://false:443 instead of https://1.1.1.1:443
                    const getOriginSet = ()=>{
                        const { socket: socket } = session;
                        let originSet;
                        if (socket.servername === false) {
                            socket.servername = socket.remoteAddress;
                            originSet = session.originSet;
                            socket.servername = false;
                        } else originSet = session.originSet;
                        return originSet;
                    };
                    const isFree = ()=>session[$f27a9ba7f5496a52$var$kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;
                    session.socket.once("session", (tlsSession)=>{
                        this.tlsSessionCache.set(name, tlsSession);
                    });
                    session.once("error", (error)=>{
                        // Listeners are empty when the session successfully connected.
                        for(let index = 0; index < listeners.length; index++)listeners[index].reject(error);
                        // The connection got broken, purge the cache.
                        this.tlsSessionCache.delete(name);
                    });
                    session.setTimeout(this.timeout, ()=>{
                        // Terminates all streams owned by this session.
                        session.destroy();
                    });
                    session.once("close", ()=>{
                        this._sessionCount--;
                        if (receivedSettings) {
                            // Assumes session `close` is emitted after request `close`
                            this._emptySessionCount--;
                            // This cannot be moved to the stream logic,
                            // because there may be a session that hadn't made a single request.
                            const where = this.sessions[normalizedOptions];
                            if (where.length === 1) delete this.sessions[normalizedOptions];
                            else where.splice(where.indexOf(session), 1);
                        } else {
                            // Broken connection
                            removeFromQueue();
                            const error = new Error("Session closed without receiving a SETTINGS frame");
                            error.code = "HTTP2WRAPPER_NOSETTINGS";
                            for(let index = 0; index < listeners.length; index++)listeners[index].reject(error);
                        }
                        // There may be another session awaiting.
                        this._processQueue();
                    });
                    // Iterates over the queue and processes listeners.
                    const processListeners = ()=>{
                        const queue = this.queue[normalizedOptions];
                        if (!queue) return;
                        const originSet = session[$f27a9ba7f5496a52$var$kOriginSet];
                        for(let index = 0; index < originSet.length; index++){
                            const origin = originSet[index];
                            if (origin in queue) {
                                const { listeners: listeners, completed: completed } = queue[origin];
                                let index = 0;
                                // Prevents session overloading.
                                while(index < listeners.length && isFree()){
                                    // We assume `resolve(...)` calls `request(...)` *directly*,
                                    // otherwise the session will get overloaded.
                                    listeners[index].resolve(session);
                                    index++;
                                }
                                queue[origin].listeners.splice(0, index);
                                if (queue[origin].listeners.length === 0 && !completed) {
                                    delete queue[origin];
                                    if (--queue[$f27a9ba7f5496a52$var$kLength] === 0) {
                                        delete this.queue[normalizedOptions];
                                        break;
                                    }
                                }
                                // We're no longer free, no point in continuing.
                                if (!isFree()) break;
                            }
                        }
                    };
                    // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
                    session.on("origin", ()=>{
                        session[$f27a9ba7f5496a52$var$kOriginSet] = getOriginSet() || [];
                        session[$f27a9ba7f5496a52$var$kGracefullyClosing] = false;
                        $f27a9ba7f5496a52$var$closeSessionIfCovered(this.sessions[normalizedOptions], session);
                        if (session[$f27a9ba7f5496a52$var$kGracefullyClosing] || !isFree()) return;
                        processListeners();
                        if (!isFree()) return;
                        // Close covered sessions (if possible).
                        $f27a9ba7f5496a52$var$closeCoveredSessions(this.sessions[normalizedOptions], session);
                    });
                    session.once("remoteSettings", ()=>{
                        // The Agent could have been destroyed already.
                        if (entry.destroyed) {
                            const error = new Error("Agent has been destroyed");
                            for(let index = 0; index < listeners.length; index++)listeners[index].reject(error);
                            session.destroy();
                            return;
                        }
                        // See https://github.com/nodejs/node/issues/38426
                        if (session.setLocalWindowSize) session.setLocalWindowSize(4194304); // 4 MB
                        session[$f27a9ba7f5496a52$var$kOriginSet] = getOriginSet() || [];
                        if (session.socket.encrypted) {
                            const mainOrigin = session[$f27a9ba7f5496a52$var$kOriginSet][0];
                            if (mainOrigin !== normalizedOrigin) {
                                const error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                                for(let index = 0; index < listeners.length; index++)listeners[index].reject(error);
                                session.destroy();
                                return;
                            }
                        }
                        removeFromQueue();
                        {
                            const where = this.sessions;
                            if (normalizedOptions in where) {
                                const sessions = where[normalizedOptions];
                                sessions.splice($f27a9ba7f5496a52$var$getSortedIndex(sessions, session, $f27a9ba7f5496a52$var$compareSessions), 0, session);
                            } else where[normalizedOptions] = [
                                session
                            ];
                        }
                        receivedSettings = true;
                        this._emptySessionCount++;
                        this.emit("session", session);
                        this._accept(session, listeners, normalizedOrigin, options);
                        if (session[$f27a9ba7f5496a52$var$kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
                        // `session.remoteSettings.maxConcurrentStreams` might get increased
                        session.on("remoteSettings", ()=>{
                            if (!isFree()) return;
                            processListeners();
                            if (!isFree()) return;
                            // In case the Origin Set changes
                            $f27a9ba7f5496a52$var$closeCoveredSessions(this.sessions[normalizedOptions], session);
                        });
                    });
                    // Shim `session.request()` in order to catch all streams
                    session[$f27a9ba7f5496a52$var$kRequest] = session.request;
                    session.request = (headers, streamOptions)=>{
                        if (session[$f27a9ba7f5496a52$var$kGracefullyClosing]) throw new Error("The session is gracefully closing. No new streams are allowed.");
                        const stream = session[$f27a9ba7f5496a52$var$kRequest](headers, streamOptions);
                        // The process won't exit until the session is closed or all requests are gone.
                        session.ref();
                        if (session[$f27a9ba7f5496a52$var$kCurrentStreamCount]++ === 0) this._emptySessionCount--;
                        stream.once("close", ()=>{
                            if (--session[$f27a9ba7f5496a52$var$kCurrentStreamCount] === 0) {
                                this._emptySessionCount++;
                                session.unref();
                                if (this._emptySessionCount > this.maxEmptySessions || session[$f27a9ba7f5496a52$var$kGracefullyClosing]) {
                                    session.close();
                                    return;
                                }
                            }
                            if (session.destroyed || session.closed) return;
                            if (isFree() && !$f27a9ba7f5496a52$var$closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
                                $f27a9ba7f5496a52$var$closeCoveredSessions(this.sessions[normalizedOptions], session);
                                processListeners();
                                if (session[$f27a9ba7f5496a52$var$kCurrentStreamCount] === 0) this._processQueue();
                            }
                        });
                        return stream;
                    };
                } catch (error) {
                    removeFromQueue();
                    this._sessionCount--;
                    for(let index = 0; index < listeners.length; index++)listeners[index].reject(error);
                }
            };
            entry.listeners = listeners;
            entry.completed = false;
            entry.destroyed = false;
            this.queue[normalizedOptions][normalizedOrigin] = entry;
            this.queue[normalizedOptions][$f27a9ba7f5496a52$var$kLength]++;
            this._processQueue();
        });
    }
    request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject)=>{
            this.getSession(origin, options, [
                {
                    reject: reject,
                    resolve: (session)=>{
                        try {
                            const stream = session.request(headers, streamOptions);
                            // Do not throw before `request(...)` has been awaited
                            $a74a06cdc7c0a760$exports(stream);
                            resolve(stream);
                        } catch (error) {
                            reject(error);
                        }
                    }
                }
            ]);
        });
    }
    async createConnection(origin, options) {
        return $f27a9ba7f5496a52$var$Agent.connect(origin, options);
    }
    static connect(origin, options) {
        options.ALPNProtocols = [
            "h2"
        ];
        const port = origin.port || 443;
        const host = origin.hostname;
        if (typeof options.servername === "undefined") options.servername = host;
        const socket = $dAk3n$tls.connect(port, host, options);
        if (options.socket) socket._peername = {
            family: undefined,
            address: undefined,
            port: port
        };
        return socket;
    }
    closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
        let closedCount = 0;
        const { sessions: sessions } = this;
        // eslint-disable-next-line guard-for-in
        for(const key in sessions){
            const thisSessions = sessions[key];
            for(let index = 0; index < thisSessions.length; index++){
                const session = thisSessions[index];
                if (session[$f27a9ba7f5496a52$var$kCurrentStreamCount] === 0) {
                    closedCount++;
                    session.close();
                    if (closedCount >= maxCount) return closedCount;
                }
            }
        }
        return closedCount;
    }
    destroy(reason) {
        const { sessions: sessions, queue: queue } = this;
        // eslint-disable-next-line guard-for-in
        for(const key in sessions){
            const thisSessions = sessions[key];
            for(let index = 0; index < thisSessions.length; index++)thisSessions[index].destroy(reason);
        }
        // eslint-disable-next-line guard-for-in
        for(const normalizedOptions in queue){
            const entries = queue[normalizedOptions];
            // eslint-disable-next-line guard-for-in
            for(const normalizedOrigin in entries)entries[normalizedOrigin].destroyed = true;
        }
        // New requests should NOT attach to destroyed sessions
        this.queue = {};
        this.tlsSessionCache.clear();
    }
    get emptySessionCount() {
        return this._emptySessionCount;
    }
    get pendingSessionCount() {
        return this._sessionCount - this._emptySessionCount;
    }
    get sessionCount() {
        return this._sessionCount;
    }
}
$f27a9ba7f5496a52$var$Agent.kCurrentStreamCount = $f27a9ba7f5496a52$var$kCurrentStreamCount;
$f27a9ba7f5496a52$var$Agent.kGracefullyClosing = $f27a9ba7f5496a52$var$kGracefullyClosing;
$f27a9ba7f5496a52$exports = {
    Agent: $f27a9ba7f5496a52$var$Agent,
    globalAgent: new $f27a9ba7f5496a52$var$Agent()
};


var $2a024f368552c192$require$Agent = $f27a9ba7f5496a52$exports.Agent;
var $2a024f368552c192$require$globalAgent = $f27a9ba7f5496a52$exports.globalAgent;
var $1395c2d3cfe2b43f$exports = {};
"use strict";

var $1395c2d3cfe2b43f$require$URL = $dAk3n$url.URL;
var $1395c2d3cfe2b43f$require$urlToHttpOptions = $dAk3n$url.urlToHttpOptions;


var $1395c2d3cfe2b43f$require$Writable = $dAk3n$stream.Writable;

var $1395c2d3cfe2b43f$require$Agent = $f27a9ba7f5496a52$exports.Agent;
var $1395c2d3cfe2b43f$require$globalAgent = $f27a9ba7f5496a52$exports.globalAgent;
var $03986b38485bbd9f$exports = {};
"use strict";

var $03986b38485bbd9f$require$Readable = $dAk3n$stream.Readable;
class $03986b38485bbd9f$var$IncomingMessage extends $03986b38485bbd9f$require$Readable {
    constructor(socket, highWaterMark){
        super({
            emitClose: false,
            autoDestroy: true,
            highWaterMark: highWaterMark
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this._dumped = false;
    }
    get connection() {
        return this.socket;
    }
    set connection(value) {
        this.socket = value;
    }
    _destroy(error, callback) {
        if (!this.readableEnded) this.aborted = true;
        // See https://github.com/nodejs/node/issues/35303
        callback();
        this.req._request.destroy(error);
    }
    setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
    }
    _dump() {
        if (!this._dumped) {
            this._dumped = true;
            this.removeAllListeners("data");
            this.resume();
        }
    }
    _read() {
        if (this.req) this.req._request.resume();
    }
}
$03986b38485bbd9f$exports = $03986b38485bbd9f$var$IncomingMessage;


var $e6cdd184952b64ef$exports = {};
"use strict";
$e6cdd184952b64ef$exports = (from, to, events)=>{
    for (const event of events)from.on(event, (...args)=>to.emit(event, ...args));
};


var $cc524128a9118346$exports = {};
"use strict";
/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */ const $cc524128a9118346$var$makeError = (Base, key, getMessage)=>{
    $cc524128a9118346$exports[key] = class NodeError extends Base {
        constructor(...args){
            super(typeof getMessage === "string" ? getMessage : getMessage(args));
            this.name = `${super.name} [${key}]`;
            this.code = key;
        }
    };
};
$cc524128a9118346$var$makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args)=>{
    const type = args[0].includes(".") ? "property" : "argument";
    let valid = args[1];
    const isManyTypes = Array.isArray(valid);
    if (isManyTypes) valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
    return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
});
$cc524128a9118346$var$makeError(TypeError, "ERR_INVALID_PROTOCOL", (args)=>`Protocol "${args[0]}" not supported. Expected "${args[1]}"`);
$cc524128a9118346$var$makeError(Error, "ERR_HTTP_HEADERS_SENT", (args)=>`Cannot ${args[0]} headers after they are sent to the client`);
$cc524128a9118346$var$makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args)=>`${args[0]} must be a valid HTTP token [${args[1]}]`);
$cc524128a9118346$var$makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args)=>`Invalid value "${args[0]} for header "${args[1]}"`);
$cc524128a9118346$var$makeError(TypeError, "ERR_INVALID_CHAR", (args)=>`Invalid character in ${args[0]} [${args[1]}]`);
$cc524128a9118346$var$makeError(Error, "ERR_HTTP2_NO_SOCKET_MANIPULATION", "HTTP/2 sockets should not be directly manipulated (e.g. read and written)");


var $1395c2d3cfe2b43f$require$ERR_INVALID_ARG_TYPE = $cc524128a9118346$exports.ERR_INVALID_ARG_TYPE;
var $1395c2d3cfe2b43f$require$ERR_INVALID_PROTOCOL = $cc524128a9118346$exports.ERR_INVALID_PROTOCOL;
var $1395c2d3cfe2b43f$require$ERR_HTTP_HEADERS_SENT = $cc524128a9118346$exports.ERR_HTTP_HEADERS_SENT;
var $12951c7d748a7be1$exports = {};
"use strict";

var $12951c7d748a7be1$require$ERR_INVALID_HTTP_TOKEN = $cc524128a9118346$exports.ERR_INVALID_HTTP_TOKEN;
var $0f1cd27867b13a33$exports = {};
"use strict";
$0f1cd27867b13a33$exports = (header)=>{
    switch(header){
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
            return true;
        default:
            return false;
    }
};


const $12951c7d748a7be1$var$isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
$12951c7d748a7be1$exports = (name)=>{
    if (typeof name !== "string" || !$12951c7d748a7be1$var$isValidHttpToken.test(name) && !$0f1cd27867b13a33$exports(name)) throw new $12951c7d748a7be1$require$ERR_INVALID_HTTP_TOKEN("Header name", name);
};


var $20773763b613875d$exports = {};
"use strict";

var $20773763b613875d$require$ERR_HTTP_INVALID_HEADER_VALUE = $cc524128a9118346$exports.ERR_HTTP_INVALID_HEADER_VALUE;
var $20773763b613875d$require$ERR_INVALID_CHAR = $cc524128a9118346$exports.ERR_INVALID_CHAR;
const $20773763b613875d$var$isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
$20773763b613875d$exports = (name, value)=>{
    if (typeof value === "undefined") throw new $20773763b613875d$require$ERR_HTTP_INVALID_HEADER_VALUE(value, name);
    if ($20773763b613875d$var$isInvalidHeaderValue.test(value)) throw new $20773763b613875d$require$ERR_INVALID_CHAR("header content", name);
};


var $6b61e9f6e2c4f83b$exports = {};
"use strict";

var $6b61e9f6e2c4f83b$require$ERR_HTTP2_NO_SOCKET_MANIPULATION = $cc524128a9118346$exports.ERR_HTTP2_NO_SOCKET_MANIPULATION;
/* istanbul ignore file */ /* https://github.com/nodejs/node/blob/6eec858f34a40ffa489c1ec54bb24da72a28c781/lib/internal/http2/compat.js#L195-L272 */ const $6b61e9f6e2c4f83b$var$proxySocketHandler = {
    has (stream, property) {
        // Replaced [kSocket] with .socket
        const reference = stream.session === undefined ? stream : stream.session.socket;
        return property in stream || property in reference;
    },
    get (stream, property) {
        switch(property){
            case "on":
            case "once":
            case "end":
            case "emit":
            case "destroy":
                return stream[property].bind(stream);
            case "writable":
            case "destroyed":
                return stream[property];
            case "readable":
                if (stream.destroyed) return false;
                return stream.readable;
            case "setTimeout":
                {
                    const { session: session } = stream;
                    if (session !== undefined) return session.setTimeout.bind(session);
                    return stream.setTimeout.bind(stream);
                }
            case "write":
            case "read":
            case "pause":
            case "resume":
                throw new $6b61e9f6e2c4f83b$require$ERR_HTTP2_NO_SOCKET_MANIPULATION();
            default:
                {
                    // Replaced [kSocket] with .socket
                    const reference = stream.session === undefined ? stream : stream.session.socket;
                    const value = reference[property];
                    return typeof value === "function" ? value.bind(reference) : value;
                }
        }
    },
    getPrototypeOf (stream) {
        if (stream.session !== undefined) // Replaced [kSocket] with .socket
        return Reflect.getPrototypeOf(stream.session.socket);
        return Reflect.getPrototypeOf(stream);
    },
    set (stream, property, value) {
        switch(property){
            case "writable":
            case "readable":
            case "destroyed":
            case "on":
            case "once":
            case "end":
            case "emit":
            case "destroy":
                stream[property] = value;
                return true;
            case "setTimeout":
                {
                    const { session: session } = stream;
                    if (session === undefined) stream.setTimeout = value;
                    else session.setTimeout = value;
                    return true;
                }
            case "write":
            case "read":
            case "pause":
            case "resume":
                throw new $6b61e9f6e2c4f83b$require$ERR_HTTP2_NO_SOCKET_MANIPULATION();
            default:
                {
                    // Replaced [kSocket] with .socket
                    const reference = stream.session === undefined ? stream : stream.session.socket;
                    reference[property] = value;
                    return true;
                }
        }
    }
};
$6b61e9f6e2c4f83b$exports = $6b61e9f6e2c4f83b$var$proxySocketHandler;


const { HTTP2_HEADER_STATUS: $1395c2d3cfe2b43f$var$HTTP2_HEADER_STATUS, HTTP2_HEADER_METHOD: $1395c2d3cfe2b43f$var$HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH: $1395c2d3cfe2b43f$var$HTTP2_HEADER_PATH, HTTP2_HEADER_AUTHORITY: $1395c2d3cfe2b43f$var$HTTP2_HEADER_AUTHORITY, HTTP2_METHOD_CONNECT: $1395c2d3cfe2b43f$var$HTTP2_METHOD_CONNECT } = $dAk3n$http2.constants;
const $1395c2d3cfe2b43f$var$kHeaders = Symbol("headers");
const $1395c2d3cfe2b43f$var$kOrigin = Symbol("origin");
const $1395c2d3cfe2b43f$var$kSession = Symbol("session");
const $1395c2d3cfe2b43f$var$kOptions = Symbol("options");
const $1395c2d3cfe2b43f$var$kFlushedHeaders = Symbol("flushedHeaders");
const $1395c2d3cfe2b43f$var$kJobs = Symbol("jobs");
const $1395c2d3cfe2b43f$var$kPendingAgentPromise = Symbol("pendingAgentPromise");
class $1395c2d3cfe2b43f$var$ClientRequest extends $1395c2d3cfe2b43f$require$Writable {
    constructor(input, options, callback){
        super({
            autoDestroy: false,
            emitClose: false
        });
        if (typeof input === "string") input = $1395c2d3cfe2b43f$require$urlToHttpOptions(new $1395c2d3cfe2b43f$require$URL(input));
        else if (input instanceof $1395c2d3cfe2b43f$require$URL) input = $1395c2d3cfe2b43f$require$urlToHttpOptions(input);
        else input = {
            ...input
        };
        if (typeof options === "function" || options === undefined) {
            // (options, callback)
            callback = options;
            options = input;
        } else // (input, options, callback)
        options = Object.assign(input, options);
        if (options.h2session) {
            this[$1395c2d3cfe2b43f$var$kSession] = options.h2session;
            if (this[$1395c2d3cfe2b43f$var$kSession].destroyed) throw new Error("The session has been closed already");
            this.protocol = this[$1395c2d3cfe2b43f$var$kSession].socket.encrypted ? "https:" : "http:";
        } else if (options.agent === false) this.agent = new $1395c2d3cfe2b43f$require$Agent({
            maxEmptySessions: 0
        });
        else if (typeof options.agent === "undefined" || options.agent === null) this.agent = $1395c2d3cfe2b43f$require$globalAgent;
        else if (typeof options.agent.request === "function") this.agent = options.agent;
        else throw new $1395c2d3cfe2b43f$require$ERR_INVALID_ARG_TYPE("options.agent", [
            "http2wrapper.Agent-like Object",
            "undefined",
            "false"
        ], options.agent);
        if (this.agent) this.protocol = this.agent.protocol;
        if (options.protocol && options.protocol !== this.protocol) throw new $1395c2d3cfe2b43f$require$ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
        if (!options.port) options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;
        options.host = options.hostname || options.host || "localhost";
        // Unused
        delete options.hostname;
        const { timeout: timeout } = options;
        options.timeout = undefined;
        this[$1395c2d3cfe2b43f$var$kHeaders] = Object.create(null);
        this[$1395c2d3cfe2b43f$var$kJobs] = [];
        this[$1395c2d3cfe2b43f$var$kPendingAgentPromise] = undefined;
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        if (!(this.method === "CONNECT" && (options.path === "/" || options.path === undefined))) this.path = options.path;
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        const { headers: headers } = options;
        if (headers) // eslint-disable-next-line guard-for-in
        for(const header in headers)this.setHeader(header, headers[header]);
        if (options.auth && !("authorization" in this[$1395c2d3cfe2b43f$var$kHeaders])) this[$1395c2d3cfe2b43f$var$kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[$1395c2d3cfe2b43f$var$kOptions] = options;
        // Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
        this[$1395c2d3cfe2b43f$var$kOrigin] = new $1395c2d3cfe2b43f$require$URL(`${this.protocol}//${options.servername || options.host}:${options.port}`);
        // A socket is being reused
        const reuseSocket = options._reuseSocket;
        if (reuseSocket) {
            options.createConnection = (...args)=>{
                if (reuseSocket.destroyed) return this.agent.createConnection(...args);
                return reuseSocket;
            };
            // eslint-disable-next-line promise/prefer-await-to-then
            this.agent.getSession(this[$1395c2d3cfe2b43f$var$kOrigin], this[$1395c2d3cfe2b43f$var$kOptions]).catch(()=>{});
        }
        if (timeout) this.setTimeout(timeout);
        if (callback) this.once("response", callback);
        this[$1395c2d3cfe2b43f$var$kFlushedHeaders] = false;
    }
    get method() {
        return this[$1395c2d3cfe2b43f$var$kHeaders][$1395c2d3cfe2b43f$var$HTTP2_HEADER_METHOD];
    }
    set method(value) {
        if (value) this[$1395c2d3cfe2b43f$var$kHeaders][$1395c2d3cfe2b43f$var$HTTP2_HEADER_METHOD] = value.toUpperCase();
    }
    get path() {
        const header = this.method === "CONNECT" ? $1395c2d3cfe2b43f$var$HTTP2_HEADER_AUTHORITY : $1395c2d3cfe2b43f$var$HTTP2_HEADER_PATH;
        return this[$1395c2d3cfe2b43f$var$kHeaders][header];
    }
    set path(value) {
        if (value) {
            const header = this.method === "CONNECT" ? $1395c2d3cfe2b43f$var$HTTP2_HEADER_AUTHORITY : $1395c2d3cfe2b43f$var$HTTP2_HEADER_PATH;
            this[$1395c2d3cfe2b43f$var$kHeaders][header] = value;
        }
    }
    get host() {
        return this[$1395c2d3cfe2b43f$var$kOrigin].hostname;
    }
    set host(_value) {
    // Do nothing as this is read only.
    }
    get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
    }
    _write(chunk, encoding, callback) {
        // https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
        if (this._mustNotHaveABody) {
            callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
            /* istanbul ignore next: Node.js 12 throws directly */ return;
        }
        this.flushHeaders();
        const callWrite = ()=>this._request.write(chunk, encoding, callback);
        if (this._request) callWrite();
        else this[$1395c2d3cfe2b43f$var$kJobs].push(callWrite);
    }
    _final(callback) {
        this.flushHeaders();
        const callEnd = ()=>{
            // For GET, HEAD and DELETE and CONNECT
            if (this._mustNotHaveABody || this.method === "CONNECT") {
                callback();
                return;
            }
            this._request.end(callback);
        };
        if (this._request) callEnd();
        else this[$1395c2d3cfe2b43f$var$kJobs].push(callEnd);
    }
    abort() {
        if (this.res && this.res.complete) return;
        if (!this.aborted) process.nextTick(()=>this.emit("abort"));
        this.aborted = true;
        this.destroy();
    }
    async _destroy(error, callback) {
        if (this.res) this.res._dump();
        if (this._request) this._request.destroy();
        else process.nextTick(()=>{
            this.emit("close");
        });
        try {
            await this[$1395c2d3cfe2b43f$var$kPendingAgentPromise];
        } catch (internalError) {
            if (this.aborted) error = internalError;
        }
        callback(error);
    }
    async flushHeaders() {
        if (this[$1395c2d3cfe2b43f$var$kFlushedHeaders] || this.destroyed) return;
        this[$1395c2d3cfe2b43f$var$kFlushedHeaders] = true;
        const isConnectMethod = this.method === $1395c2d3cfe2b43f$var$HTTP2_METHOD_CONNECT;
        // The real magic is here
        const onStream = (stream)=>{
            this._request = stream;
            if (this.destroyed) {
                stream.destroy();
                return;
            }
            // Forwards `timeout`, `continue`, `close` and `error` events to this instance.
            if (!isConnectMethod) // TODO: Should we proxy `close` here?
            $e6cdd184952b64ef$exports(stream, this, [
                "timeout",
                "continue"
            ]);
            stream.once("error", (error)=>{
                this.destroy(error);
            });
            stream.once("aborted", ()=>{
                const { res: res } = this;
                if (res) {
                    res.aborted = true;
                    res.emit("aborted");
                    res.destroy();
                } else this.destroy(new Error("The server aborted the HTTP/2 stream"));
            });
            const onResponse = (headers, flags, rawHeaders)=>{
                // If we were to emit raw request stream, it would be as fast as the native approach.
                // Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
                const response = new $03986b38485bbd9f$exports(this.socket, stream.readableHighWaterMark);
                this.res = response;
                // Undocumented, but it is used by `cacheable-request`
                response.url = `${this[$1395c2d3cfe2b43f$var$kOrigin].origin}${this.path}`;
                response.req = this;
                response.statusCode = headers[$1395c2d3cfe2b43f$var$HTTP2_HEADER_STATUS];
                response.headers = headers;
                response.rawHeaders = rawHeaders;
                response.once("end", ()=>{
                    response.complete = true;
                    // Has no effect, just be consistent with the Node.js behavior
                    response.socket = null;
                    response.connection = null;
                });
                if (isConnectMethod) {
                    response.upgrade = true;
                    // The HTTP1 API says the socket is detached here,
                    // but we can't do that so we pass the original HTTP2 request.
                    if (this.emit("connect", response, stream, Buffer.alloc(0))) this.emit("close");
                    else // No listeners attached, destroy the original request.
                    stream.destroy();
                } else {
                    // Forwards data
                    stream.on("data", (chunk)=>{
                        if (!response._dumped && !response.push(chunk)) stream.pause();
                    });
                    stream.once("end", ()=>{
                        if (!this.aborted) response.push(null);
                    });
                    if (!this.emit("response", response)) // No listeners attached, dump the response.
                    response._dump();
                }
            };
            // This event tells we are ready to listen for the data.
            stream.once("response", onResponse);
            // Emits `information` event
            stream.once("headers", (headers)=>this.emit("information", {
                    statusCode: headers[$1395c2d3cfe2b43f$var$HTTP2_HEADER_STATUS]
                }));
            stream.once("trailers", (trailers, flags, rawTrailers)=>{
                const { res: res } = this;
                // https://github.com/nodejs/node/issues/41251
                if (res === null) {
                    onResponse(trailers, flags, rawTrailers);
                    return;
                }
                // Assigns trailers to the response object.
                res.trailers = trailers;
                res.rawTrailers = rawTrailers;
            });
            stream.once("close", ()=>{
                const { aborted: aborted, res: res } = this;
                if (res) {
                    if (aborted) {
                        res.aborted = true;
                        res.emit("aborted");
                        res.destroy();
                    }
                    const finish = ()=>{
                        res.emit("close");
                        this.destroy();
                        this.emit("close");
                    };
                    if (res.readable) res.once("end", finish);
                    else finish();
                    return;
                }
                if (!this.destroyed) {
                    this.destroy(new Error("The HTTP/2 stream has been early terminated"));
                    this.emit("close");
                    return;
                }
                this.destroy();
                this.emit("close");
            });
            this.socket = new Proxy(stream, $6b61e9f6e2c4f83b$exports);
            for (const job of this[$1395c2d3cfe2b43f$var$kJobs])job();
            this[$1395c2d3cfe2b43f$var$kJobs].length = 0;
            this.emit("socket", this.socket);
        };
        if (!($1395c2d3cfe2b43f$var$HTTP2_HEADER_AUTHORITY in this[$1395c2d3cfe2b43f$var$kHeaders]) && !isConnectMethod) this[$1395c2d3cfe2b43f$var$kHeaders][$1395c2d3cfe2b43f$var$HTTP2_HEADER_AUTHORITY] = this[$1395c2d3cfe2b43f$var$kOrigin].host;
        // Makes a HTTP2 request
        if (this[$1395c2d3cfe2b43f$var$kSession]) try {
            onStream(this[$1395c2d3cfe2b43f$var$kSession].request(this[$1395c2d3cfe2b43f$var$kHeaders]));
        } catch (error) {
            this.destroy(error);
        }
        else {
            this.reusedSocket = true;
            try {
                const promise = this.agent.request(this[$1395c2d3cfe2b43f$var$kOrigin], this[$1395c2d3cfe2b43f$var$kOptions], this[$1395c2d3cfe2b43f$var$kHeaders]);
                this[$1395c2d3cfe2b43f$var$kPendingAgentPromise] = promise;
                onStream(await promise);
                this[$1395c2d3cfe2b43f$var$kPendingAgentPromise] = false;
            } catch (error) {
                this[$1395c2d3cfe2b43f$var$kPendingAgentPromise] = false;
                this.destroy(error);
            }
        }
    }
    get connection() {
        return this.socket;
    }
    set connection(value) {
        this.socket = value;
    }
    getHeaderNames() {
        return Object.keys(this[$1395c2d3cfe2b43f$var$kHeaders]);
    }
    hasHeader(name) {
        if (typeof name !== "string") throw new $1395c2d3cfe2b43f$require$ERR_INVALID_ARG_TYPE("name", "string", name);
        return Boolean(this[$1395c2d3cfe2b43f$var$kHeaders][name.toLowerCase()]);
    }
    getHeader(name) {
        if (typeof name !== "string") throw new $1395c2d3cfe2b43f$require$ERR_INVALID_ARG_TYPE("name", "string", name);
        return this[$1395c2d3cfe2b43f$var$kHeaders][name.toLowerCase()];
    }
    get headersSent() {
        return this[$1395c2d3cfe2b43f$var$kFlushedHeaders];
    }
    removeHeader(name) {
        if (typeof name !== "string") throw new $1395c2d3cfe2b43f$require$ERR_INVALID_ARG_TYPE("name", "string", name);
        if (this.headersSent) throw new $1395c2d3cfe2b43f$require$ERR_HTTP_HEADERS_SENT("remove");
        delete this[$1395c2d3cfe2b43f$var$kHeaders][name.toLowerCase()];
    }
    setHeader(name, value) {
        if (this.headersSent) throw new $1395c2d3cfe2b43f$require$ERR_HTTP_HEADERS_SENT("set");
        $12951c7d748a7be1$exports(name);
        $20773763b613875d$exports(name, value);
        const lowercased = name.toLowerCase();
        if (lowercased === "connection") {
            if (value.toLowerCase() === "keep-alive") return;
            throw new Error(`Invalid 'connection' header: ${value}`);
        }
        if (lowercased === "host" && this.method === "CONNECT") this[$1395c2d3cfe2b43f$var$kHeaders][$1395c2d3cfe2b43f$var$HTTP2_HEADER_AUTHORITY] = value;
        else this[$1395c2d3cfe2b43f$var$kHeaders][lowercased] = value;
    }
    setNoDelay() {
    // HTTP2 sockets cannot be malformed, do nothing.
    }
    setSocketKeepAlive() {
    // HTTP2 sockets cannot be malformed, do nothing.
    }
    setTimeout(ms, callback) {
        const applyTimeout = ()=>this._request.setTimeout(ms, callback);
        if (this._request) applyTimeout();
        else this[$1395c2d3cfe2b43f$var$kJobs].push(applyTimeout);
        return this;
    }
    get maxHeadersCount() {
        if (!this.destroyed && this._request) return this._request.session.localSettings.maxHeaderListSize;
        return undefined;
    }
    set maxHeadersCount(_value) {
    // Updating HTTP2 settings would affect all requests, do nothing.
    }
}
$1395c2d3cfe2b43f$exports = $1395c2d3cfe2b43f$var$ClientRequest;



var $20f44ebf9f76ef32$exports = {};
"use strict";

var $20f44ebf9f76ef32$require$URL = $dAk3n$url.URL;
var $20f44ebf9f76ef32$require$urlToHttpOptions = $dAk3n$url.urlToHttpOptions;


var $e4ada7a984d3bdb0$exports = {};
"use strict";

$e4ada7a984d3bdb0$exports = (options = {}, connect = $dAk3n$tls.connect)=>new Promise((resolve, reject)=>{
        let timeout = false;
        let socket;
        const callback = async ()=>{
            await socketPromise;
            socket.off("timeout", onTimeout);
            socket.off("error", reject);
            if (options.resolveSocket) {
                resolve({
                    alpnProtocol: socket.alpnProtocol,
                    socket: socket,
                    timeout: timeout
                });
                if (timeout) {
                    await Promise.resolve();
                    socket.emit("timeout");
                }
            } else {
                socket.destroy();
                resolve({
                    alpnProtocol: socket.alpnProtocol,
                    timeout: timeout
                });
            }
        };
        const onTimeout = async ()=>{
            timeout = true;
            callback();
        };
        const socketPromise = (async ()=>{
            try {
                socket = await connect(options, callback);
                socket.on("error", reject);
                socket.once("timeout", onTimeout);
            } catch (error) {
                reject(error);
            }
        })();
    });




var $20f44ebf9f76ef32$require$Agent = $f27a9ba7f5496a52$exports.Agent;
var $20f44ebf9f76ef32$require$globalAgent = $f27a9ba7f5496a52$exports.globalAgent;

var $9de0712fc1b5524a$exports = {};
"use strict";

var $9de0712fc1b5524a$require$isIP = $dAk3n$net.isIP;

const $9de0712fc1b5524a$var$getHost = (host)=>{
    if (host[0] === "[") {
        const idx = host.indexOf("]");
        $dAk3n$assert(idx !== -1);
        return host.slice(1, idx);
    }
    const idx = host.indexOf(":");
    if (idx === -1) return host;
    return host.slice(0, idx);
};
$9de0712fc1b5524a$exports = (host)=>{
    const servername = $9de0712fc1b5524a$var$getHost(host);
    if ($9de0712fc1b5524a$require$isIP(servername)) return "";
    return servername;
};



const $20f44ebf9f76ef32$var$cache = new $40a8e476d2ca8d4c$exports({
    maxSize: 100
});
const $20f44ebf9f76ef32$var$queue = new Map();
const $20f44ebf9f76ef32$var$installSocket = (agent, socket, options)=>{
    socket._httpMessage = {
        shouldKeepAlive: true
    };
    const onFree = ()=>{
        agent.emit("free", socket, options);
    };
    socket.on("free", onFree);
    const onClose = ()=>{
        agent.removeSocket(socket, options);
    };
    socket.on("close", onClose);
    const onTimeout = ()=>{
        const { freeSockets: freeSockets } = agent;
        for (const sockets of Object.values(freeSockets))if (sockets.includes(socket)) {
            socket.destroy();
            return;
        }
    };
    socket.on("timeout", onTimeout);
    const onRemove = ()=>{
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("timeout", onTimeout);
        socket.off("agentRemove", onRemove);
    };
    socket.on("agentRemove", onRemove);
    agent.emit("free", socket, options);
};
const $20f44ebf9f76ef32$var$createResolveProtocol = (cache, queue = new Map(), connect)=>{
    return async (options)=>{
        const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
        if (!cache.has(name)) {
            if (queue.has(name)) {
                const result = await queue.get(name);
                return {
                    alpnProtocol: result.alpnProtocol
                };
            }
            const { path: path } = options;
            options.path = options.socketPath;
            const resultPromise = $e4ada7a984d3bdb0$exports(options, connect);
            queue.set(name, resultPromise);
            try {
                const result = await resultPromise;
                cache.set(name, result.alpnProtocol);
                queue.delete(name);
                options.path = path;
                return result;
            } catch (error) {
                queue.delete(name);
                options.path = path;
                throw error;
            }
        }
        return {
            alpnProtocol: cache.get(name)
        };
    };
};
const $20f44ebf9f76ef32$var$defaultResolveProtocol = $20f44ebf9f76ef32$var$createResolveProtocol($20f44ebf9f76ef32$var$cache, $20f44ebf9f76ef32$var$queue);
$20f44ebf9f76ef32$exports = async (input, options, callback)=>{
    if (typeof input === "string") input = $20f44ebf9f76ef32$require$urlToHttpOptions(new $20f44ebf9f76ef32$require$URL(input));
    else if (input instanceof $20f44ebf9f76ef32$require$URL) input = $20f44ebf9f76ef32$require$urlToHttpOptions(input);
    else input = {
        ...input
    };
    if (typeof options === "function" || options === undefined) {
        // (options, callback)
        callback = options;
        options = input;
    } else // (input, options, callback)
    options = Object.assign(input, options);
    options.ALPNProtocols = options.ALPNProtocols || [
        "h2",
        "http/1.1"
    ];
    if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
    options.protocol = options.protocol || "https:";
    const isHttps = options.protocol === "https:";
    options.host = options.hostname || options.host || "localhost";
    options.session = options.tlsSession;
    options.servername = options.servername || $9de0712fc1b5524a$exports(options.headers && options.headers.host || options.host);
    options.port = options.port || (isHttps ? 443 : 80);
    options._defaultAgent = isHttps ? $dAk3n$https.globalAgent : $dAk3n$http.globalAgent;
    const resolveProtocol = options.resolveProtocol || $20f44ebf9f76ef32$var$defaultResolveProtocol;
    // Note: We don't support `h2session` here
    let { agent: agent } = options;
    if (agent !== undefined && agent !== false && agent.constructor.name !== "Object") throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
    if (isHttps) {
        options.resolveSocket = true;
        let { socket: socket, alpnProtocol: alpnProtocol, timeout: timeout } = await resolveProtocol(options);
        if (timeout) {
            if (socket) socket.destroy();
            const error = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
            error.code = "ETIMEDOUT";
            error.ms = options.timeout;
            throw error;
        }
        // We can't accept custom `createConnection` because the API is different for HTTP/2
        if (socket && options.createConnection) {
            socket.destroy();
            socket = undefined;
        }
        delete options.resolveSocket;
        const isHttp2 = alpnProtocol === "h2";
        if (agent) {
            agent = isHttp2 ? agent.http2 : agent.https;
            options.agent = agent;
        }
        if (agent === undefined) agent = isHttp2 ? $20f44ebf9f76ef32$require$globalAgent : $dAk3n$https.globalAgent;
        if (socket) {
            if (agent === false) socket.destroy();
            else {
                const defaultCreateConnection = (isHttp2 ? $20f44ebf9f76ef32$require$Agent : $dAk3n$https.Agent).prototype.createConnection;
                if (agent.createConnection === defaultCreateConnection) {
                    if (isHttp2) options._reuseSocket = socket;
                    else $20f44ebf9f76ef32$var$installSocket(agent, socket, options);
                } else socket.destroy();
            }
        }
        if (isHttp2) return $a74a06cdc7c0a760$exports(new $1395c2d3cfe2b43f$exports(options, callback));
    } else if (agent) options.agent = agent.http;
    return $a74a06cdc7c0a760$exports($dAk3n$http.request(options, callback));
};
$20f44ebf9f76ef32$exports.protocolCache = $20f44ebf9f76ef32$var$cache;
$20f44ebf9f76ef32$exports.resolveProtocol = $20f44ebf9f76ef32$var$defaultResolveProtocol;
$20f44ebf9f76ef32$exports.createResolveProtocol = $20f44ebf9f76ef32$var$createResolveProtocol;


var $6c37620d081be1c4$exports = {};
"use strict";



var $7430fc304029ebac$exports = {};
"use strict";


// Really awesome hack.
const $7430fc304029ebac$var$JSStreamSocket = new $dAk3n$tls.TLSSocket(new $dAk3n$stream.PassThrough())._handle._parentWrap.constructor;
$7430fc304029ebac$exports = $7430fc304029ebac$var$JSStreamSocket;



var $6c37620d081be1c4$require$globalAgent = $f27a9ba7f5496a52$exports.globalAgent;
var $49bd8099d99c0afc$exports = {};
"use strict";
class $49bd8099d99c0afc$var$UnexpectedStatusCodeError extends Error {
    constructor(statusCode, statusMessage = ""){
        super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || "empty status message"})`);
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
    }
}
$49bd8099d99c0afc$exports = $49bd8099d99c0afc$var$UnexpectedStatusCodeError;


var $ce3cfb104b1e1ca3$exports = {};
"use strict";

var $ce3cfb104b1e1ca3$require$URL = $dAk3n$url.URL;
var $14d01b10f5e7a7d9$exports = {};
"use strict";
const $14d01b10f5e7a7d9$var$checkType = (name, value, types)=>{
    const valid = types.some((type)=>{
        const typeofType = typeof type;
        if (typeofType === "string") return typeof value === type;
        return value instanceof type;
    });
    if (!valid) {
        const names = types.map((type)=>typeof type === "string" ? type : type.name);
        throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
    }
};
$14d01b10f5e7a7d9$exports = $14d01b10f5e7a7d9$var$checkType;


$ce3cfb104b1e1ca3$exports = (self, proxyOptions)=>{
    $14d01b10f5e7a7d9$exports("proxyOptions", proxyOptions, [
        "object"
    ]);
    $14d01b10f5e7a7d9$exports("proxyOptions.headers", proxyOptions.headers, [
        "object",
        "undefined"
    ]);
    $14d01b10f5e7a7d9$exports("proxyOptions.raw", proxyOptions.raw, [
        "boolean",
        "undefined"
    ]);
    $14d01b10f5e7a7d9$exports("proxyOptions.url", proxyOptions.url, [
        $ce3cfb104b1e1ca3$require$URL,
        "string"
    ]);
    const url = new $ce3cfb104b1e1ca3$require$URL(proxyOptions.url);
    self.proxyOptions = {
        raw: true,
        ...proxyOptions,
        headers: {
            ...proxyOptions.headers
        },
        url: url
    };
};


var $b0f55557acd887ca$exports = {};
"use strict";
$b0f55557acd887ca$exports = (self)=>{
    const { username: username, password: password } = self.proxyOptions.url;
    if (username || password) {
        const data = `${username}:${password}`;
        const authorization = `Basic ${Buffer.from(data).toString("base64")}`;
        return {
            "proxy-authorization": authorization,
            authorization: authorization
        };
    }
    return {};
};


const $6c37620d081be1c4$var$createConnection = (self, options, callback)=>{
    (async ()=>{
        try {
            const { proxyOptions: proxyOptions } = self;
            const { url: url, headers: headers, raw: raw } = proxyOptions;
            const stream = await $6c37620d081be1c4$require$globalAgent.request(url, proxyOptions, {
                ...$b0f55557acd887ca$exports(self),
                ...headers,
                ":method": "CONNECT",
                ":authority": `${options.host}:${options.port}`
            });
            stream.once("error", callback);
            stream.once("response", (headers)=>{
                const statusCode = headers[":status"];
                if (statusCode !== 200) {
                    callback(new $49bd8099d99c0afc$exports(statusCode, ""));
                    return;
                }
                const encrypted = self instanceof $dAk3n$https.Agent;
                if (raw && encrypted) {
                    options.socket = stream;
                    const secureStream = $dAk3n$tls.connect(options);
                    secureStream.once("close", ()=>{
                        stream.destroy();
                    });
                    callback(null, secureStream);
                    return;
                }
                const socket = new $7430fc304029ebac$exports(stream);
                socket.encrypted = false;
                socket._handle.getpeername = (out)=>{
                    out.family = undefined;
                    out.address = undefined;
                    out.port = undefined;
                };
                callback(null, socket);
            });
        } catch (error) {
            callback(error);
        }
    })();
};
class $6c37620d081be1c4$var$HttpOverHttp2 extends $dAk3n$http.Agent {
    constructor(options){
        super(options);
        $ce3cfb104b1e1ca3$exports(this, options.proxyOptions);
    }
    createConnection(options, callback) {
        $6c37620d081be1c4$var$createConnection(this, options, callback);
    }
}
class $6c37620d081be1c4$var$HttpsOverHttp2 extends $dAk3n$https.Agent {
    constructor(options){
        super(options);
        $ce3cfb104b1e1ca3$exports(this, options.proxyOptions);
    }
    createConnection(options, callback) {
        $6c37620d081be1c4$var$createConnection(this, options, callback);
    }
}
$6c37620d081be1c4$exports = {
    HttpOverHttp2: $6c37620d081be1c4$var$HttpOverHttp2,
    HttpsOverHttp2: $6c37620d081be1c4$var$HttpsOverHttp2
};


var $2a024f368552c192$require$HttpOverHttp2 = $6c37620d081be1c4$exports.HttpOverHttp2;
var $2a024f368552c192$require$HttpsOverHttp2 = $6c37620d081be1c4$exports.HttpsOverHttp2;
var $f0642d8eef740542$exports = {};
"use strict";

var $f0642d8eef740542$require$globalAgent = $f27a9ba7f5496a52$exports.globalAgent;
var $34baa37b462b4167$exports = {};
"use strict";

var $34baa37b462b4167$require$Agent = $f27a9ba7f5496a52$exports.Agent;



class $34baa37b462b4167$var$Http2OverHttpX extends $34baa37b462b4167$require$Agent {
    constructor(options){
        super(options);
        $ce3cfb104b1e1ca3$exports(this, options.proxyOptions);
    }
    async createConnection(origin, options) {
        const authority = `${origin.hostname}:${origin.port || 443}`;
        const [stream, statusCode, statusMessage] = await this._getProxyStream(authority);
        if (statusCode !== 200) throw new $49bd8099d99c0afc$exports(statusCode, statusMessage);
        if (this.proxyOptions.raw) options.socket = stream;
        else {
            const socket = new $7430fc304029ebac$exports(stream);
            socket.encrypted = false;
            socket._handle.getpeername = (out)=>{
                out.family = undefined;
                out.address = undefined;
                out.port = undefined;
            };
            return socket;
        }
        return super.createConnection(origin, options);
    }
}
$34baa37b462b4167$exports = $34baa37b462b4167$var$Http2OverHttpX;



const $f0642d8eef740542$var$getStatusCode = (stream)=>new Promise((resolve, reject)=>{
        stream.once("error", reject);
        stream.once("response", (headers)=>{
            stream.off("error", reject);
            resolve(headers[":status"]);
        });
    });
class $f0642d8eef740542$var$Http2OverHttp2 extends $34baa37b462b4167$exports {
    async _getProxyStream(authority) {
        const { proxyOptions: proxyOptions } = this;
        const headers = {
            ...$b0f55557acd887ca$exports(this),
            ...proxyOptions.headers,
            ":method": "CONNECT",
            ":authority": authority
        };
        const stream = await $f0642d8eef740542$require$globalAgent.request(proxyOptions.url, proxyOptions, headers);
        const statusCode = await $f0642d8eef740542$var$getStatusCode(stream);
        return [
            stream,
            statusCode,
            ""
        ];
    }
}
$f0642d8eef740542$exports = $f0642d8eef740542$var$Http2OverHttp2;


var $13364042a7c7f3d6$exports = {};
"use strict";




const $13364042a7c7f3d6$var$getStream = (request)=>new Promise((resolve, reject)=>{
        const onConnect = (response, socket, head)=>{
            socket.unshift(head);
            request.off("error", reject);
            resolve([
                socket,
                response.statusCode,
                response.statusMessage
            ]);
        };
        request.once("error", reject);
        request.once("connect", onConnect);
    });
class $13364042a7c7f3d6$var$Http2OverHttp extends $34baa37b462b4167$exports {
    async _getProxyStream(authority) {
        const { proxyOptions: proxyOptions } = this;
        const { url: url, headers: headers } = this.proxyOptions;
        const network = url.protocol === "https:" ? $dAk3n$https : $dAk3n$http;
        // `new URL('https://localhost/httpbin.org:443')` results in
        // a `/httpbin.org:443` path, which has an invalid leading slash.
        const request = network.request({
            ...proxyOptions,
            hostname: url.hostname,
            port: url.port,
            path: authority,
            headers: {
                ...$b0f55557acd887ca$exports(this),
                ...headers,
                host: authority
            },
            method: "CONNECT"
        }).end();
        return $13364042a7c7f3d6$var$getStream(request);
    }
}
$13364042a7c7f3d6$exports = {
    Http2OverHttp: $13364042a7c7f3d6$var$Http2OverHttp,
    Http2OverHttps: $13364042a7c7f3d6$var$Http2OverHttp
};


var $2a024f368552c192$require$Http2OverHttp = $13364042a7c7f3d6$exports.Http2OverHttp;
var $2a024f368552c192$require$Http2OverHttps = $13364042a7c7f3d6$exports.Http2OverHttps;


const $2a024f368552c192$var$request = (url, options, callback)=>new $1395c2d3cfe2b43f$exports(url, options, callback);
const $2a024f368552c192$var$get = (url, options, callback)=>{
    // eslint-disable-next-line unicorn/prevent-abbreviations
    const req = new $1395c2d3cfe2b43f$exports(url, options, callback);
    req.end();
    return req;
};
$2a024f368552c192$exports = {
    ...$dAk3n$http2,
    ClientRequest: $1395c2d3cfe2b43f$exports,
    IncomingMessage: $03986b38485bbd9f$exports,
    Agent: $2a024f368552c192$require$Agent,
    globalAgent: $2a024f368552c192$require$globalAgent,
    request: $2a024f368552c192$var$request,
    get: $2a024f368552c192$var$get,
    auto: $20f44ebf9f76ef32$exports,
    proxies: {
        HttpOverHttp2: $2a024f368552c192$require$HttpOverHttp2,
        HttpsOverHttp2: $2a024f368552c192$require$HttpsOverHttp2,
        Http2OverHttp2: $f0642d8eef740542$exports,
        Http2OverHttp: $2a024f368552c192$require$Http2OverHttp,
        Http2OverHttps: $2a024f368552c192$require$Http2OverHttps
    },
    validateHeaderName: $12951c7d748a7be1$exports,
    validateHeaderValue: $20773763b613875d$exports
};



function $31c7246525649940$export$2e2bcd8739ae039(link) {
    const parsed = [];
    const items = link.split(",");
    for (const item of items){
        // https://tools.ietf.org/html/rfc5988#section-5
        const [rawUriReference, ...rawLinkParameters] = item.split(";");
        const trimmedUriReference = rawUriReference.trim();
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        if (trimmedUriReference[0] !== "<" || trimmedUriReference[trimmedUriReference.length - 1] !== ">") throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
        const reference = trimmedUriReference.slice(1, -1);
        const parameters = {};
        if (rawLinkParameters.length === 0) throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
        for (const rawParameter of rawLinkParameters){
            const trimmedRawParameter = rawParameter.trim();
            const center = trimmedRawParameter.indexOf("=");
            if (center === -1) throw new Error(`Failed to parse Link header: ${link}`);
            const name = trimmedRawParameter.slice(0, center).trim();
            const value = trimmedRawParameter.slice(center + 1).trim();
            parameters[name] = value;
        }
        parsed.push({
            reference: reference,
            parameters: parameters
        });
    }
    return parsed;
}


const [$50d8a008d62bdd46$var$major, $50d8a008d62bdd46$var$minor] = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).versions.node.split(".").map(Number);
function $50d8a008d62bdd46$var$validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for(const key in searchParameters){
        const value = searchParameters[key];
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).null_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
    }
}
const $50d8a008d62bdd46$var$globalCache = new Map();
let $50d8a008d62bdd46$var$globalDnsCache;
const $50d8a008d62bdd46$var$getGlobalDnsCache = ()=>{
    if ($50d8a008d62bdd46$var$globalDnsCache) return $50d8a008d62bdd46$var$globalDnsCache;
    $50d8a008d62bdd46$var$globalDnsCache = new (0, $c3c5a2a4f023bf43$export$2e2bcd8739ae039)();
    return $50d8a008d62bdd46$var$globalDnsCache;
};
const $50d8a008d62bdd46$var$defaultInternals = {
    request: undefined,
    agent: {
        http: undefined,
        https: undefined,
        http2: undefined
    },
    h2session: undefined,
    decompress: true,
    timeout: {
        connect: undefined,
        lookup: undefined,
        read: undefined,
        request: undefined,
        response: undefined,
        secureConnect: undefined,
        send: undefined,
        socket: undefined
    },
    prefixUrl: "",
    body: undefined,
    form: undefined,
    json: undefined,
    cookieJar: undefined,
    ignoreInvalidCookies: false,
    searchParams: undefined,
    dnsLookup: undefined,
    dnsCache: undefined,
    context: {},
    hooks: {
        init: [],
        beforeRequest: [],
        beforeError: [],
        beforeRedirect: [],
        beforeRetry: [],
        afterResponse: []
    },
    followRedirect: true,
    maxRedirects: 10,
    cache: undefined,
    throwHttpErrors: true,
    username: "",
    password: "",
    http2: false,
    allowGetBody: false,
    headers: {
        "user-agent": "got (https://github.com/sindresorhus/got)"
    },
    methodRewriting: false,
    dnsLookupIpVersion: undefined,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
        limit: 2,
        methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
        ],
        statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
        ],
        errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
        ],
        maxRetryAfter: undefined,
        calculateDelay: ({ computedValue: computedValue })=>computedValue,
        backoffLimit: Number.POSITIVE_INFINITY,
        noise: 100
    },
    localAddress: undefined,
    method: "GET",
    createConnection: undefined,
    cacheOptions: {
        shared: undefined,
        cacheHeuristic: undefined,
        immutableMinTimeToLive: undefined,
        ignoreCargoCult: undefined
    },
    https: {
        alpnProtocols: undefined,
        rejectUnauthorized: undefined,
        checkServerIdentity: undefined,
        certificateAuthority: undefined,
        key: undefined,
        certificate: undefined,
        passphrase: undefined,
        pfx: undefined,
        ciphers: undefined,
        honorCipherOrder: undefined,
        minVersion: undefined,
        maxVersion: undefined,
        signatureAlgorithms: undefined,
        tlsSessionLifetime: undefined,
        dhparam: undefined,
        ecdhCurve: undefined,
        certificateRevocationLists: undefined
    },
    encoding: undefined,
    resolveBodyOnly: false,
    isStream: false,
    responseType: "text",
    url: undefined,
    pagination: {
        transform (response) {
            if (response.request.options.responseType === "json") return response.body;
            return JSON.parse(response.body);
        },
        paginate ({ response: response }) {
            const rawLinkHeader = response.headers.link;
            if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") return false;
            const parsed = (0, $31c7246525649940$export$2e2bcd8739ae039)(rawLinkHeader);
            const next = parsed.find((entry)=>entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
            if (next) return {
                url: new (0, $dAk3n$nodeurl.URL)(next.reference, response.url)
            };
            return false;
        },
        filter: ()=>true,
        shouldContinue: ()=>true,
        countLimit: Number.POSITIVE_INFINITY,
        backoff: 0,
        requestLimit: 10000,
        stackAllItems: false
    },
    setHost: true,
    maxHeaderSize: undefined,
    signal: undefined,
    enableUnixSockets: true
};
const $50d8a008d62bdd46$var$cloneInternals = (internals)=>{
    const { hooks: hooks, retry: retry } = internals;
    const result = {
        ...internals,
        context: {
            ...internals.context
        },
        cacheOptions: {
            ...internals.cacheOptions
        },
        https: {
            ...internals.https
        },
        agent: {
            ...internals.agent
        },
        headers: {
            ...internals.headers
        },
        retry: {
            ...retry,
            errorCodes: [
                ...retry.errorCodes
            ],
            methods: [
                ...retry.methods
            ],
            statusCodes: [
                ...retry.statusCodes
            ]
        },
        timeout: {
            ...internals.timeout
        },
        hooks: {
            init: [
                ...hooks.init
            ],
            beforeRequest: [
                ...hooks.beforeRequest
            ],
            beforeError: [
                ...hooks.beforeError
            ],
            beforeRedirect: [
                ...hooks.beforeRedirect
            ],
            beforeRetry: [
                ...hooks.beforeRetry
            ],
            afterResponse: [
                ...hooks.afterResponse
            ]
        },
        searchParams: internals.searchParams ? new (0, $dAk3n$nodeurl.URLSearchParams)(internals.searchParams) : undefined,
        pagination: {
            ...internals.pagination
        }
    };
    if (result.url !== undefined) result.prefixUrl = "";
    return result;
};
const $50d8a008d62bdd46$var$cloneRaw = (raw)=>{
    const { hooks: hooks, retry: retry } = raw;
    const result = {
        ...raw
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.context)) result.context = {
        ...raw.context
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.cacheOptions)) result.cacheOptions = {
        ...raw.cacheOptions
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.https)) result.https = {
        ...raw.https
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.cacheOptions)) result.cacheOptions = {
        ...result.cacheOptions
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.agent)) result.agent = {
        ...raw.agent
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.headers)) result.headers = {
        ...raw.headers
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(retry)) {
        result.retry = {
            ...retry
        };
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(retry.errorCodes)) result.retry.errorCodes = [
            ...retry.errorCodes
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(retry.methods)) result.retry.methods = [
            ...retry.methods
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(retry.statusCodes)) result.retry.statusCodes = [
            ...retry.statusCodes
        ];
    }
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.timeout)) result.timeout = {
        ...raw.timeout
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(hooks)) {
        result.hooks = {
            ...hooks
        };
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.init)) result.hooks.init = [
            ...hooks.init
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeRequest)) result.hooks.beforeRequest = [
            ...hooks.beforeRequest
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeError)) result.hooks.beforeError = [
            ...hooks.beforeError
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeRedirect)) result.hooks.beforeRedirect = [
            ...hooks.beforeRedirect
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeRetry)) result.hooks.beforeRetry = [
            ...hooks.beforeRetry
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.afterResponse)) result.hooks.afterResponse = [
            ...hooks.afterResponse
        ];
    }
    // TODO: raw.searchParams
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.pagination)) result.pagination = {
        ...raw.pagination
    };
    return result;
};
const $50d8a008d62bdd46$var$getHttp2TimeoutOption = (internals)=>{
    const delays = [
        internals.timeout.socket,
        internals.timeout.connect,
        internals.timeout.lookup,
        internals.timeout.request,
        internals.timeout.secureConnect
    ].filter((delay)=>typeof delay === "number");
    if (delays.length > 0) return Math.min(...delays);
    return undefined;
};
const $50d8a008d62bdd46$var$init = (options, withOptions, self)=>{
    const initHooks = options.hooks?.init;
    if (initHooks) for (const hook of initHooks)hook(withOptions, self);
};
class $50d8a008d62bdd46$export$2e2bcd8739ae039 {
    constructor(input, options, defaults){
        Object.defineProperty(this, "_unixOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_internals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_merging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_init", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], input);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], options);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], defaults);
        if (input instanceof $50d8a008d62bdd46$export$2e2bcd8739ae039 || options instanceof $50d8a008d62bdd46$export$2e2bcd8739ae039) throw new TypeError("The defaults must be passed as the third argument");
        this._internals = $50d8a008d62bdd46$var$cloneInternals(defaults?._internals ?? defaults ?? $50d8a008d62bdd46$var$defaultInternals);
        this._init = [
            ...defaults?._init ?? []
        ];
        this._merging = false;
        this._unixOptions = undefined;
        // This rule allows `finally` to be considered more important.
        // Meaning no matter the error thrown in the `try` block,
        // if `finally` throws then the `finally` error will be thrown.
        //
        // Yes, we want this. If we set `url` first, then the `url.searchParams`
        // would get merged. Instead we set the `searchParams` first, then
        // `url.searchParams` is overwritten as expected.
        //
        /* eslint-disable no-unsafe-finally */ try {
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).plainObject(input)) try {
                this.merge(input);
                this.merge(options);
            } finally{
                this.url = input.url;
            }
            else try {
                this.merge(options);
            } finally{
                if (options?.url !== undefined) {
                    if (input === undefined) this.url = options.url;
                    else throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
                } else if (input !== undefined) this.url = input;
            }
        } catch (error) {
            error.options = this;
            throw error;
        }
    /* eslint-enable no-unsafe-finally */ }
    merge(options) {
        if (!options) return;
        if (options instanceof $50d8a008d62bdd46$export$2e2bcd8739ae039) {
            for (const init of options._init)this.merge(init);
            return;
        }
        options = $50d8a008d62bdd46$var$cloneRaw(options);
        $50d8a008d62bdd46$var$init(this, options, this);
        $50d8a008d62bdd46$var$init(options, options, this);
        this._merging = true;
        // Always merge `isStream` first
        if ("isStream" in options) this.isStream = options.isStream;
        try {
            let push = false;
            for(const key in options){
                // `got.extend()` options
                if (key === "mutableDefaults" || key === "handlers") continue;
                // Never merge `url`
                if (key === "url") continue;
                if (!(key in this)) throw new Error(`Unexpected option: ${key}`);
                // @ts-expect-error Type 'unknown' is not assignable to type 'never'.
                this[key] = options[key];
                push = true;
            }
            if (push) this._init.push(options);
        } finally{
            this._merging = false;
        }
    }
    /**
    Custom request function.
    The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).

    @default http.request | https.request
    */ get request() {
        return this._internals.request;
    }
    set request(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.request = value;
    }
    /**
    An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
    This is necessary because a request to one protocol might redirect to another.
    In such a scenario, Got will switch over to the right protocol agent for you.

    If a key is not present, it will default to a global agent.

    @example
    ```
    import got from 'got';
    import HttpAgent from 'agentkeepalive';

    const {HttpsAgent} = HttpAgent;

    await got('https://sindresorhus.com', {
        agent: {
            http: new HttpAgent(),
            https: new HttpsAgent()
        }
    });
    ```
    */ get agent() {
        return this._internals.agent;
    }
    set agent(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        // eslint-disable-next-line guard-for-in
        for(const key in value){
            if (!(key in this._internals.agent)) throw new TypeError(`Unexpected agent option: ${key}`);
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
            ], value[key]);
        }
        if (this._merging) Object.assign(this._internals.agent, value);
        else this._internals.agent = {
            ...value
        };
    }
    get h2session() {
        return this._internals.h2session;
    }
    set h2session(value) {
        this._internals.h2session = value;
    }
    /**
    Decompress the response automatically.

    This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.

    If this is disabled, a compressed response is returned as a `Buffer`.
    This may be useful if you want to handle decompression yourself or stream the raw compressed data.

    @default true
    */ get decompress() {
        return this._internals.decompress;
    }
    set decompress(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.decompress = value;
    }
    /**
    Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
    By default, there's no timeout.

    This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:

    - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
        Does not apply when using a Unix domain socket.
    - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
    - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
    - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
    - `response` starts when the request has been written to the socket and ends when the response headers are received.
    - `send` starts when the socket is connected and ends with the request has been written to the socket.
    - `request` starts when the request is initiated and ends when the response's end event fires.
    */ get timeout() {
        // We always return `Delays` here.
        // It has to be `Delays | number`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.timeout;
    }
    set timeout(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        // eslint-disable-next-line guard-for-in
        for(const key in value){
            if (!(key in this._internals.timeout)) throw new Error(`Unexpected timeout option: ${key}`);
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
            ], value[key]);
        }
        if (this._merging) Object.assign(this._internals.timeout, value);
        else this._internals.timeout = {
            ...value
        };
    }
    /**
    When specified, `prefixUrl` will be prepended to `url`.
    The prefix can be any valid URL, either relative or absolute.
    A trailing slash `/` is optional - one will be added automatically.

    __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.

    __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
    For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
    The latter is used by browsers.

    __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.

    __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
    If the URL doesn't include it anymore, it will throw.

    @example
    ```
    import got from 'got';

    await got('unicorn', {prefixUrl: 'https://cats.com'});
    //=> 'https://cats.com/unicorn'

    const instance = got.extend({
        prefixUrl: 'https://google.com'
    });

    await instance('unicorn', {
        hooks: {
            beforeRequest: [
                options => {
                    options.prefixUrl = 'https://cats.com';
                }
            ]
        }
    });
    //=> 'https://cats.com/unicorn'
    ```
    */ get prefixUrl() {
        // We always return `string` here.
        // It has to be `string | URL`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.prefixUrl;
    }
    set prefixUrl(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance
        ], value);
        if (value === "") {
            this._internals.prefixUrl = "";
            return;
        }
        value = value.toString();
        if (!value.endsWith("/")) value += "/";
        if (this._internals.prefixUrl && this._internals.url) {
            const { href: href } = this._internals.url;
            this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
        }
        this._internals.prefixUrl = value;
    }
    /**
    __Note #1__: The `body` option cannot be used with the `json` or `form` option.

    __Note #2__: If you provide this option, `got.stream()` will be read-only.

    __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.

    __Note #4__: This option is not enumerable and will not be merged with the instance defaults.

    The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.

    Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
    */ get body() {
        return this._internals.body;
    }
    set body(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).generator,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).asyncGenerator,
            (0, $3217e51b94272cab$export$67a42df2b7ab73bc),
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(value)) (0, $23048e7f833b5d93$export$a7a9523472993e97).truthy(value.readable);
        if (value !== undefined) {
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.form);
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.json);
        }
        this._internals.body = value;
    }
    /**
    The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).

    If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */ get form() {
        return this._internals.form;
    }
    set form(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).plainObject,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value !== undefined) {
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.body);
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.json);
        }
        this._internals.form = value;
    }
    /**
    JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */ get json() {
        return this._internals.json;
    }
    set json(value) {
        if (value !== undefined) {
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.body);
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.form);
        }
        this._internals.json = value;
    }
    /**
    The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).

    Properties from `options` will override properties in the parsed `url`.

    If no protocol is specified, it will throw a `TypeError`.

    __Note__: The query string is **not** parsed as search params.

    @example
    ```
    await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
    await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b

    // The query string is overridden by `searchParams`
    await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
    ```
    */ get url() {
        return this._internals.url;
    }
    set url(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === undefined) {
            this._internals.url = undefined;
            return;
        }
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(value) && value.startsWith("/")) throw new Error("`url` must not start with a slash");
        const urlString = `${this.prefixUrl}${value.toString()}`;
        const url = new (0, $dAk3n$nodeurl.URL)(urlString);
        this._internals.url = url;
        if (url.protocol === "unix:") url.href = `http://unix${url.pathname}${url.search}`;
        if (url.protocol !== "http:" && url.protocol !== "https:") {
            const error = new Error(`Unsupported protocol: ${url.protocol}`);
            error.code = "ERR_UNSUPPORTED_PROTOCOL";
            throw error;
        }
        if (this._internals.username) {
            url.username = this._internals.username;
            this._internals.username = "";
        }
        if (this._internals.password) {
            url.password = this._internals.password;
            this._internals.password = "";
        }
        if (this._internals.searchParams) {
            url.search = this._internals.searchParams.toString();
            this._internals.searchParams = undefined;
        }
        if (url.hostname === "unix") {
            if (!this._internals.enableUnixSockets) throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches?.groups) {
                const { socketPath: socketPath, path: path } = matches.groups;
                this._unixOptions = {
                    socketPath: socketPath,
                    path: path,
                    host: ""
                };
            } else this._unixOptions = undefined;
            return;
        }
        this._unixOptions = undefined;
    }
    /**
    Cookie support. You don't have to care about parsing or how to store them.

    __Note__: If you provide this option, `options.headers.cookie` will be overridden.
    */ get cookieJar() {
        return this._internals.cookieJar;
    }
    set cookieJar(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === undefined) {
            this._internals.cookieJar = undefined;
            return;
        }
        let { setCookie: setCookie, getCookieString: getCookieString } = value;
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(setCookie);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(getCookieString);
        /* istanbul ignore next: Horrible `tough-cookie` v3 check */ if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = (0, $dAk3n$nodeutil.promisify)(setCookie.bind(value));
            getCookieString = (0, $dAk3n$nodeutil.promisify)(getCookieString.bind(value));
            this._internals.cookieJar = {
                setCookie: setCookie,
                getCookieString: getCookieString
            };
        } else this._internals.cookieJar = value;
    }
    /**
    You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).

    *Requires Node.js 16 or later.*

    @example
    ```
    import got from 'got';

    const abortController = new AbortController();

    const request = got('https://httpbin.org/anything', {
        signal: abortController.signal
    });

    setTimeout(() => {
        abortController.abort();
    }, 100);
    ```
    */ // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    get signal() {
        return this._internals.signal;
    }
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    set signal(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        this._internals.signal = value;
    }
    /**
    Ignore invalid cookies instead of throwing an error.
    Only useful when the `cookieJar` option has been set. Not recommended.

    @default false
    */ get ignoreInvalidCookies() {
        return this._internals.ignoreInvalidCookies;
    }
    set ignoreInvalidCookies(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.ignoreInvalidCookies = value;
    }
    /**
    Query string that will be added to the request URL.
    This will override the query string in `url`.

    If you need to pass in an array, you can do it using a `URLSearchParams` instance.

    @example
    ```
    import got from 'got';

    const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);

    await got('https://example.com', {searchParams});

    console.log(searchParams.toString());
    //=> 'key=a&key=b'
    ```
    */ get searchParams() {
        if (this._internals.url) return this._internals.url.searchParams;
        if (this._internals.searchParams === undefined) this._internals.searchParams = new (0, $dAk3n$nodeurl.URLSearchParams)();
        return this._internals.searchParams;
    }
    set searchParams(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        const url = this._internals.url;
        if (value === undefined) {
            this._internals.searchParams = undefined;
            if (url) url.search = "";
            return;
        }
        const searchParameters = this.searchParams;
        let updated;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(value)) updated = new (0, $dAk3n$nodeurl.URLSearchParams)(value);
        else if (value instanceof (0, $dAk3n$nodeurl.URLSearchParams)) updated = value;
        else {
            $50d8a008d62bdd46$var$validateSearchParameters(value);
            updated = new (0, $dAk3n$nodeurl.URLSearchParams)();
            // eslint-disable-next-line guard-for-in
            for(const key in value){
                const entry = value[key];
                if (entry === null) updated.append(key, "");
                else if (entry === undefined) searchParameters.delete(key);
                else updated.append(key, entry);
            }
        }
        if (this._merging) {
            // These keys will be replaced
            for (const key of updated.keys())searchParameters.delete(key);
            for (const [key, value] of updated)searchParameters.append(key, value);
        } else if (url) url.search = searchParameters.toString();
        else this._internals.searchParams = searchParameters;
    }
    get searchParameters() {
        throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    set searchParameters(_value) {
        throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    get dnsLookup() {
        return this._internals.dnsLookup;
    }
    set dnsLookup(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.dnsLookup = value;
    }
    /**
    An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
    Useful when making lots of requests to different *public* hostnames.

    `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.

    __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.

    @default false
    */ get dnsCache() {
        return this._internals.dnsCache;
    }
    set dnsCache(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === true) this._internals.dnsCache = $50d8a008d62bdd46$var$getGlobalDnsCache();
        else if (value === false) this._internals.dnsCache = undefined;
        else this._internals.dnsCache = value;
    }
    /**
    User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.

    @example
    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            beforeRequest: [
                options => {
                    if (!options.context || !options.context.token) {
                        throw new Error('Token required');
                    }

                    options.headers.token = options.context.token;
                }
            ]
        }
    });

    const context = {
        token: 'secret'
    };

    const response = await instance('https://httpbin.org/headers', {context});

    // Let's see the headers
    console.log(response.body);
    ```
    */ get context() {
        return this._internals.context;
    }
    set context(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        if (this._merging) Object.assign(this._internals.context, value);
        else this._internals.context = {
            ...value
        };
    }
    /**
    Hooks allow modifications during the request lifecycle.
    Hook functions may be async and are run serially.
    */ get hooks() {
        return this._internals.hooks;
    }
    set hooks(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        // eslint-disable-next-line guard-for-in
        for(const knownHookEvent in value){
            if (!(knownHookEvent in this._internals.hooks)) throw new Error(`Unexpected hook event: ${knownHookEvent}`);
            const typedKnownHookEvent = knownHookEvent;
            const hooks = value[typedKnownHookEvent];
            (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
            ], hooks);
            if (hooks) for (const hook of hooks)(0, $23048e7f833b5d93$export$a7a9523472993e97).function_(hook);
            if (this._merging) {
                if (hooks) // @ts-expect-error FIXME
                this._internals.hooks[typedKnownHookEvent].push(...hooks);
            } else {
                if (!hooks) throw new Error(`Missing hook event: ${knownHookEvent}`);
                // @ts-expect-error FIXME
                this._internals.hooks[knownHookEvent] = [
                    ...hooks
                ];
            }
        }
    }
    /**
    Defines if redirect responses should be followed automatically.

    Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
    This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.

    @default true
    */ get followRedirect() {
        return this._internals.followRedirect;
    }
    set followRedirect(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.followRedirect = value;
    }
    get followRedirects() {
        throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    set followRedirects(_value) {
        throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    /**
    If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.

    @default 10
    */ get maxRedirects() {
        return this._internals.maxRedirects;
    }
    set maxRedirects(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(value);
        this._internals.maxRedirects = value;
    }
    /**
    A cache adapter instance for storing cached response data.

    @default false
    */ get cache() {
        return this._internals.cache;
    }
    set cache(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === true) this._internals.cache = $50d8a008d62bdd46$var$globalCache;
        else if (value === false) this._internals.cache = undefined;
        else this._internals.cache = value;
    }
    /**
    Determines if a `got.HTTPError` is thrown for unsuccessful responses.

    If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
    This may be useful if you are checking for resource availability and are expecting error responses.

    @default true
    */ get throwHttpErrors() {
        return this._internals.throwHttpErrors;
    }
    set throwHttpErrors(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.throwHttpErrors = value;
    }
    get username() {
        const url = this._internals.url;
        const value = url ? url.username : this._internals.username;
        return decodeURIComponent(value);
    }
    set username(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) url.username = fixedValue;
        else this._internals.username = fixedValue;
    }
    get password() {
        const url = this._internals.url;
        const value = url ? url.password : this._internals.password;
        return decodeURIComponent(value);
    }
    set password(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) url.password = fixedValue;
        else this._internals.password = fixedValue;
    }
    /**
    If set to `true`, Got will additionally accept HTTP2 requests.

    It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.

    __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.

    __Note__: Overriding `options.request` will disable HTTP2 support.

    @default false

    @example
    ```
    import got from 'got';

    const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});

    console.log(headers.via);
    //=> '2 nghttpx'
    ```
    */ get http2() {
        return this._internals.http2;
    }
    set http2(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.http2 = value;
    }
    /**
    Set this to `true` to allow sending body for the `GET` method.
    However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
    This option is only meant to interact with non-compliant servers when you have no other choice.

    __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.

    @default false
    */ get allowGetBody() {
        return this._internals.allowGetBody;
    }
    set allowGetBody(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.allowGetBody = value;
    }
    /**
    Request headers.

    Existing headers will be overwritten. Headers set to `undefined` will be omitted.

    @default {}
    */ get headers() {
        return this._internals.headers;
    }
    set headers(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        if (this._merging) Object.assign(this._internals.headers, (0, $cc1220db54f967ea$export$2e2bcd8739ae039)(value));
        else this._internals.headers = (0, $cc1220db54f967ea$export$2e2bcd8739ae039)(value);
    }
    /**
    Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.

    As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
    Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.

    __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).

    @default false
    */ get methodRewriting() {
        return this._internals.methodRewriting;
    }
    set methodRewriting(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.methodRewriting = value;
    }
    /**
    Indicates which DNS record family to use.

    Values:
    - `undefined`: IPv4 (if present) or IPv6
    - `4`: Only IPv4
    - `6`: Only IPv6

    @default undefined
    */ get dnsLookupIpVersion() {
        return this._internals.dnsLookupIpVersion;
    }
    set dnsLookupIpVersion(value) {
        if (value !== undefined && value !== 4 && value !== 6) throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
        this._internals.dnsLookupIpVersion = value;
    }
    /**
    A function used to parse JSON responses.

    @example
    ```
    import got from 'got';
    import Bourne from '@hapi/bourne';

    const parsed = await got('https://example.com', {
        parseJson: text => Bourne.parse(text)
    }).json();

    console.log(parsed);
    ```
    */ get parseJson() {
        return this._internals.parseJson;
    }
    set parseJson(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(value);
        this._internals.parseJson = value;
    }
    /**
    A function used to stringify the body of JSON requests.

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (key.startsWith('_')) {
                return;
            }

            return value;
        }),
        json: {
            some: 'payload',
            _ignoreMe: 1234
        }
    });
    ```

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (typeof value === 'number') {
                return value.toString();
            }

            return value;
        }),
        json: {
            some: 'payload',
            number: 1
        }
    });
    ```
    */ get stringifyJson() {
        return this._internals.stringifyJson;
    }
    set stringifyJson(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(value);
        this._internals.stringifyJson = value;
    }
    /**
    An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.

    Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).

    The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
    The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).

    By default, it retries *only* on the specified methods, status codes, and on these network errors:

    - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
    - `ECONNRESET`: Connection was forcibly closed by a peer.
    - `EADDRINUSE`: Could not bind to any free port.
    - `ECONNREFUSED`: Connection was refused by the server.
    - `EPIPE`: The remote side of the stream being written has been closed.
    - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
    - `ENETUNREACH`: No internet connection.
    - `EAI_AGAIN`: DNS lookup timed out.

    __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
    __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
    */ get retry() {
        return this._internals.retry;
    }
    set retry(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.calculateDelay);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.maxRetryAfter);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.limit);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.methods);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.statusCodes);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.errorCodes);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.noise);
        if (value.noise && Math.abs(value.noise) > 100) throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
        for(const key in value){
            if (!(key in this._internals.retry)) throw new Error(`Unexpected retry option: ${key}`);
        }
        if (this._merging) Object.assign(this._internals.retry, value);
        else this._internals.retry = {
            ...value
        };
        const { retry: retry } = this._internals;
        retry.methods = [
            ...new Set(retry.methods.map((method)=>method.toUpperCase()))
        ];
        retry.statusCodes = [
            ...new Set(retry.statusCodes)
        ];
        retry.errorCodes = [
            ...new Set(retry.errorCodes)
        ];
    }
    /**
    From `http.RequestOptions`.

    The IP address used to send the request from.
    */ get localAddress() {
        return this._internals.localAddress;
    }
    set localAddress(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.localAddress = value;
    }
    /**
    The HTTP method used to make the request.

    @default 'GET'
    */ get method() {
        return this._internals.method;
    }
    set method(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).string(value);
        this._internals.method = value.toUpperCase();
    }
    get createConnection() {
        return this._internals.createConnection;
    }
    set createConnection(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.createConnection = value;
    }
    /**
    From `http-cache-semantics`

    @default {}
    */ get cacheOptions() {
        return this._internals.cacheOptions;
    }
    set cacheOptions(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.shared);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.cacheHeuristic);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.immutableMinTimeToLive);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.ignoreCargoCult);
        for(const key in value){
            if (!(key in this._internals.cacheOptions)) throw new Error(`Cache option \`${key}\` does not exist`);
        }
        if (this._merging) Object.assign(this._internals.cacheOptions, value);
        else this._internals.cacheOptions = {
            ...value
        };
    }
    /**
    Options for the advanced HTTPS API.
    */ get https() {
        return this._internals.https;
    }
    set https(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.rejectUnauthorized);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.checkServerIdentity);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.certificateAuthority);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.key);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.certificate);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.passphrase);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.pfx);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.alpnProtocols);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.ciphers);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.dhparam);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.signatureAlgorithms);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.minVersion);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.maxVersion);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.honorCipherOrder);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.tlsSessionLifetime);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.ecdhCurve);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.certificateRevocationLists);
        for(const key in value){
            if (!(key in this._internals.https)) throw new Error(`HTTPS option \`${key}\` does not exist`);
        }
        if (this._merging) Object.assign(this._internals.https, value);
        else this._internals.https = {
            ...value
        };
    }
    /**
    [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.

    To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
    Don't set this option to `null`.

    __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.

    @default 'utf-8'
    */ get encoding() {
        return this._internals.encoding;
    }
    set encoding(value) {
        if (value === null) throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.encoding = value;
    }
    /**
    When set to `true` the promise will return the Response body instead of the Response object.

    @default false
    */ get resolveBodyOnly() {
        return this._internals.resolveBodyOnly;
    }
    set resolveBodyOnly(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.resolveBodyOnly = value;
    }
    /**
    Returns a `Stream` instead of a `Promise`.
    This is equivalent to calling `got.stream(url, options?)`.

    @default false
    */ get isStream() {
        return this._internals.isStream;
    }
    set isStream(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.isStream = value;
    }
    /**
    The parsing method.

    The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.

    It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.

    __Note__: When using streams, this option is ignored.

    @example
    ```
    const responsePromise = got(url);
    const bufferPromise = responsePromise.buffer();
    const jsonPromise = responsePromise.json();

    const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
    // `response` is an instance of Got Response
    // `buffer` is an instance of Buffer
    // `json` is an object
    ```

    @example
    ```
    // This
    const body = await got(url).json();

    // is semantically the same as this
    const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
    ```
    */ get responseType() {
        return this._internals.responseType;
    }
    set responseType(value) {
        if (value === undefined) {
            this._internals.responseType = "text";
            return;
        }
        if (value !== "text" && value !== "buffer" && value !== "json") throw new Error(`Invalid \`responseType\` option: ${value}`);
        this._internals.responseType = value;
    }
    get pagination() {
        return this._internals.pagination;
    }
    set pagination(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        if (this._merging) Object.assign(this._internals.pagination, value);
        else this._internals.pagination = value;
    }
    get auth() {
        throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    set auth(_value) {
        throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    get setHost() {
        return this._internals.setHost;
    }
    set setHost(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.setHost = value;
    }
    get maxHeaderSize() {
        return this._internals.maxHeaderSize;
    }
    set maxHeaderSize(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.maxHeaderSize = value;
    }
    get enableUnixSockets() {
        return this._internals.enableUnixSockets;
    }
    set enableUnixSockets(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.enableUnixSockets = value;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    toJSON() {
        return {
            ...this._internals
        };
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
        return (0, $dAk3n$nodeutil.inspect)(this._internals, options);
    }
    createNativeRequestOptions() {
        const internals = this._internals;
        const url = internals.url;
        let agent;
        if (url.protocol === "https:") agent = internals.http2 ? internals.agent : internals.agent.https;
        else agent = internals.agent.http;
        const { https: https } = internals;
        let { pfx: pfx } = https;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(pfx) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).plainObject(pfx[0])) pfx = pfx.map((object)=>({
                buf: object.buffer,
                passphrase: object.passphrase
            }));
        return {
            ...internals.cacheOptions,
            ...this._unixOptions,
            // HTTPS options
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ALPNProtocols: https.alpnProtocols,
            ca: https.certificateAuthority,
            cert: https.certificate,
            key: https.key,
            passphrase: https.passphrase,
            pfx: https.pfx,
            rejectUnauthorized: https.rejectUnauthorized,
            checkServerIdentity: https.checkServerIdentity ?? (0, $dAk3n$nodetls.checkServerIdentity),
            ciphers: https.ciphers,
            honorCipherOrder: https.honorCipherOrder,
            minVersion: https.minVersion,
            maxVersion: https.maxVersion,
            sigalgs: https.signatureAlgorithms,
            sessionTimeout: https.tlsSessionLifetime,
            dhparam: https.dhparam,
            ecdhCurve: https.ecdhCurve,
            crl: https.certificateRevocationLists,
            // HTTP options
            lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
            family: internals.dnsLookupIpVersion,
            agent: agent,
            setHost: internals.setHost,
            method: internals.method,
            maxHeaderSize: internals.maxHeaderSize,
            localAddress: internals.localAddress,
            headers: internals.headers,
            createConnection: internals.createConnection,
            timeout: internals.http2 ? $50d8a008d62bdd46$var$getHttp2TimeoutOption(internals) : undefined,
            // HTTP/2 options
            h2session: internals.h2session
        };
    }
    getRequestFunction() {
        const url = this._internals.url;
        const { request: request } = this._internals;
        if (!request && url) return this.getFallbackRequestFunction();
        return request;
    }
    getFallbackRequestFunction() {
        const url = this._internals.url;
        if (!url) return;
        if (url.protocol === "https:") {
            if (this._internals.http2) {
                if ($50d8a008d62bdd46$var$major < 15 || $50d8a008d62bdd46$var$major === 15 && $50d8a008d62bdd46$var$minor < 10) {
                    const error = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
                    error.code = "EUNSUPPORTED";
                    throw error;
                }
                return (0, (/*@__PURE__*/$parcel$interopDefault($2a024f368552c192$exports))).auto;
            }
            return (0, ($parcel$interopDefault($dAk3n$nodehttps))).request;
        }
        return (0, ($parcel$interopDefault($dAk3n$nodehttp))).request;
    }
    freeze() {
        const options = this._internals;
        Object.freeze(options);
        Object.freeze(options.hooks);
        Object.freeze(options.hooks.afterResponse);
        Object.freeze(options.hooks.beforeError);
        Object.freeze(options.hooks.beforeRedirect);
        Object.freeze(options.hooks.beforeRequest);
        Object.freeze(options.hooks.beforeRetry);
        Object.freeze(options.hooks.init);
        Object.freeze(options.https);
        Object.freeze(options.cacheOptions);
        Object.freeze(options.agent);
        Object.freeze(options.headers);
        Object.freeze(options.timeout);
        Object.freeze(options.retry);
        Object.freeze(options.retry.errorCodes);
        Object.freeze(options.retry.methods);
        Object.freeze(options.retry.statusCodes);
    }
}



const $55c0d93679690b5b$export$746ebf9e39b71511 = (response)=>{
    const { statusCode: statusCode } = response;
    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
    return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
class $55c0d93679690b5b$export$f9c837a54db411d extends (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743) {
    constructor(error, response){
        const { options: options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = "ParseError";
        this.code = "ERR_BODY_PARSE_FAILURE";
    }
}
const $55c0d93679690b5b$export$3b629cd0ff482602 = (response, responseType, parseJson, encoding)=>{
    const { rawBody: rawBody } = response;
    try {
        if (responseType === "text") return rawBody.toString(encoding);
        if (responseType === "json") return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
        if (responseType === "buffer") return rawBody;
    } catch (error) {
        throw new $55c0d93679690b5b$export$f9c837a54db411d(error, response);
    }
    throw new $55c0d93679690b5b$export$f9c837a54db411d({
        message: `Unknown body type '${responseType}'`,
        name: "Error"
    }, response);
};


function $8d86e64dbd681a61$var$isClientRequest(clientRequest) {
    return clientRequest.writable && !clientRequest.writableEnded;
}
var $8d86e64dbd681a61$export$2e2bcd8739ae039 = $8d86e64dbd681a61$var$isClientRequest;


// eslint-disable-next-line @typescript-eslint/naming-convention
function $df34902dcbfbf4e8$export$2e2bcd8739ae039(url) {
    return url.protocol === "unix:" || url.hostname === "unix";
}



const { buffer: $851c2383dc8b8638$var$getBuffer } = (0, (/*@__PURE__*/$parcel$interopDefault($d62fd2c5965796dc$exports)));
const $851c2383dc8b8638$var$supportsBrotli = (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string((0, ($parcel$interopDefault($dAk3n$nodeprocess))).versions.brotli);
const $851c2383dc8b8638$var$methodsWithoutBody = new Set([
    "GET",
    "HEAD"
]);
const $851c2383dc8b8638$var$cacheableStore = new (0, $3fee59244baa25fc$export$2e2bcd8739ae039)();
const $851c2383dc8b8638$var$redirectCodes = new Set([
    300,
    301,
    302,
    303,
    304,
    307,
    308
]);
const $851c2383dc8b8638$var$proxiedRequestEvents = [
    "socket",
    "connect",
    "continue",
    "information",
    "upgrade"
];
const $851c2383dc8b8638$var$noop = ()=>{};
class $851c2383dc8b8638$export$2e2bcd8739ae039 extends (0, $dAk3n$nodestream.Duplex) {
    constructor(url, options, defaults){
        super({
            // Don't destroy immediately, as the error may be emitted on unsuccessful retry
            autoDestroy: false,
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0
        });
        // @ts-expect-error - Ignoring for now.
        Object.defineProperty(this, "constructor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_noPipe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "requestUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "redirectUrls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retryCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_stopRetry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downloadedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_uploadedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_stopReading", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pipedServerResponses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_responseSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bodySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_unproxyEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isFromCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cannotHaveBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_triggerRead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cancelTimeouts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_removeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nativeResponse", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_flushed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_aborted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // We need this because `this._request` if `undefined` when using cache
        Object.defineProperty(this, "_requestInitialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._downloadedSize = 0;
        this._uploadedSize = 0;
        this._stopReading = false;
        this._pipedServerResponses = new Set();
        this._cannotHaveBody = false;
        this._unproxyEvents = $851c2383dc8b8638$var$noop;
        this._triggerRead = false;
        this._cancelTimeouts = $851c2383dc8b8638$var$noop;
        this._removeListeners = $851c2383dc8b8638$var$noop;
        this._jobs = [];
        this._flushed = false;
        this._requestInitialized = false;
        this._aborted = false;
        this.redirectUrls = [];
        this.retryCount = 0;
        this._stopRetry = $851c2383dc8b8638$var$noop;
        this.on("pipe", (source)=>{
            if (source?.headers) Object.assign(this.options.headers, source.headers);
        });
        this.on("newListener", (event)=>{
            if (event === "retry" && this.listenerCount("retry") > 0) throw new Error("A retry listener has been attached already.");
        });
        try {
            this.options = new (0, $50d8a008d62bdd46$export$2e2bcd8739ae039)(url, options, defaults);
            if (!this.options.url) {
                if (this.options.prefixUrl === "") throw new TypeError("Missing `url` property");
                this.options.url = "";
            }
            this.requestUrl = this.options.url;
        } catch (error) {
            const { options: options } = error;
            if (options) this.options = options;
            this.flush = async ()=>{
                this.flush = async ()=>{};
                this.destroy(error);
            };
            return;
        }
        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.
        // The below is run only once.
        const { body: body } = this.options;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body)) body.once("error", (error)=>{
            if (this._flushed) this._beforeError(new (0, $a5bde8c0d43bf4db$export$137ec66182ed30ea)(error, this));
            else this.flush = async ()=>{
                this.flush = async ()=>{};
                this._beforeError(new (0, $a5bde8c0d43bf4db$export$137ec66182ed30ea)(error, this));
            };
        });
        if (this.options.signal) {
            const abort = ()=>{
                this.destroy(new (0, $a5bde8c0d43bf4db$export$18b052ffd8c84d7)(this));
            };
            if (this.options.signal.aborted) abort();
            else {
                this.options.signal.addEventListener("abort", abort);
                this._removeListeners = ()=>{
                    this.options.signal.removeEventListener("abort", abort);
                };
            }
        }
    }
    async flush() {
        if (this._flushed) return;
        this._flushed = true;
        try {
            await this._finalizeBody();
            if (this.destroyed) return;
            await this._makeRequest();
            if (this.destroyed) {
                this._request?.destroy();
                return;
            }
            // Queued writes etc.
            for (const job of this._jobs)job();
            // Prevent memory leak
            this._jobs.length = 0;
            this._requestInitialized = true;
        } catch (error) {
            this._beforeError(error);
        }
    }
    _beforeError(error) {
        if (this._stopReading) return;
        const { response: response, options: options } = this;
        const attemptCount = this.retryCount + (error.name === "RetryError" ? 0 : 1);
        this._stopReading = true;
        if (!(error instanceof (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743))) error = new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)(error.message, error, this);
        const typedError = error;
        (async ()=>{
            // Node.js parser is really weird.
            // It emits post-request Parse Errors on the same instance as previous request. WTF.
            // Therefore we need to check if it has been destroyed as well.
            //
            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,
            // but makes the response unreadable. So we additionally need to check `response.readable`.
            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.
                response.setEncoding(this.readableEncoding);
                const success = await this._setRawBody(response);
                if (success) response.body = response.rawBody.toString();
            }
            if (this.listenerCount("retry") !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && "retry-after" in response.headers) {
                        retryAfter = Number(response.headers["retry-after"]);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
                            if (retryAfter <= 0) retryAfter = 1;
                        } else retryAfter *= 1000;
                    }
                    const retryOptions = options.retry;
                    backoff = await retryOptions.calculateDelay({
                        attemptCount: attemptCount,
                        retryOptions: retryOptions,
                        error: typedError,
                        retryAfter: retryAfter,
                        computedValue: (0, $4b7363a0144183fb$export$2e2bcd8739ae039)({
                            attemptCount: attemptCount,
                            retryOptions: retryOptions,
                            error: typedError,
                            retryAfter: retryAfter,
                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
                        })
                    });
                } catch (error_) {
                    this._error(new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)(error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    await new Promise((resolve)=>{
                        const timeout = setTimeout(resolve, backoff);
                        this._stopRetry = ()=>{
                            clearTimeout(timeout);
                            resolve();
                        };
                    });
                    // Something forced us to abort the retry
                    if (this.destroyed) return;
                    try {
                        for (const hook of this.options.hooks.beforeRetry)// eslint-disable-next-line no-await-in-loop
                        await hook(typedError, this.retryCount + 1);
                    } catch (error_) {
                        this._error(new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)(error_.message, error, this));
                        return;
                    }
                    // Something forced us to abort the retry
                    if (this.destroyed) return;
                    this.destroy();
                    this.emit("retry", this.retryCount + 1, error, (updatedOptions)=>{
                        const request = new $851c2383dc8b8638$export$2e2bcd8739ae039(options.url, updatedOptions, options);
                        request.retryCount = this.retryCount + 1;
                        (0, ($parcel$interopDefault($dAk3n$nodeprocess))).nextTick(()=>{
                            request.flush();
                        });
                        return request;
                    });
                    return;
                }
            }
            this._error(typedError);
        })();
    }
    _read() {
        this._triggerRead = true;
        const { response: response } = this;
        if (response && !this._stopReading) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) this._triggerRead = false;
            let data;
            while((data = response.read()) !== null){
                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands
                const progress = this.downloadProgress;
                if (progress.percent < 1) this.emit("downloadProgress", progress);
                this.push(data);
            }
        }
    }
    _write(chunk, encoding, callback) {
        const write = ()=>{
            this._writeRequest(chunk, encoding, callback);
        };
        if (this._requestInitialized) write();
        else this._jobs.push(write);
    }
    _final(callback) {
        const endRequest = ()=>{
            // We need to check if `this._request` is present,
            // because it isn't when we use cache.
            if (!this._request || this._request.destroyed) {
                callback();
                return;
            }
            this._request.end((error)=>{
                // The request has been destroyed before `_final` finished.
                // See https://github.com/nodejs/node/issues/39356
                if (this._request._writableState?.errored) return;
                if (!error) {
                    this._bodySize = this._uploadedSize;
                    this.emit("uploadProgress", this.uploadProgress);
                    this._request.emit("upload-complete");
                }
                callback(error);
            });
        };
        if (this._requestInitialized) endRequest();
        else this._jobs.push(endRequest);
    }
    _destroy(error, callback) {
        this._stopReading = true;
        this.flush = async ()=>{};
        // Prevent further retries
        this._stopRetry();
        this._cancelTimeouts();
        this._removeListeners();
        if (this.options) {
            const { body: body } = this.options;
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body)) body.destroy();
        }
        if (this._request) this._request.destroy();
        if (error !== null && !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(error) && !(error instanceof (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743))) error = new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)(error.message, error, this);
        callback(error);
    }
    pipe(destination, options) {
        if (destination instanceof (0, $dAk3n$nodehttp.ServerResponse)) this._pipedServerResponses.add(destination);
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof (0, $dAk3n$nodehttp.ServerResponse)) this._pipedServerResponses.delete(destination);
        super.unpipe(destination);
        return this;
    }
    async _finalizeBody() {
        const { options: options } = this;
        const { headers: headers } = options;
        const isForm = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(options.form);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const isJSON = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(options.json);
        const isBody = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(options.body);
        const cannotHaveBody = $851c2383dc8b8638$var$methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (isForm || isJSON || isBody) {
            if (cannotHaveBody) throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            // Serialize body
            const noContentType = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(headers["content-type"]);
            if (isBody) {
                // Body is spec-compliant FormData
                if ((0, $3217e51b94272cab$export$67a42df2b7ab73bc)(options.body)) {
                    const encoder = new (0, $06ae1ff7b4cdf2fd$exports.FormDataEncoder)(options.body);
                    if (noContentType) headers["content-type"] = encoder.headers["Content-Type"];
                    if ("Content-Length" in encoder.headers) headers["content-length"] = encoder.headers["Content-Length"];
                    options.body = encoder.encode();
                }
                // Special case for https://github.com/form-data/form-data
                if ((0, $6d4fe112227e5d6d$export$2e2bcd8739ae039)(options.body) && noContentType) headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
            } else if (isForm) {
                if (noContentType) headers["content-type"] = "application/x-www-form-urlencoded";
                const { form: form } = options;
                options.form = undefined;
                options.body = new (0, $dAk3n$nodeurl.URLSearchParams)(form).toString();
            } else {
                if (noContentType) headers["content-type"] = "application/json";
                const { json: json } = options;
                options.json = undefined;
                options.body = options.stringifyJson(json);
            }
            const uploadBodySize = await (0, $5fdb580cd56326d4$export$2e2bcd8739ae039)(options.body, options.headers);
            // See https://tools.ietf.org/html/rfc7230#section-3.3.2
            // A user agent SHOULD send a Content-Length in a request message when
            // no Transfer-Encoding is sent and the request method defines a meaning
            // for an enclosed payload body.  For example, a Content-Length header
            // field is normally sent in a POST request even when the value is 0
            // (indicating an empty payload body).  A user agent SHOULD NOT send a
            // Content-Length header field when the request message does not contain
            // a payload body and the method semantics do not anticipate such a
            // body.
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers["content-length"]) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers["transfer-encoding"]) && !cannotHaveBody && !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(uploadBodySize)) headers["content-length"] = String(uploadBodySize);
        }
        if (options.responseType === "json" && !("accept" in options.headers)) options.headers.accept = "application/json";
        this._bodySize = Number(headers["content-length"]) || undefined;
    }
    async _onResponseBase(response) {
        // This will be called e.g. when using cache so we need to check if this request has been aborted.
        if (this.isAborted) return;
        const { options: options } = this;
        const { url: url } = options;
        this._nativeResponse = response;
        if (options.decompress) response = (0, (/*@__PURE__*/$parcel$interopDefault($4b1f68885d6f9646$exports)))(response);
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ?? (0, ($parcel$interopDefault($dAk3n$nodehttp))).STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirectUrls;
        typedResponse.request = this;
        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        typedResponse.ok = (0, $55c0d93679690b5b$export$746ebf9e39b71511)(typedResponse);
        this._isFromCache = typedResponse.isFromCache;
        this._responseSize = Number(response.headers["content-length"]) || undefined;
        this.response = typedResponse;
        response.once("end", ()=>{
            this._responseSize = this._downloadedSize;
            this.emit("downloadProgress", this.downloadProgress);
        });
        response.once("error", (error)=>{
            this._aborted = true;
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new (0, $a5bde8c0d43bf4db$export$e5f2fbba71434b55)(error, this));
        });
        response.once("aborted", ()=>{
            this._aborted = true;
            this._beforeError(new (0, $a5bde8c0d43bf4db$export$e5f2fbba71434b55)({
                name: "Error",
                message: "The server aborted pending request",
                code: "ECONNRESET"
            }, this));
        });
        this.emit("downloadProgress", this.downloadProgress);
        const rawCookies = response.headers["set-cookie"];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie)=>options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) promises = promises.map(async (promise)=>{
                try {
                    await promise;
                } catch  {}
            });
            try {
                await Promise.all(promises);
            } catch (error) {
                this._beforeError(error);
                return;
            }
        }
        // The above is running a promise, therefore we need to check if this request has been aborted yet again.
        if (this.isAborted) return;
        if (options.followRedirect && response.headers.location && $851c2383dc8b8638$var$redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be best to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            response.resume();
            this._cancelTimeouts();
            this._unproxyEvents();
            if (this.redirectUrls.length >= options.maxRedirects) {
                this._beforeError(new (0, $a5bde8c0d43bf4db$export$a34d7acee3cbcf76)(this));
                return;
            }
            this._request = undefined;
            const updatedOptions = new (0, $50d8a008d62bdd46$export$2e2bcd8739ae039)(undefined, undefined, this.options);
            const serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
            const canRewrite = statusCode !== 307 && statusCode !== 308;
            const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
            if (serverRequestedGet || userRequestedGet) {
                updatedOptions.method = "GET";
                updatedOptions.body = undefined;
                updatedOptions.json = undefined;
                updatedOptions.form = undefined;
                delete updatedOptions.headers["content-length"];
            }
            try {
                // We need this in order to support UTF-8
                const redirectBuffer = (0, $dAk3n$nodebuffer.Buffer).from(response.headers.location, "binary").toString();
                const redirectUrl = new (0, $dAk3n$nodeurl.URL)(redirectBuffer, url);
                if (!(0, $df34902dcbfbf4e8$export$2e2bcd8739ae039)(url) && (0, $df34902dcbfbf4e8$export$2e2bcd8739ae039)(redirectUrl)) {
                    this._beforeError(new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)("Cannot redirect to UNIX socket", {}, this));
                    return;
                }
                // Redirecting to a different site, clear sensitive data.
                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                    if ("host" in updatedOptions.headers) delete updatedOptions.headers.host;
                    if ("cookie" in updatedOptions.headers) delete updatedOptions.headers.cookie;
                    if ("authorization" in updatedOptions.headers) delete updatedOptions.headers.authorization;
                    if (updatedOptions.username || updatedOptions.password) {
                        updatedOptions.username = "";
                        updatedOptions.password = "";
                    }
                } else {
                    redirectUrl.username = updatedOptions.username;
                    redirectUrl.password = updatedOptions.password;
                }
                this.redirectUrls.push(redirectUrl);
                updatedOptions.prefixUrl = "";
                updatedOptions.url = redirectUrl;
                for (const hook of updatedOptions.hooks.beforeRedirect)// eslint-disable-next-line no-await-in-loop
                await hook(updatedOptions, typedResponse);
                this.emit("redirect", updatedOptions, typedResponse);
                this.options = updatedOptions;
                await this._makeRequest();
            } catch (error) {
                this._beforeError(error);
                return;
            }
            return;
        }
        // `HTTPError`s always have `error.response.body` defined.
        // Therefore we cannot retry if `options.throwHttpErrors` is false.
        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,
        // but that wouldn't be possible since the body would be already read in `error.response.body`.
        if (options.isStream && options.throwHttpErrors && !(0, $55c0d93679690b5b$export$746ebf9e39b71511)(typedResponse)) {
            this._beforeError(new (0, $a5bde8c0d43bf4db$export$aa9d629c530f62a7)(typedResponse));
            return;
        }
        response.on("readable", ()=>{
            if (this._triggerRead) this._read();
        });
        this.on("resume", ()=>{
            response.resume();
        });
        this.on("pause", ()=>{
            response.pause();
        });
        response.once("end", ()=>{
            this.push(null);
        });
        if (this._noPipe) {
            const success = await this._setRawBody();
            if (success) this.emit("response", response);
            return;
        }
        this.emit("response", response);
        for (const destination of this._pipedServerResponses){
            if (destination.headersSent) continue;
            // eslint-disable-next-line guard-for-in
            for(const key in response.headers){
                const isAllowed = options.decompress ? key !== "content-encoding" : true;
                const value = response.headers[key];
                if (isAllowed) destination.setHeader(key, value);
            }
            destination.statusCode = statusCode;
        }
    }
    async _setRawBody(from = this) {
        if (from.readableEnded) return false;
        try {
            // Errors are emitted via the `error` event
            const rawBody = await $851c2383dc8b8638$var$getBuffer(from);
            // On retry Request is destroyed with no error, therefore the above will successfully resolve.
            // So in order to check if this was really successfull, we need to check if it has been properly ended.
            if (!this.isAborted) {
                this.response.rawBody = rawBody;
                return true;
            }
        } catch  {}
        return false;
    }
    async _onResponse(response) {
        try {
            await this._onResponseBase(response);
        } catch (error) {
            /* istanbul ignore next: better safe than sorry */ this._beforeError(error);
        }
    }
    _onRequest(request) {
        const { options: options } = this;
        const { timeout: timeout, url: url } = options;
        (0, $263dfae12a4c70a4$export$2e2bcd8739ae039)(request);
        if (this.options.http2) // Unset stream timeout, as the `timeout` option was used only for connection timeout.
        request.setTimeout(0);
        this._cancelTimeouts = (0, $2ffcdd5ca9812885$export$2e2bcd8739ae039)(request, timeout, url);
        const responseEventName = options.cache ? "cacheableResponse" : "response";
        request.once(responseEventName, (response)=>{
            this._onResponse(response);
        });
        request.once("error", (error)=>{
            this._aborted = true;
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            error = error instanceof (0, $2ffcdd5ca9812885$export$66d311bf29d5c89c) ? new (0, $a5bde8c0d43bf4db$export$66d311bf29d5c89c)(error, this.timings, this) : new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)(error.message, error, this);
            this._beforeError(error);
        });
        this._unproxyEvents = (0, $1ee1def4a53dcdc4$export$2e2bcd8739ae039)(request, this, $851c2383dc8b8638$var$proxiedRequestEvents);
        this._request = request;
        this.emit("uploadProgress", this.uploadProgress);
        this._sendBody();
        this.emit("request", request);
    }
    async _asyncWrite(chunk) {
        return new Promise((resolve, reject)=>{
            super.write(chunk, (error)=>{
                if (error) {
                    reject(error);
                    return;
                }
                resolve();
            });
        });
    }
    _sendBody() {
        // Send body
        const { body: body } = this.options;
        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body)) body.pipe(currentRequest);
        else if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).generator(body) || (0, $23048e7f833b5d93$export$2e2bcd8739ae039).asyncGenerator(body)) (async ()=>{
            try {
                for await (const chunk of body)await this._asyncWrite(chunk);
                super.end();
            } catch (error) {
                this._beforeError(error);
            }
        })();
        else if (!(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(body)) {
            this._writeRequest(body, undefined, ()=>{});
            currentRequest.end();
        } else if (this._cannotHaveBody || this._noPipe) currentRequest.end();
    }
    _prepareCache(cache) {
        if (!$851c2383dc8b8638$var$cacheableStore.has(cache)) {
            const cacheableRequest = new (0, $a6de8cfd72a6dad5$export$2e2bcd8739ae039)((requestOptions, handler)=>{
                const result = requestOptions._request(requestOptions, handler);
                // TODO: remove this when `cacheable-request` supports async request functions.
                if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(result)) // We only need to implement the error handler in order to support HTTP2 caching.
                // The result will be a promise anyway.
                // @ts-expect-error ignore
                // eslint-disable-next-line @typescript-eslint/promise-function-async
                result.once = (event, handler)=>{
                    if (event === "error") (async ()=>{
                        try {
                            await result;
                        } catch (error) {
                            handler(error);
                        }
                    })();
                    else if (event === "abort") // The empty catch is needed here in case when
                    // it rejects before it's `await`ed in `_makeRequest`.
                    (async ()=>{
                        try {
                            const request = await result;
                            request.once("abort", handler);
                        } catch  {}
                    })();
                    else /* istanbul ignore next: safety check */ throw new Error(`Unknown HTTP2 promise event: ${event}`);
                    return result;
                };
                return result;
            }, cache);
            $851c2383dc8b8638$var$cacheableStore.set(cache, cacheableRequest.request());
        }
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject)=>{
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, (0, $d96cf451135558de$export$2e2bcd8739ae039)(url));
            let request;
            // TODO: Fix `cacheable-response`. This is ugly.
            const cacheRequest = $851c2383dc8b8638$var$cacheableStore.get(options.cache)(options, async (response)=>{
                response._readableState.autoDestroy = false;
                if (request) {
                    const fix = ()=>{
                        if (response.req) response.complete = response.req.res.complete;
                    };
                    response.prependOnceListener("end", fix);
                    fix();
                    (await request).emit("cacheableResponse", response);
                }
                resolve(response);
            });
            cacheRequest.once("error", reject);
            cacheRequest.once("request", async (requestOrPromise)=>{
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        const { options: options } = this;
        const { headers: headers, username: username, password: password } = options;
        const cookieJar = options.cookieJar;
        for(const key in headers){
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers[key])) // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete headers[key];
            else if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).null_(headers[key])) throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
        }
        if (options.decompress && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers["accept-encoding"])) headers["accept-encoding"] = $851c2383dc8b8638$var$supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
        if (username || password) {
            const credentials = (0, $dAk3n$nodebuffer.Buffer).from(`${username}:${password}`).toString("base64");
            headers.authorization = `Basic ${credentials}`;
        }
        // Set cookies
        if (cookieJar) {
            const cookieString = await cookieJar.getCookieString(options.url.toString());
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nonEmptyString(cookieString)) headers.cookie = cookieString;
        }
        // Reset `prefixUrl`
        options.prefixUrl = "";
        let request;
        for (const hook of options.hooks.beforeRequest){
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options);
            if (!(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(result)) {
                // @ts-expect-error Skip the type mismatch to support abstract responses
                request = ()=>result;
                break;
            }
        }
        if (!request) request = options.getRequestFunction();
        const url = options.url;
        this._requestOptions = options.createNativeRequestOptions();
        if (options.cache) {
            this._requestOptions._request = request;
            this._requestOptions.cache = options.cache;
            this._requestOptions.body = options.body;
            this._prepareCache(options.cache);
        }
        // Cache support
        const fn = options.cache ? this._createCacheableRequest : request;
        try {
            // We can't do `await fn(...)`,
            // because stream `error` event can be emitted before `Promise.resolve()`.
            let requestOrResponse = fn(url, this._requestOptions);
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(requestOrResponse)) requestOrResponse = await requestOrResponse;
            // Fallback
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(requestOrResponse)) {
                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
                if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(requestOrResponse)) requestOrResponse = await requestOrResponse;
            }
            if ((0, $8d86e64dbd681a61$export$2e2bcd8739ae039)(requestOrResponse)) this._onRequest(requestOrResponse);
            else if (this.writable) {
                this.once("finish", ()=>{
                    this._onResponse(requestOrResponse);
                });
                this._sendBody();
            } else this._onResponse(requestOrResponse);
        } catch (error) {
            if (error instanceof (0, $0cd45e613d0af170$export$78ff06e91c3de382)) throw new (0, $a5bde8c0d43bf4db$export$78ff06e91c3de382)(error, this);
            throw error;
        }
    }
    async _error(error) {
        try {
            if (error instanceof (0, $a5bde8c0d43bf4db$export$aa9d629c530f62a7) && !this.options.throwHttpErrors) ;
            else for (const hook of this.options.hooks.beforeError)// eslint-disable-next-line no-await-in-loop
            error = await hook(error);
        } catch (error_) {
            error = new (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743)(error_.message, error_, this);
        }
        this.destroy(error);
    }
    _writeRequest(chunk, encoding, callback) {
        if (!this._request || this._request.destroyed) // Probably the `ClientRequest` instance will throw
        return;
        this._request.write(chunk, encoding, (error)=>{
            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed
            if (!error && !this._request.destroyed) {
                this._uploadedSize += (0, $dAk3n$nodebuffer.Buffer).byteLength(chunk, encoding);
                const progress = this.uploadProgress;
                if (progress.percent < 1) this.emit("uploadProgress", progress);
            }
            callback(error);
        });
    }
    /**
    The remote IP address.
    */ get ip() {
        return this.socket?.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */ get isAborted() {
        return this._aborted;
    }
    get socket() {
        return this._request?.socket ?? undefined;
    }
    /**
    Progress event for downloading (receiving a response).
    */ get downloadProgress() {
        let percent;
        if (this._responseSize) percent = this._downloadedSize / this._responseSize;
        else if (this._responseSize === this._downloadedSize) percent = 1;
        else percent = 0;
        return {
            percent: percent,
            transferred: this._downloadedSize,
            total: this._responseSize
        };
    }
    /**
    Progress event for uploading (sending a request).
    */ get uploadProgress() {
        let percent;
        if (this._bodySize) percent = this._uploadedSize / this._bodySize;
        else if (this._bodySize === this._uploadedSize) percent = 1;
        else percent = 0;
        return {
            percent: percent,
            transferred: this._uploadedSize,
            total: this._bodySize
        };
    }
    /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */ get timings() {
        return this._request?.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */ get isFromCache() {
        return this._isFromCache;
    }
    get reusedSocket() {
        return this._request?.reusedSocket;
    }
}





class $e53308922576e4f6$export$d7f5e52d091a66db extends (0, $a5bde8c0d43bf4db$export$43ee7d0e4f429743) {
    constructor(request){
        super("Promise was canceled", {}, request);
        this.name = "CancelError";
        this.code = "ERR_CANCELED";
    }
    /**
    Whether the promise is canceled.
    */ get isCanceled() {
        return true;
    }
}


const $f187b15db470e6bb$var$proxiedRequestEvents = [
    "request",
    "response",
    "redirect",
    "uploadProgress",
    "downloadProgress"
];
function $f187b15db470e6bb$export$2e2bcd8739ae039(firstRequest) {
    let globalRequest;
    let globalResponse;
    let normalizedOptions;
    const emitter = new (0, $dAk3n$nodeevents.EventEmitter)();
    const promise = new (0, $9f256715eaead164$export$2e2bcd8739ae039)((resolve, reject, onCancel)=>{
        onCancel(()=>{
            globalRequest.destroy();
        });
        onCancel.shouldReject = false;
        onCancel(()=>{
            reject(new (0, $e53308922576e4f6$export$d7f5e52d091a66db)(globalRequest));
        });
        const makeRequest = (retryCount)=>{
            // Errors when a new request is made after the promise settles.
            // Used to detect a race condition.
            // See https://github.com/sindresorhus/got/issues/1489
            onCancel(()=>{});
            const request = firstRequest ?? new (0, $851c2383dc8b8638$export$2e2bcd8739ae039)(undefined, undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            globalRequest = request;
            request.once("response", async (response)=>{
                // Parse body
                const contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase();
                const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br";
                const { options: options } = request;
                if (isCompressed && !options.decompress) response.body = response.rawBody;
                else try {
                    response.body = (0, $55c0d93679690b5b$export$3b629cd0ff482602)(response, options.responseType, options.parseJson, options.encoding);
                } catch (error) {
                    // Fall back to `utf8`
                    response.body = response.rawBody.toString();
                    if ((0, $55c0d93679690b5b$export$746ebf9e39b71511)(response)) {
                        request._beforeError(error);
                        return;
                    }
                }
                try {
                    const hooks = options.hooks.afterResponse;
                    for (const [index, hook] of hooks.entries()){
                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions)=>{
                            options.merge(updatedOptions);
                            options.prefixUrl = "";
                            if (updatedOptions.url) options.url = updatedOptions.url;
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
                            throw new (0, $a5bde8c0d43bf4db$export$aa6cf8a4f695f0ee)(request);
                        });
                        if (!((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(response) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number(response.statusCode) && !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).nullOrUndefined(response.body))) throw new TypeError("The `afterResponse` hook returned an invalid value");
                    }
                } catch (error) {
                    request._beforeError(error);
                    return;
                }
                globalResponse = response;
                if (!(0, $55c0d93679690b5b$export$746ebf9e39b71511)(response)) {
                    request._beforeError(new (0, $a5bde8c0d43bf4db$export$aa9d629c530f62a7)(response));
                    return;
                }
                request.destroy();
                resolve(request.options.resolveBodyOnly ? response.body : response);
            });
            const onError = (error)=>{
                if (promise.isCanceled) return;
                const { options: options } = request;
                if (error instanceof (0, $a5bde8c0d43bf4db$export$aa9d629c530f62a7) && !options.throwHttpErrors) {
                    const { response: response } = error;
                    request.destroy();
                    resolve(request.options.resolveBodyOnly ? response.body : response);
                    return;
                }
                reject(error);
            };
            request.once("error", onError);
            const previousBody = request.options?.body;
            request.once("retry", (newRetryCount, error)=>{
                firstRequest = undefined;
                const newBody = request.options.body;
                if (previousBody === newBody && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(newBody)) {
                    error.message = "Cannot retry with consumed body stream";
                    onError(error);
                    return;
                }
                // This is needed! We need to reuse `request.options` because they can get modified!
                // For example, by calling `promise.json()`.
                normalizedOptions = request.options;
                makeRequest(newRetryCount);
            });
            (0, $1ee1def4a53dcdc4$export$2e2bcd8739ae039)(request, emitter, $f187b15db470e6bb$var$proxiedRequestEvents);
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(firstRequest)) request.flush();
        };
        makeRequest(0);
    });
    promise.on = (event, fn)=>{
        emitter.on(event, fn);
        return promise;
    };
    promise.off = (event, fn)=>{
        emitter.off(event, fn);
        return promise;
    };
    const shortcut = (responseType)=>{
        const newPromise = (async ()=>{
            // Wait until downloading has ended
            await promise;
            const { options: options } = globalResponse.request;
            return (0, $55c0d93679690b5b$export$3b629cd0ff482602)(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
    };
    promise.json = ()=>{
        if (globalRequest.options) {
            const { headers: headers } = globalRequest.options;
            if (!globalRequest.writableFinished && !("accept" in headers)) headers.accept = "application/json";
        }
        return shortcut("json");
    };
    promise.buffer = ()=>shortcut("buffer");
    promise.text = ()=>shortcut("text");
    return promise;
}




// The `delay` package weighs 10KB (!)
const $3c428c9fac89c79e$var$delay = async (ms)=>new Promise((resolve)=>{
        setTimeout(resolve, ms);
    });
const $3c428c9fac89c79e$var$isGotInstance = (value)=>(0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_(value);
const $3c428c9fac89c79e$var$aliases = [
    "get",
    "post",
    "put",
    "patch",
    "head",
    "delete"
];
const $3c428c9fac89c79e$var$create = (defaults)=>{
    defaults = {
        options: new (0, $50d8a008d62bdd46$export$2e2bcd8739ae039)(undefined, undefined, defaults.options),
        handlers: [
            ...defaults.handlers
        ],
        mutableDefaults: defaults.mutableDefaults
    };
    Object.defineProperty(defaults, "mutableDefaults", {
        enumerable: true,
        configurable: false,
        writable: false
    });
    // Got interface
    const got = (url, options, defaultOptions = defaults.options)=>{
        const request = new (0, $851c2383dc8b8638$export$2e2bcd8739ae039)(url, options, defaultOptions);
        let promise;
        const lastHandler = (normalized)=>{
            // Note: `options` is `undefined` when `new Options(...)` fails
            request.options = normalized;
            request._noPipe = !normalized.isStream;
            request.flush();
            if (normalized.isStream) return request;
            if (!promise) promise = (0, $f187b15db470e6bb$export$2e2bcd8739ae039)(request);
            return promise;
        };
        let iteration = 0;
        const iterateHandlers = (newOptions)=>{
            const handler = defaults.handlers[iteration++] ?? lastHandler;
            const result = handler(newOptions, iterateHandlers);
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(result) && !request.options.isStream) {
                if (!promise) promise = (0, $f187b15db470e6bb$export$2e2bcd8739ae039)(request);
                if (result !== promise) {
                    const descriptors = Object.getOwnPropertyDescriptors(promise);
                    for(const key in descriptors)if (key in result) // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete descriptors[key];
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Object.defineProperties(result, descriptors);
                    result.cancel = promise.cancel;
                }
            }
            return result;
        };
        return iterateHandlers(request.options);
    };
    got.extend = (...instancesOrOptions)=>{
        const options = new (0, $50d8a008d62bdd46$export$2e2bcd8739ae039)(undefined, undefined, defaults.options);
        const handlers = [
            ...defaults.handlers
        ];
        let mutableDefaults;
        for (const value of instancesOrOptions)if ($3c428c9fac89c79e$var$isGotInstance(value)) {
            options.merge(value.defaults.options);
            handlers.push(...value.defaults.handlers);
            mutableDefaults = value.defaults.mutableDefaults;
        } else {
            options.merge(value);
            if (value.handlers) handlers.push(...value.handlers);
            mutableDefaults = value.mutableDefaults;
        }
        return $3c428c9fac89c79e$var$create({
            options: options,
            handlers: handlers,
            mutableDefaults: Boolean(mutableDefaults)
        });
    };
    // Pagination
    const paginateEach = async function*(url, options) {
        let normalizedOptions = new (0, $50d8a008d62bdd46$export$2e2bcd8739ae039)(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const { pagination: pagination } = normalizedOptions;
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.transform);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.shouldContinue);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.filter);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.paginate);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(pagination.countLimit);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(pagination.requestLimit);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(pagination.backoff);
        const allItems = [];
        let { countLimit: countLimit } = pagination;
        let numberOfRequests = 0;
        while(numberOfRequests < pagination.requestLimit){
            if (numberOfRequests !== 0) // eslint-disable-next-line no-await-in-loop
            await $3c428c9fac89c79e$var$delay(pagination.backoff);
            // eslint-disable-next-line no-await-in-loop
            const response = await got(undefined, undefined, normalizedOptions);
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(response);
            const currentItems = [];
            (0, $23048e7f833b5d93$export$a7a9523472993e97).array(parsed);
            for (const item of parsed)if (pagination.filter({
                item: item,
                currentItems: currentItems,
                allItems: allItems
            })) {
                if (!pagination.shouldContinue({
                    item: item,
                    currentItems: currentItems,
                    allItems: allItems
                })) return;
                yield item;
                if (pagination.stackAllItems) allItems.push(item);
                currentItems.push(item);
                if (--countLimit <= 0) return;
            }
            const optionsToMerge = pagination.paginate({
                response: response,
                currentItems: currentItems,
                allItems: allItems
            });
            if (optionsToMerge === false) return;
            if (optionsToMerge === response.request.options) normalizedOptions = response.request.options;
            else {
                normalizedOptions.merge(optionsToMerge);
                (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                    (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance,
                    (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
                ], optionsToMerge.url);
                if (optionsToMerge.url !== undefined) {
                    normalizedOptions.prefixUrl = "";
                    normalizedOptions.url = optionsToMerge.url;
                }
            }
            numberOfRequests++;
        }
    };
    got.paginate = paginateEach;
    got.paginate.all = async (url, options)=>{
        const results = [];
        for await (const item of paginateEach(url, options))results.push(item);
        return results;
    };
    // For those who like very descriptive names
    got.paginate.each = paginateEach;
    // Stream API
    got.stream = (url, options)=>got(url, {
            ...options,
            isStream: true
        });
    // Shortcuts
    for (const method of $3c428c9fac89c79e$var$aliases){
        got[method] = (url, options)=>got(url, {
                ...options,
                method: method
            });
        got.stream[method] = (url, options)=>got(url, {
                ...options,
                method: method,
                isStream: true
            });
    }
    if (!defaults.mutableDefaults) {
        Object.freeze(defaults.handlers);
        defaults.options.freeze();
    }
    Object.defineProperty(got, "defaults", {
        value: defaults,
        writable: false,
        configurable: false,
        enumerable: true
    });
    return got;
};
var $3c428c9fac89c79e$export$2e2bcd8739ae039 = $3c428c9fac89c79e$var$create;










const $466d778d0565266d$var$defaults = {
    options: new (0, $50d8a008d62bdd46$export$2e2bcd8739ae039)(),
    handlers: [],
    mutableDefaults: false
};
const $466d778d0565266d$export$9ce08dfff6f4564a = (0, $3c428c9fac89c79e$export$2e2bcd8739ae039)($466d778d0565266d$var$defaults);
var $466d778d0565266d$export$2e2bcd8739ae039 = $466d778d0565266d$export$9ce08dfff6f4564a;


var $0769a1c12bb8a940$exports = {};
var $06870d2b49978634$export$98e6a39c04603d36;
var $06870d2b49978634$export$c2a28f090bb0afd6;
var $06870d2b49978634$export$7b419323e6ed4f31;
var $06870d2b49978634$export$a7b6bc01c63cdfc3;
var $06870d2b49978634$export$71aa6c912b956294;
"use strict";

var $3c5cae8aecb8625e$export$98e6a39c04603d36;
var $3c5cae8aecb8625e$export$2f872c0f2117be69;
var $3c5cae8aecb8625e$export$fac44ee5b035f737;
var $3c5cae8aecb8625e$export$c564cdbbe6da493;
var $3c5cae8aecb8625e$export$170b8c323eee7bec;
var $3c5cae8aecb8625e$export$aa1c11b655786597;
$3c5cae8aecb8625e$export$98e6a39c04603d36 = $3c5cae8aecb8625e$export$2f872c0f2117be69 = $3c5cae8aecb8625e$var$decode;
$3c5cae8aecb8625e$export$fac44ee5b035f737 = $3c5cae8aecb8625e$export$c564cdbbe6da493 = $3c5cae8aecb8625e$var$encode;
$3c5cae8aecb8625e$export$170b8c323eee7bec = $3c5cae8aecb8625e$var$safe;
$3c5cae8aecb8625e$export$aa1c11b655786597 = $3c5cae8aecb8625e$var$unsafe;
var $3c5cae8aecb8625e$var$eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
function $3c5cae8aecb8625e$var$encode(obj, opt) {
    var children = [];
    var out = "";
    if (typeof opt === "string") opt = {
        section: opt,
        whitespace: false
    };
    else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? " = " : "=";
    Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) val.forEach(function(item) {
            out += $3c5cae8aecb8625e$var$safe(k + "[]") + separator + $3c5cae8aecb8625e$var$safe(item) + "\n";
        });
        else if (val && typeof val === "object") children.push(k);
        else out += $3c5cae8aecb8625e$var$safe(k) + separator + $3c5cae8aecb8625e$var$safe(val) + $3c5cae8aecb8625e$var$eol;
    });
    if (opt.section && out.length) out = "[" + $3c5cae8aecb8625e$var$safe(opt.section) + "]" + $3c5cae8aecb8625e$var$eol + out;
    children.forEach(function(k, _, __) {
        var nk = $3c5cae8aecb8625e$var$dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = $3c5cae8aecb8625e$var$encode(obj[k], {
            section: section,
            whitespace: opt.whitespace
        });
        if (out.length && child.length) out += $3c5cae8aecb8625e$var$eol;
        out += child;
    });
    return out;
}
function $3c5cae8aecb8625e$var$dotSplit(str) {
    return str.replace(/\1/g, "\x02LITERAL\\1LITERAL\x02").replace(/\\\./g, "\x01").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "\x01");
    });
}
function $3c5cae8aecb8625e$var$decode(str) {
    var out = {};
    var p = out;
    var section = null;
    //          section     |key      = value
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/)) return;
        var match = line.match(re);
        if (!match) return;
        if (match[1] !== undefined) {
            section = $3c5cae8aecb8625e$var$unsafe(match[1]);
            if (section === "__proto__") {
                // not allowed
                // keep parsing the section, but don't attach it.
                p = {};
                return;
            }
            p = out[section] = out[section] || {};
            return;
        }
        var key = $3c5cae8aecb8625e$var$unsafe(match[2]);
        if (key === "__proto__") return;
        var value = match[3] ? $3c5cae8aecb8625e$var$unsafe(match[4]) : true;
        switch(value){
            case "true":
            case "false":
            case "null":
                value = JSON.parse(value);
        }
        // Convert keys with '[]' suffix to an array
        if (key.length > 2 && key.slice(-2) === "[]") {
            key = key.substring(0, key.length - 2);
            if (key === "__proto__") return;
            if (!p[key]) p[key] = [];
            else if (!Array.isArray(p[key])) p[key] = [
                p[key]
            ];
        }
        // safeguard against resetting a previously defined
        // array by accidentally forgetting the brackets
        if (Array.isArray(p[key])) p[key].push(value);
        else p[key] = value;
    });
    // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
    // use a filter to return the keys that have to be deleted.
    Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) return false;
        // see if the parent section is also an object.
        // if so, add it to that, and mark this one for deletion
        var parts = $3c5cae8aecb8625e$var$dotSplit(k);
        var p = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _, __) {
            if (part === "__proto__") return;
            if (!p[part] || typeof p[part] !== "object") p[part] = {};
            p = p[part];
        });
        if (p === out && nl === l) return false;
        p[nl] = out[k];
        return true;
    }).forEach(function(del, _, __) {
        delete out[del];
    });
    return out;
}
function $3c5cae8aecb8625e$var$isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
}
function $3c5cae8aecb8625e$var$safe(val) {
    return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && $3c5cae8aecb8625e$var$isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
}
function $3c5cae8aecb8625e$var$unsafe(val, doUnesc) {
    val = (val || "").trim();
    if ($3c5cae8aecb8625e$var$isQuoted(val)) {
        // remove the single quotes before calling JSON.parse
        if (val.charAt(0) === "'") val = val.substr(1, val.length - 2);
        try {
            val = JSON.parse(val);
        } catch (_) {}
    } else {
        // walk the val to find the first not-escaped ; character
        var esc = false;
        var unesc = "";
        for(var i = 0, l = val.length; i < l; i++){
            var c = val.charAt(i);
            if (esc) {
                if ("\\;#".indexOf(c) !== -1) unesc += c;
                else unesc += "\\" + c;
                esc = false;
            } else if (";#".indexOf(c) !== -1) break;
            else if (c === "\\") esc = true;
            else unesc += c;
        }
        if (esc) unesc += "\\";
        return unesc.trim();
    }
    return val;
}



var $75158f2f034390ae$exports = {};
"use strict";
var $75158f2f034390ae$var$singleComment = 1;
var $75158f2f034390ae$var$multiComment = 2;
function $75158f2f034390ae$var$stripWithoutWhitespace() {
    return "";
}
function $75158f2f034390ae$var$stripWithWhitespace(str, start, end) {
    return str.slice(start, end).replace(/\S/g, " ");
}
$75158f2f034390ae$exports = function(str, opts) {
    opts = opts || {};
    var currentChar;
    var nextChar;
    var insideString = false;
    var insideComment = false;
    var offset = 0;
    var ret = "";
    var strip = opts.whitespace === false ? $75158f2f034390ae$var$stripWithoutWhitespace : $75158f2f034390ae$var$stripWithWhitespace;
    for(var i = 0; i < str.length; i++){
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
            var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
            if (!escaped) insideString = !insideString;
        }
        if (insideString) continue;
        if (!insideComment && currentChar + nextChar === "//") {
            ret += str.slice(offset, i);
            offset = i;
            insideComment = $75158f2f034390ae$var$singleComment;
            i++;
        } else if (insideComment === $75158f2f034390ae$var$singleComment && currentChar + nextChar === "\r\n") {
            i++;
            insideComment = false;
            ret += strip(str, offset, i);
            offset = i;
            continue;
        } else if (insideComment === $75158f2f034390ae$var$singleComment && currentChar === "\n") {
            insideComment = false;
            ret += strip(str, offset, i);
            offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
            ret += str.slice(offset, i);
            offset = i;
            insideComment = $75158f2f034390ae$var$multiComment;
            i++;
            continue;
        } else if (insideComment === $75158f2f034390ae$var$multiComment && currentChar + nextChar === "*/") {
            i++;
            insideComment = false;
            ret += strip(str, offset, i + 1);
            offset = i + 1;
            continue;
        }
    }
    return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
};


var $06870d2b49978634$var$parse = $06870d2b49978634$export$98e6a39c04603d36 = function(content) {
    //if it ends in .json or starts with { then it must be json.
    //must be done this way, because ini accepts everything.
    //can't just try and parse it and let it throw if it's not ini.
    //everything is ini. even json with a syntax error.
    if (/^\s*{/.test(content)) return JSON.parse($75158f2f034390ae$exports(content));
    return $3c5cae8aecb8625e$export$98e6a39c04603d36(content);
};
var $06870d2b49978634$var$file = $06870d2b49978634$export$c2a28f090bb0afd6 = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
    });
    //path.join breaks if it's a not a string, so just skip this.
    for(var i in args)if ("string" !== typeof args[i]) return;
    var file = $dAk3n$path.join.apply(null, args);
    var content;
    try {
        return $dAk3n$fs.readFileSync(file, "utf-8");
    } catch (err) {
        return;
    }
};
var $06870d2b49978634$var$json = $06870d2b49978634$export$7b419323e6ed4f31 = function() {
    var content = $06870d2b49978634$var$file.apply(null, arguments);
    return content ? $06870d2b49978634$var$parse(content) : null;
};
var $06870d2b49978634$var$env = $06870d2b49978634$export$a7b6bc01c63cdfc3 = function(prefix, env) {
    env = env || process.env;
    var obj = {};
    var l = prefix.length;
    for(var k in env)if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
        var keypath = k.substring(l).split("__");
        // Trim empty strings from keypath array
        var _emptyStringIndex;
        while((_emptyStringIndex = keypath.indexOf("")) > -1)keypath.splice(_emptyStringIndex, 1);
        var cursor = obj;
        keypath.forEach(function _buildSubObj(_subkey, i) {
            // (check for _subkey first so we ignore empty strings)
            // (check for cursor to avoid assignment to primitive objects)
            if (!_subkey || typeof cursor !== "object") return;
            // If this is the last key, just stuff the value in there
            // Assigns actual value from env variable to final key
            // (unless it's just an empty string- in that case use the last valid key)
            if (i === keypath.length - 1) cursor[_subkey] = env[k];
            // Build sub-object if nothing already exists at the keypath
            if (cursor[_subkey] === undefined) cursor[_subkey] = {};
            // Increment cursor used to track the object at the current depth
            cursor = cursor[_subkey];
        });
    }
    return obj;
};
var $06870d2b49978634$var$find = $06870d2b49978634$export$71aa6c912b956294 = function() {
    var rel = $dAk3n$path.join.apply(null, [].slice.call(arguments));
    function find(start, rel) {
        var file = $dAk3n$path.join(start, rel);
        try {
            $dAk3n$fs.statSync(file);
            return file;
        } catch (err) {
            if ($dAk3n$path.dirname(start) !== start) return find($dAk3n$path.dirname(start), rel);
        }
    }
    return find(process.cwd(), rel);
};



var $0769a1c12bb8a940$require$join = $dAk3n$path.join;
var $e3800752717a7df1$exports = {};
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */ "use strict";
function $e3800752717a7df1$var$isSpecificValue(val) {
    return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
}
function $e3800752717a7df1$var$cloneSpecificValue(val) {
    if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
    } else if (val instanceof Date) return new Date(val.getTime());
    else if (val instanceof RegExp) return new RegExp(val);
    else throw new Error("Unexpected situation");
}
/**
 * Recursive cloning array.
 */ function $e3800752717a7df1$var$deepCloneArray(arr) {
    var clone = [];
    arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
            if (Array.isArray(item)) clone[index] = $e3800752717a7df1$var$deepCloneArray(item);
            else if ($e3800752717a7df1$var$isSpecificValue(item)) clone[index] = $e3800752717a7df1$var$cloneSpecificValue(item);
            else clone[index] = $e3800752717a7df1$var$deepExtend({}, item);
        } else clone[index] = item;
    });
    return clone;
}
function $e3800752717a7df1$var$safeGetProperty(object, property) {
    return property === "__proto__" ? undefined : object[property];
}
/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */ var $e3800752717a7df1$var$deepExtend = $e3800752717a7df1$exports = function() {
    if (arguments.length < 1 || typeof arguments[0] !== "object") return false;
    if (arguments.length < 2) return arguments[0];
    var target = arguments[0];
    // convert arguments to array and cut off target object
    var args = Array.prototype.slice.call(arguments, 1);
    var val, src, clone;
    args.forEach(function(obj) {
        // skip argument if isn't an object, is null, or is an array
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) return;
        Object.keys(obj).forEach(function(key) {
            src = $e3800752717a7df1$var$safeGetProperty(target, key); // source value
            val = $e3800752717a7df1$var$safeGetProperty(obj, key); // new value
            // recursion prevention
            if (val === target) return;
            else if (typeof val !== "object" || val === null) {
                target[key] = val;
                return;
            // just clone arrays (and recursive clone objects inside)
            } else if (Array.isArray(val)) {
                target[key] = $e3800752717a7df1$var$deepCloneArray(val);
                return;
            // custom cloning and overwrite for specific objects
            } else if ($e3800752717a7df1$var$isSpecificValue(val)) {
                target[key] = $e3800752717a7df1$var$cloneSpecificValue(val);
                return;
            // overwrite by new value if source isn't object or array
            } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
                target[key] = $e3800752717a7df1$var$deepExtend({}, val);
                return;
            // source value and new value is objects both, extending...
            } else {
                target[key] = $e3800752717a7df1$var$deepExtend(src, val);
                return;
            }
        });
    });
    return target;
};


var $0769a1c12bb8a940$var$etc = "/etc";
var $0769a1c12bb8a940$var$win = process.platform === "win32";
var $0769a1c12bb8a940$var$home = $0769a1c12bb8a940$var$win ? process.env.USERPROFILE : process.env.HOME;

$0769a1c12bb8a940$exports = function(name, defaults, argv, parse) {
    if ("string" !== typeof name) throw new Error("rc(name): name *must* be string");
    if (!argv) argv = (parcelRequire("a0xT4"))(process.argv.slice(2));
    defaults = ("string" === typeof defaults ? $06870d2b49978634$export$7b419323e6ed4f31(defaults) : defaults) || {};
    parse = parse || $06870d2b49978634$export$98e6a39c04603d36;
    var env = $06870d2b49978634$export$a7b6bc01c63cdfc3(name + "_");
    var configs = [
        defaults
    ];
    var configFiles = [];
    function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0) return;
        var fileConfig = $06870d2b49978634$export$c2a28f090bb0afd6(file);
        if (fileConfig) {
            configs.push(parse(fileConfig));
            configFiles.push(file);
        }
    }
    // which files do we look at?
    if (!$0769a1c12bb8a940$var$win) [
        $0769a1c12bb8a940$require$join($0769a1c12bb8a940$var$etc, name, "config"),
        $0769a1c12bb8a940$require$join($0769a1c12bb8a940$var$etc, name + "rc")
    ].forEach(addConfigFile);
    if ($0769a1c12bb8a940$var$home) [
        $0769a1c12bb8a940$require$join($0769a1c12bb8a940$var$home, ".config", name, "config"),
        $0769a1c12bb8a940$require$join($0769a1c12bb8a940$var$home, ".config", name),
        $0769a1c12bb8a940$require$join($0769a1c12bb8a940$var$home, "." + name, "config"),
        $0769a1c12bb8a940$require$join($0769a1c12bb8a940$var$home, "." + name + "rc")
    ].forEach(addConfigFile);
    addConfigFile($06870d2b49978634$export$71aa6c912b956294("." + name + "rc"));
    if (env.config) addConfigFile(env.config);
    if (argv.config) addConfigFile(argv.config);
    return $e3800752717a7df1$exports.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? {
            configs: configFiles,
            config: configFiles[configFiles.length - 1]
        } : undefined
    ]));
};


function $9f0f0be5e21eca3a$export$2e2bcd8739ae039(scope) {
    const result = (0, (/*@__PURE__*/$parcel$interopDefault($0769a1c12bb8a940$exports)))("npm", {
        registry: "https://registry.npmjs.org/"
    });
    const url = result[`${scope}:registry`] || result.config_registry || result.registry;
    return url.slice(-1) === "/" ? url : `${url}/`;
}


var $88ef39e7e8a3750c$exports = {};

var $f93dc2b45b1e9c9a$exports = {};
"use strict";

var $b29807dd97d8245f$exports = {};
"use strict";
var $70616e559d159ff9$exports = {};
"use strict";
var $70616e559d159ff9$var$__createBinding = $70616e559d159ff9$exports && $70616e559d159ff9$exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var $70616e559d159ff9$var$__exportStar = $70616e559d159ff9$exports && $70616e559d159ff9$exports.__exportStar || function(m, exports) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) $70616e559d159ff9$var$__createBinding(exports, m, p);
};
Object.defineProperty($70616e559d159ff9$exports, "__esModule", {
    value: true
});

$70616e559d159ff9$var$__exportStar((parcelRequire("h2kFo")), $70616e559d159ff9$exports);


var $b29807dd97d8245f$require$readCAFileSync = $70616e559d159ff9$exports.readCAFileSync;


var $56b289e070568af0$exports = {};

var $56b289e070568af0$var$$parcel$__dirname = $dAk3n$path.resolve(__dirname, "../../../../node_modules/.pnpm/config-chain@1.1.13/node_modules/config-chain");
var $7788db962ce7a5c8$exports = {};
$7788db962ce7a5c8$exports = $7788db962ce7a5c8$var$ProtoList;
function $7788db962ce7a5c8$var$setProto(obj, proto) {
    if (typeof Object.setPrototypeOf === "function") return Object.setPrototypeOf(obj, proto);
    else obj.__proto__ = proto;
}
function $7788db962ce7a5c8$var$ProtoList() {
    this.list = [];
    var root = null;
    Object.defineProperty(this, "root", {
        get: function() {
            return root;
        },
        set: function(r) {
            root = r;
            if (this.list.length) $7788db962ce7a5c8$var$setProto(this.list[this.list.length - 1], r);
        },
        enumerable: true,
        configurable: true
    });
}
$7788db962ce7a5c8$var$ProtoList.prototype = {
    get length () {
        return this.list.length;
    },
    get keys () {
        var k = [];
        for(var i in this.list[0])k.push(i);
        return k;
    },
    get snapshot () {
        var o = {};
        this.keys.forEach(function(k) {
            o[k] = this.get(k);
        }, this);
        return o;
    },
    get store () {
        return this.list[0];
    },
    push: function(obj) {
        if (typeof obj !== "object") obj = {
            valueOf: obj
        };
        if (this.list.length >= 1) $7788db962ce7a5c8$var$setProto(this.list[this.list.length - 1], obj);
        $7788db962ce7a5c8$var$setProto(obj, this.root);
        return this.list.push(obj);
    },
    pop: function() {
        if (this.list.length >= 2) $7788db962ce7a5c8$var$setProto(this.list[this.list.length - 2], this.root);
        return this.list.pop();
    },
    unshift: function(obj) {
        $7788db962ce7a5c8$var$setProto(obj, this.list[0] || this.root);
        return this.list.unshift(obj);
    },
    shift: function() {
        if (this.list.length === 1) $7788db962ce7a5c8$var$setProto(this.list[0], this.root);
        return this.list.shift();
    },
    get: function(key) {
        return this.list[0][key];
    },
    set: function(key, val, save) {
        if (!this.length) this.push({});
        if (save && this.list[0].hasOwnProperty(key)) this.push({});
        return this.list[0][key] = val;
    },
    forEach: function(fn, thisp) {
        for(var key in this.list[0])fn.call(thisp, key, this.list[0][key]);
    },
    slice: function() {
        return this.list.slice.apply(this.list, arguments);
    },
    splice: function() {
        // handle injections
        var ret = this.list.splice.apply(this.list, arguments);
        for(var i = 0, l = this.list.length; i < l; i++)$7788db962ce7a5c8$var$setProto(this.list[i], this.list[i + 1] || this.root);
        return ret;
    }
};






var $56b289e070568af0$require$EE = $dAk3n$events.EventEmitter;


var $56b289e070568af0$var$exports = $56b289e070568af0$exports = function() {
    var args = [].slice.call(arguments), conf = new $56b289e070568af0$var$ConfigChain();
    while(args.length){
        var a = args.shift();
        if (a) conf.push("string" === typeof a ? $56b289e070568af0$var$json(a) : a);
    }
    return conf;
};
//recursively find a file...
var $56b289e070568af0$var$find = $56b289e070568af0$var$exports.find = function() {
    var rel = $dAk3n$path.join.apply(null, [].slice.call(arguments));
    function find(start, rel) {
        var file = $dAk3n$path.join(start, rel);
        try {
            $dAk3n$fs.statSync(file);
            return file;
        } catch (err) {
            if ($dAk3n$path.dirname(start) !== start) return find($dAk3n$path.dirname(start), rel);
        }
    }
    return find($56b289e070568af0$var$$parcel$__dirname, rel);
};
var $56b289e070568af0$var$parse = $56b289e070568af0$var$exports.parse = function(content, file, type) {
    content = "" + content;
    // if we don't know what it is, try json and fall back to ini
    // if we know what it is, then it must be that.
    if (!type) try {
        return JSON.parse(content);
    } catch (er) {
        return $3c5cae8aecb8625e$export$98e6a39c04603d36(content);
    }
    else if (type === "json") {
        if (this.emit) try {
            return JSON.parse(content);
        } catch (er) {
            this.emit("error", er);
        }
        else return JSON.parse(content);
    } else return $3c5cae8aecb8625e$export$98e6a39c04603d36(content);
};
var $56b289e070568af0$var$json = $56b289e070568af0$var$exports.json = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
    });
    var file = $dAk3n$path.join.apply(null, args);
    var content;
    try {
        content = $dAk3n$fs.readFileSync(file, "utf-8");
    } catch (err) {
        return;
    }
    return $56b289e070568af0$var$parse(content, file, "json");
};
var $56b289e070568af0$var$env = $56b289e070568af0$var$exports.env = function(prefix, env) {
    env = env || process.env;
    var obj = {};
    var l = prefix.length;
    for(var k in env)if (k.indexOf(prefix) === 0) obj[k.substring(l)] = env[k];
    return obj;
};
$56b289e070568af0$var$exports.ConfigChain = $56b289e070568af0$var$ConfigChain;
function $56b289e070568af0$var$ConfigChain() {
    $56b289e070568af0$require$EE.apply(this);
    $7788db962ce7a5c8$exports.apply(this, arguments);
    this._awaiting = 0;
    this._saving = 0;
    this.sources = {};
}
// multi-inheritance-ish
var $56b289e070568af0$var$extras = {
    constructor: {
        value: $56b289e070568af0$var$ConfigChain
    }
};
Object.keys($56b289e070568af0$require$EE.prototype).forEach(function(k) {
    $56b289e070568af0$var$extras[k] = Object.getOwnPropertyDescriptor($56b289e070568af0$require$EE.prototype, k);
});
$56b289e070568af0$var$ConfigChain.prototype = Object.create($7788db962ce7a5c8$exports.prototype, $56b289e070568af0$var$extras);
$56b289e070568af0$var$ConfigChain.prototype.del = function(key, where) {
    // if not specified where, then delete from the whole chain, scorched
    // earth style
    if (where) {
        var target = this.sources[where];
        target = target && target.data;
        if (!target) return this.emit("error", new Error("not found " + where));
        delete target[key];
    } else for(var i = 0, l = this.list.length; i < l; i++)delete this.list[i][key];
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.set = function(key, value, where) {
    var target;
    if (where) {
        target = this.sources[where];
        target = target && target.data;
        if (!target) return this.emit("error", new Error("not found " + where));
    } else {
        target = this.list[0];
        if (!target) return this.emit("error", new Error("cannot set, no confs!"));
    }
    target[key] = value;
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.get = function(key, where) {
    if (where) {
        where = this.sources[where];
        if (where) where = where.data;
        if (where && Object.hasOwnProperty.call(where, key)) return where[key];
        return undefined;
    }
    return this.list[0][key];
};
$56b289e070568af0$var$ConfigChain.prototype.save = function(where, type, cb) {
    if (typeof type === "function") cb = type, type = null;
    var target = this.sources[where];
    if (!target || !(target.path || target.source) || !target.data) // TODO: maybe save() to a url target could be a PUT or something?
    // would be easy to swap out with a reddis type thing, too
    return this.emit("error", new Error("bad save target: " + where));
    if (target.source) {
        var pref = target.prefix || "";
        Object.keys(target.data).forEach(function(k) {
            target.source[pref + k] = target.data[k];
        });
        return this;
    }
    var type = type || target.type;
    var data = target.data;
    if (target.type === "json") data = JSON.stringify(data);
    else data = $3c5cae8aecb8625e$export$fac44ee5b035f737(data);
    this._saving++;
    $dAk3n$fs.writeFile(target.path, data, "utf8", (function(er) {
        this._saving--;
        if (er) {
            if (cb) return cb(er);
            else return this.emit("error", er);
        }
        if (this._saving === 0) {
            if (cb) cb();
            this.emit("save");
        }
    }).bind(this));
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.addFile = function(file, type, name) {
    name = name || file;
    var marker = {
        __source__: name
    };
    this.sources[name] = {
        path: file,
        type: type
    };
    this.push(marker);
    this._await();
    $dAk3n$fs.readFile(file, "utf8", (function(er, data) {
        if (er) this.emit("error", er);
        this.addString(data, file, type, marker);
    }).bind(this));
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.addEnv = function(prefix, env, name) {
    name = name || "env";
    var data = $56b289e070568af0$var$exports.env(prefix, env);
    this.sources[name] = {
        data: data,
        source: env,
        prefix: prefix
    };
    return this.add(data, name);
};
$56b289e070568af0$var$ConfigChain.prototype.addUrl = function(req, type, name) {
    this._await();
    var href = $dAk3n$url.format(req);
    name = name || href;
    var marker = {
        __source__: name
    };
    this.sources[name] = {
        href: href,
        type: type
    };
    this.push(marker);
    $dAk3n$http.request(req, (function(res) {
        var c = [];
        var ct = res.headers["content-type"];
        if (!type) {
            type = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null;
            marker.type = type;
        }
        res.on("data", c.push.bind(c)).on("end", (function() {
            this.addString(Buffer.concat(c), href, type, marker);
        }).bind(this)).on("error", this.emit.bind(this, "error"));
    }).bind(this)).on("error", this.emit.bind(this, "error")).end();
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.addString = function(data, file, type, marker) {
    data = this.parse(data, file, type);
    this.add(data, marker);
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.add = function(data, marker) {
    if (marker && typeof marker === "object") {
        var i = this.list.indexOf(marker);
        if (i === -1) return this.emit("error", new Error("bad marker"));
        this.splice(i, 1, data);
        marker = marker.__source__;
        this.sources[marker] = this.sources[marker] || {};
        this.sources[marker].data = data;
        // we were waiting for this.  maybe emit 'load'
        this._resolve();
    } else {
        if (typeof marker === "string") {
            this.sources[marker] = this.sources[marker] || {};
            this.sources[marker].data = data;
        }
        // trigger the load event if nothing was already going to do so.
        this._await();
        this.push(data);
        process.nextTick(this._resolve.bind(this));
    }
    return this;
};
$56b289e070568af0$var$ConfigChain.prototype.parse = $56b289e070568af0$var$exports.parse;
$56b289e070568af0$var$ConfigChain.prototype._await = function() {
    this._awaiting++;
};
$56b289e070568af0$var$ConfigChain.prototype._resolve = function() {
    this._awaiting--;
    if (this._awaiting === 0) this.emit("load", this);
};


var $b29807dd97d8245f$require$ConfigChain = $56b289e070568af0$exports.ConfigChain;
var $0a35d3b7efdac3cb$exports = {};
$0a35d3b7efdac3cb$exports = function(x) {
    const colonIndex = x.indexOf(":");
    if (colonIndex === -1) return $0a35d3b7efdac3cb$var$normalize(x);
    const firstPart = x.substr(0, colonIndex);
    const secondPart = x.substr(colonIndex + 1);
    return `${$0a35d3b7efdac3cb$var$normalize(firstPart)}:${$0a35d3b7efdac3cb$var$normalize(secondPart)}`;
};
function $0a35d3b7efdac3cb$var$normalize(s) {
    s = s.toLowerCase();
    if (s === "_authtoken") return "_authToken";
    let r = s[0];
    for(let i = 1; i < s.length; i++)r += s[i] === "_" ? "-" : s[i];
    return r;
}


var $284783b539dac1c0$export$7f5accf66bbfd23;
var $284783b539dac1c0$export$d623ebfd4290032d;
var $284783b539dac1c0$export$616eedde42a218b;
"use strict";


var $2e81fcfa3d80c53c$exports = {};
"use strict";
Object.defineProperty($2e81fcfa3d80c53c$exports, "__esModule", {
    value: true
});
$2e81fcfa3d80c53c$exports.envReplace = void 0;
var $2d9ea4fe113a7ed1$exports = {};
"use strict";
Object.defineProperty($2d9ea4fe113a7ed1$exports, "__esModule", {
    value: true
});
$2d9ea4fe113a7ed1$exports.envReplace = void 0;
const $2d9ea4fe113a7ed1$var$ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
function $2d9ea4fe113a7ed1$var$envReplace(settingValue, env) {
    return settingValue.replace($2d9ea4fe113a7ed1$var$ENV_EXPR, $2d9ea4fe113a7ed1$var$replaceEnvMatch.bind(null, env));
}
$2d9ea4fe113a7ed1$exports.envReplace = $2d9ea4fe113a7ed1$var$envReplace;
function $2d9ea4fe113a7ed1$var$replaceEnvMatch(env, orig, escape, name) {
    if (escape.length % 2) return orig.slice((escape.length + 1) / 2);
    const envValue = $2d9ea4fe113a7ed1$var$getEnvValue(env, name);
    if (envValue === undefined) throw new Error(`Failed to replace env in config: ${orig}`);
    return `${escape.slice(escape.length / 2)}${envValue}`;
}
const $2d9ea4fe113a7ed1$var$ENV_VALUE = /([^:-]+)(:?)-(.+)/;
function $2d9ea4fe113a7ed1$var$getEnvValue(env, name) {
    const matched = name.match($2d9ea4fe113a7ed1$var$ENV_VALUE);
    if (!matched) return env[name];
    const [, variableName, colon, fallback] = matched;
    if (Object.prototype.hasOwnProperty.call(env, variableName)) return !env[variableName] && colon ? fallback : env[variableName];
    return fallback;
}


Object.defineProperty($2e81fcfa3d80c53c$exports, "envReplace", {
    enumerable: true,
    get: function() {
        return $2d9ea4fe113a7ed1$exports.envReplace;
    }
});


var $284783b539dac1c0$require$envReplace = $2e81fcfa3d80c53c$exports.envReplace;
// https://github.com/npm/cli/blob/latest/lib/config/core.js#L359-L404
const $284783b539dac1c0$var$parseField = (types, field, key)=>{
    if (typeof field !== "string") return field;
    const typeList = [].concat(types[key]);
    const isPath = typeList.indexOf($dAk3n$path) !== -1;
    const isBool = typeList.indexOf(Boolean) !== -1;
    const isString = typeList.indexOf(String) !== -1;
    const isNumber = typeList.indexOf(Number) !== -1;
    field = `${field}`.trim();
    if (/^".*"$/.test(field)) try {
        field = JSON.parse(field);
    } catch (error) {
        throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
    }
    if (isBool && !isString && field === "") return true;
    switch(field){
        case "true":
            return true;
        case "false":
            return false;
        case "null":
            return null;
        case "undefined":
            return undefined;
    }
    field = $284783b539dac1c0$require$envReplace(field, process.env);
    if (isPath) {
        const regex = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
        if (regex.test(field) && process.env.HOME) field = $dAk3n$path.resolve(process.env.HOME, field.substr(2));
        field = $dAk3n$path.resolve(field);
    }
    if (isNumber && !isNaN(field)) field = Number(field);
    return field;
};
// https://github.com/npm/cli/blob/latest/lib/config/find-prefix.js
const $284783b539dac1c0$var$findPrefix = (name)=>{
    name = $dAk3n$path.resolve(name);
    let walkedUp = false;
    while($dAk3n$path.basename(name) === "node_modules"){
        name = $dAk3n$path.dirname(name);
        walkedUp = true;
    }
    if (walkedUp) return name;
    const find = (name, original)=>{
        const regex = /^[a-zA-Z]:(\\|\/)?$/;
        if (name === "/" || process.platform === "win32" && regex.test(name)) return original;
        try {
            const files = $dAk3n$fs.readdirSync(name);
            if (files.includes("node_modules") || files.includes("package.json") || files.includes("package.json5") || files.includes("package.yaml") || files.includes("pnpm-workspace.yaml")) return name;
            const dirname = $dAk3n$path.dirname(name);
            if (dirname === name) return original;
            return find(dirname, original);
        } catch (error) {
            if (name === original) {
                if (error.code === "ENOENT") return original;
                throw error;
            }
            return original;
        }
    };
    return find(name, name);
};
$284783b539dac1c0$export$7f5accf66bbfd23 = $284783b539dac1c0$require$envReplace;
$284783b539dac1c0$export$d623ebfd4290032d = $284783b539dac1c0$var$findPrefix;
$284783b539dac1c0$export$616eedde42a218b = $284783b539dac1c0$var$parseField;



class $b29807dd97d8245f$var$Conf extends $b29807dd97d8245f$require$ConfigChain {
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
    constructor(base, types){
        super(base);
        this.root = base;
        this._parseField = $284783b539dac1c0$export$616eedde42a218b.bind(null, types || (parcelRequire("4Dih0")));
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
    add(data, marker) {
        try {
            for (const x of Object.keys(data))data[x] = this._parseField(data[x], x);
        } catch (error) {
            throw error;
        }
        return super.add(data, marker);
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
    addFile(file, name) {
        name = name || file;
        const marker = {
            __source__: name
        };
        this.sources[name] = {
            path: file,
            type: "ini"
        };
        this.push(marker);
        this._await();
        try {
            const contents = $dAk3n$fs.readFileSync(file, "utf8");
            this.addString(contents, file, "ini", marker);
        } catch (error) {
            if (error.code === "ENOENT") this.add({}, marker);
            else return `Issue while reading "${file}". ${error.message}`;
        }
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
    addEnv(env) {
        env = env || process.env;
        const conf = {};
        Object.keys(env).filter((x)=>/^npm_config_/i.test(x)).forEach((x)=>{
            if (!env[x]) return;
            conf[$0a35d3b7efdac3cb$exports(x.substr(11))] = env[x];
        });
        return super.addEnv("", conf, "env");
    }
    // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
    loadPrefix() {
        const cli = this.list[0];
        Object.defineProperty(this, "prefix", {
            enumerable: true,
            set: (prefix)=>{
                const g = this.get("global");
                this[g ? "globalPrefix" : "localPrefix"] = prefix;
            },
            get: ()=>{
                const g = this.get("global");
                return g ? this.globalPrefix : this.localPrefix;
            }
        });
        Object.defineProperty(this, "globalPrefix", {
            enumerable: true,
            set: (prefix)=>{
                this.set("prefix", prefix);
            },
            get: ()=>{
                return $dAk3n$path.resolve(this.get("prefix"));
            }
        });
        let p;
        Object.defineProperty(this, "localPrefix", {
            enumerable: true,
            set: (prefix)=>{
                p = prefix;
            },
            get: ()=>{
                return p;
            }
        });
        if (Object.prototype.hasOwnProperty.call(cli, "prefix")) p = $dAk3n$path.resolve(cli.prefix);
        else try {
            const prefix = $284783b539dac1c0$export$d623ebfd4290032d(process.cwd());
            p = prefix;
        } catch (error) {
            throw error;
        }
        return p;
    }
    // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
    loadCAFile(file) {
        if (!file) return;
        const ca = $b29807dd97d8245f$require$readCAFileSync(file);
        if (ca) this.set("ca", ca);
    }
    // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
    loadUser() {
        const defConf = this.root;
        if (this.get("global")) return;
        if (process.env.SUDO_UID) {
            defConf.user = Number(process.env.SUDO_UID);
            return;
        }
        const prefix = $dAk3n$path.resolve(this.get("prefix"));
        try {
            const stats = $dAk3n$fs.statSync(prefix);
            defConf.user = stats.uid;
        } catch (error) {
            if (error.code === "ENOENT") return;
            throw error;
        }
    }
}
$b29807dd97d8245f$exports = $b29807dd97d8245f$var$Conf;


var $9c2514140ba47fd6$exports = {};
// Generated with `lib/make.js`
"use strict";


const $9c2514140ba47fd6$var$temp = $dAk3n$os.tmpdir();
const $9c2514140ba47fd6$var$uidOrPid = process.getuid ? process.getuid() : process.pid;
const $9c2514140ba47fd6$var$hasUnicode = ()=>true;
const $9c2514140ba47fd6$var$isWindows = process.platform === "win32";
const $9c2514140ba47fd6$var$osenv = {
    editor: ()=>process.env.EDITOR || process.env.VISUAL || ($9c2514140ba47fd6$var$isWindows ? "notepad.exe" : "vi"),
    shell: ()=>$9c2514140ba47fd6$var$isWindows ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
};
const $9c2514140ba47fd6$var$umask = {
    fromString: ()=>process.umask()
};
let $9c2514140ba47fd6$var$home = $dAk3n$os.homedir();
if ($9c2514140ba47fd6$var$home) process.env.HOME = $9c2514140ba47fd6$var$home;
else $9c2514140ba47fd6$var$home = $dAk3n$path.resolve($9c2514140ba47fd6$var$temp, "npm-" + $9c2514140ba47fd6$var$uidOrPid);
const $9c2514140ba47fd6$var$cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
const $9c2514140ba47fd6$var$cacheRoot = process.platform === "win32" && process.env.APPDATA || $9c2514140ba47fd6$var$home;
const $9c2514140ba47fd6$var$cache = $dAk3n$path.resolve($9c2514140ba47fd6$var$cacheRoot, $9c2514140ba47fd6$var$cacheExtra);
let $9c2514140ba47fd6$var$defaults;
let $9c2514140ba47fd6$var$globalPrefix;
Object.defineProperty($9c2514140ba47fd6$exports, "defaults", {
    get: function() {
        if ($9c2514140ba47fd6$var$defaults) return $9c2514140ba47fd6$var$defaults;
        if (process.env.PREFIX) $9c2514140ba47fd6$var$globalPrefix = process.env.PREFIX;
        else if (process.platform === "win32") // c:\node\node.exe --> prefix=c:\node\
        $9c2514140ba47fd6$var$globalPrefix = $dAk3n$path.dirname(process.execPath);
        else {
            // /usr/local/bin/node --> prefix=/usr/local
            $9c2514140ba47fd6$var$globalPrefix = $dAk3n$path.dirname($dAk3n$path.dirname(process.execPath)); // destdir only is respected on Unix
            if (process.env.DESTDIR) $9c2514140ba47fd6$var$globalPrefix = $dAk3n$path.join(process.env.DESTDIR, $9c2514140ba47fd6$var$globalPrefix);
        }
        $9c2514140ba47fd6$var$defaults = {
            access: null,
            "allow-same-version": false,
            "always-auth": false,
            also: null,
            audit: true,
            "auth-type": "legacy",
            "bin-links": true,
            browser: null,
            ca: null,
            cafile: null,
            cache: $9c2514140ba47fd6$var$cache,
            "cache-lock-stale": 60000,
            "cache-lock-retries": 10,
            "cache-lock-wait": 10000,
            "cache-max": Infinity,
            "cache-min": 10,
            cert: null,
            cidr: null,
            color: process.env.NO_COLOR == null,
            depth: Infinity,
            description: true,
            dev: false,
            "dry-run": false,
            editor: $9c2514140ba47fd6$var$osenv.editor(),
            "engine-strict": false,
            force: false,
            "fetch-retries": 2,
            "fetch-retry-factor": 10,
            "fetch-retry-mintimeout": 10000,
            "fetch-retry-maxtimeout": 60000,
            git: "git",
            "git-tag-version": true,
            "commit-hooks": true,
            global: false,
            globalconfig: $dAk3n$path.resolve($9c2514140ba47fd6$var$globalPrefix, "etc", "npmrc"),
            "global-style": false,
            group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
            "ham-it-up": false,
            heading: "npm",
            "if-present": false,
            "ignore-prepublish": false,
            "ignore-scripts": false,
            "init-module": $dAk3n$path.resolve($9c2514140ba47fd6$var$home, ".npm-init.js"),
            "init-author-name": "",
            "init-author-email": "",
            "init-author-url": "",
            "init-version": "1.0.0",
            "init-license": "ISC",
            json: false,
            key: null,
            "legacy-bundling": false,
            link: false,
            "local-address": undefined,
            loglevel: "notice",
            logstream: process.stderr,
            "logs-max": 10,
            long: false,
            maxsockets: 50,
            message: "%s",
            "metrics-registry": null,
            "node-options": null,
            // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
            "offline": false,
            "onload-script": false,
            only: null,
            optional: true,
            otp: null,
            "package-lock": true,
            "package-lock-only": false,
            parseable: false,
            "prefer-offline": false,
            "prefer-online": false,
            prefix: $9c2514140ba47fd6$var$globalPrefix,
            production: process.env.NODE_ENV === "production",
            "progress": !process.env.TRAVIS && !process.env.CI,
            provenance: false,
            proxy: null,
            "https-proxy": null,
            "no-proxy": null,
            "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
            "read-only": false,
            "rebuild-bundle": true,
            registry: "https://registry.npmjs.org/",
            rollback: true,
            save: true,
            "save-bundle": false,
            "save-dev": false,
            "save-exact": false,
            "save-optional": false,
            "save-prefix": "^",
            "save-prod": false,
            scope: "",
            "script-shell": null,
            "scripts-prepend-node-path": "warn-only",
            searchopts: "",
            searchexclude: null,
            searchlimit: 20,
            searchstaleness: 900,
            "send-metrics": false,
            shell: $9c2514140ba47fd6$var$osenv.shell(),
            shrinkwrap: true,
            "sign-git-tag": false,
            "sso-poll-frequency": 500,
            "sso-type": "oauth",
            "strict-ssl": true,
            tag: "latest",
            "tag-version-prefix": "v",
            timing: false,
            tmp: $9c2514140ba47fd6$var$temp,
            unicode: $9c2514140ba47fd6$var$hasUnicode(),
            "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
            usage: false,
            user: process.platform === "win32" ? 0 : "nobody",
            userconfig: $dAk3n$path.resolve($9c2514140ba47fd6$var$home, ".npmrc"),
            umask: process.umask ? process.umask() : $9c2514140ba47fd6$var$umask.fromString("022"),
            version: false,
            versions: false,
            viewer: process.platform === "win32" ? "browser" : "man",
            _exit: true
        };
        return $9c2514140ba47fd6$var$defaults;
    }
});








// https://github.com/npm/cli/blob/latest/lib/config/core.js#L101-L200
$f93dc2b45b1e9c9a$exports = (opts, types, defaults)=>{
    const conf = new $b29807dd97d8245f$exports(Object.assign({}, $9c2514140ba47fd6$exports.defaults, defaults), types);
    conf.add(Object.assign({}, opts), "cli");
    const warnings = [];
    let failedToLoadBuiltInConfig = false;
    if ($dAk3n$module.createRequire((()=>{
        let path = /(?<path>[^\(\s]+):[0-9]+:[0-9]+/.exec(new Error().stack.split("\n").slice(2, 3)[0]).groups.path;
        if (path.indexOf("file") >= 0) path = new URL(path).pathname;
        let filename = path;
        try {
            if (filename[0] === "/" && $f93dc2b45b1e9c9a$import$cb4ae3886b738c2d$722a64dea1b767dc() === "win32") filename = filename.slice(1);
        } catch (_) {}
        return filename;
    })()).resolve.paths) {
        const paths = $dAk3n$module.createRequire((()=>{
            let path = /(?<path>[^\(\s]+):[0-9]+:[0-9]+/.exec(new Error().stack.split("\n").slice(2, 3)[0]).groups.path;
            if (path.indexOf("file") >= 0) path = new URL(path).pathname;
            let filename = path;
            try {
                if (filename[0] === "/" && $f93dc2b45b1e9c9a$import$cb4ae3886b738c2d$722a64dea1b767dc() === "win32") filename = filename.slice(1);
            } catch (_) {}
            return filename;
        })()).resolve.paths("npm");
        // Assume that last path in resolve paths is builtin modules directory
        let npmPath;
        try {
            npmPath = $dAk3n$module.createRequire((()=>{
                let path = /(?<path>[^\(\s]+):[0-9]+:[0-9]+/.exec(new Error().stack.split("\n").slice(2, 3)[0]).groups.path;
                if (path.indexOf("file") >= 0) path = new URL(path).pathname;
                let filename = path;
                try {
                    if (filename[0] === "/" && $f93dc2b45b1e9c9a$import$cb4ae3886b738c2d$722a64dea1b767dc() === "win32") filename = filename.slice(1);
                } catch (_) {}
                return filename;
            })()).resolve("npm", {
                paths: paths.slice(-1)
            });
        } catch (error) {
            // Error will be thrown if module cannot be found.
            // Update the flag while loading builtin config failed.
            failedToLoadBuiltInConfig = true;
        }
        if (npmPath) /**
			 *  According to https://github.com/npm/cli/blob/86f5bdb91f7a5971953a5171d32d6eeda6a2e972/lib/npm.js#L258
			 *  and https://github.com/npm/cli/blob/86f5bdb91f7a5971953a5171d32d6eeda6a2e972/lib/config/core.js#L92
			 */ warnings.push(conf.addFile($dAk3n$path.resolve($dAk3n$path.dirname(npmPath), "..", "npmrc"), "builtin"));
    }
    conf.addEnv();
    conf.loadPrefix();
    const projectConf = $dAk3n$path.resolve(conf.localPrefix, ".npmrc");
    const userConf = conf.get("userconfig");
    if (!conf.get("global") && projectConf !== userConf) warnings.push(conf.addFile(projectConf, "project"));
    else conf.add({}, "project");
    // TODO: cover with tests that configs from workspace .npmrc have bigger priority
    // than the ones in userconfig
    if (conf.get("workspace-prefix") && conf.get("workspace-prefix") !== projectConf) {
        const workspaceConf = $dAk3n$path.resolve(conf.get("workspace-prefix"), ".npmrc");
        warnings.push(conf.addFile(workspaceConf, "workspace"));
    }
    warnings.push(conf.addFile(conf.get("userconfig"), "user"));
    if (conf.get("prefix")) {
        const etc = $dAk3n$path.resolve(conf.get("prefix"), "etc");
        conf.root.globalconfig = $dAk3n$path.resolve(etc, "npmrc");
        conf.root.globalignorefile = $dAk3n$path.resolve(etc, "npmignore");
    }
    warnings.push(conf.addFile(conf.get("globalconfig"), "global"));
    conf.loadUser();
    const caFile = conf.get("cafile");
    if (caFile) conf.loadCAFile(caFile);
    return {
        config: conf,
        warnings: warnings.filter(Boolean),
        failedToLoadBuiltInConfig: failedToLoadBuiltInConfig
    };
};
Object.defineProperty($f93dc2b45b1e9c9a$exports, "defaults", {
    get () {
        return $9c2514140ba47fd6$exports.defaults;
    },
    enumerable: true
});


const $88ef39e7e8a3750c$var$tokenKey = ":_authToken";
const $88ef39e7e8a3750c$var$legacyTokenKey = ":_auth";
const $88ef39e7e8a3750c$var$userKey = ":username";
const $88ef39e7e8a3750c$var$passwordKey = ":_password";
$88ef39e7e8a3750c$exports = function getRegistryAuthToken() {
    let checkUrl;
    let options;
    if (arguments.length >= 2) {
        checkUrl = arguments[0];
        options = Object.assign({}, arguments[1]);
    } else if (typeof arguments[0] === "string") checkUrl = arguments[0];
    else options = Object.assign({}, arguments[0]);
    options = options || {};
    const providedNpmrc = options.npmrc;
    options.npmrc = (options.npmrc ? {
        config: {
            get: (key)=>providedNpmrc[key]
        }
    } : $f93dc2b45b1e9c9a$exports()).config;
    checkUrl = checkUrl || options.npmrc.get("registry") || $f93dc2b45b1e9c9a$exports.defaults.registry;
    return $88ef39e7e8a3750c$var$getRegistryAuthInfo(checkUrl, options) || $88ef39e7e8a3750c$var$getLegacyAuthInfo(options.npmrc);
};
function $88ef39e7e8a3750c$var$getRegistryAuthInfo(checkUrl, options) {
    const parsed = $dAk3n$url.parse(checkUrl, false, true);
    let pathname;
    while(pathname !== "/" && parsed.pathname !== pathname){
        pathname = parsed.pathname || "/";
        const regUrl = "//" + parsed.host + pathname.replace(/\/$/, "");
        const authInfo = $88ef39e7e8a3750c$var$getAuthInfoForUrl(regUrl, options.npmrc);
        if (authInfo) return authInfo;
        // break if not recursive
        if (!options.recursive) return /\/$/.test(checkUrl) ? undefined : $88ef39e7e8a3750c$var$getRegistryAuthInfo($dAk3n$url.resolve(checkUrl, "."), options);
        parsed.pathname = $dAk3n$url.resolve($88ef39e7e8a3750c$var$normalizePath(pathname), "..") || "/";
    }
    return undefined;
}
function $88ef39e7e8a3750c$var$getLegacyAuthInfo(npmrc) {
    if (!npmrc.get("_auth")) return undefined;
    const token = $88ef39e7e8a3750c$var$replaceEnvironmentVariable(npmrc.get("_auth"));
    return {
        token: token,
        type: "Basic"
    };
}
function $88ef39e7e8a3750c$var$normalizePath(path) {
    return path[path.length - 1] === "/" ? path : path + "/";
}
function $88ef39e7e8a3750c$var$getAuthInfoForUrl(regUrl, npmrc) {
    // try to get bearer token
    const bearerAuth = $88ef39e7e8a3750c$var$getBearerToken(npmrc.get(regUrl + $88ef39e7e8a3750c$var$tokenKey) || npmrc.get(regUrl + "/" + $88ef39e7e8a3750c$var$tokenKey));
    if (bearerAuth) return bearerAuth;
    // try to get basic token
    const username = npmrc.get(regUrl + $88ef39e7e8a3750c$var$userKey) || npmrc.get(regUrl + "/" + $88ef39e7e8a3750c$var$userKey);
    const password = npmrc.get(regUrl + $88ef39e7e8a3750c$var$passwordKey) || npmrc.get(regUrl + "/" + $88ef39e7e8a3750c$var$passwordKey);
    const basicAuth = $88ef39e7e8a3750c$var$getTokenForUsernameAndPassword(username, password);
    if (basicAuth) return basicAuth;
    const basicAuthWithToken = $88ef39e7e8a3750c$var$getLegacyAuthToken(npmrc.get(regUrl + $88ef39e7e8a3750c$var$legacyTokenKey) || npmrc.get(regUrl + "/" + $88ef39e7e8a3750c$var$legacyTokenKey));
    if (basicAuthWithToken) return basicAuthWithToken;
    return undefined;
}
function $88ef39e7e8a3750c$var$replaceEnvironmentVariable(token) {
    return token.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
        return process.env[envVar];
    });
}
function $88ef39e7e8a3750c$var$getBearerToken(tok) {
    if (!tok) return undefined;
    // check if bearer token is set as environment variable
    const token = $88ef39e7e8a3750c$var$replaceEnvironmentVariable(tok);
    return {
        token: token,
        type: "Bearer"
    };
}
function $88ef39e7e8a3750c$var$getTokenForUsernameAndPassword(username, password) {
    if (!username || !password) return undefined;
    // passwords are base64 encoded, so we need to decode it
    // See https://github.com/npm/npm/blob/v3.10.6/lib/config/set-credentials-by-uri.js#L26
    const pass = Buffer.from($88ef39e7e8a3750c$var$replaceEnvironmentVariable(password), "base64").toString("utf8");
    // a basic auth token is base64 encoded 'username:password'
    // See https://github.com/npm/npm/blob/v3.10.6/lib/config/get-credentials-by-uri.js#L70
    const token = Buffer.from(username + ":" + pass, "utf8").toString("base64");
    // we found a basicToken token so let's exit the loop
    return {
        token: token,
        type: "Basic",
        password: pass,
        username: username
    };
}
function $88ef39e7e8a3750c$var$getLegacyAuthToken(tok) {
    if (!tok) return undefined;
    // check if legacy auth token is set as environment variable
    const token = $88ef39e7e8a3750c$var$replaceEnvironmentVariable(tok);
    return {
        token: token,
        type: "Basic"
    };
}


var $6f38c44ac5aebb4f$exports = {};
// just pre-load all the stuff that index.js lazily exports

var $b95lY = parcelRequire("b95lY");

var $kRlLP = parcelRequire("kRlLP");
var $be5b4f25eb084348$exports = {};

var $kAJmv = parcelRequire("kAJmv");

var $kRlLP = parcelRequire("kRlLP");
var $be5b4f25eb084348$require$MAX_LENGTH = $kRlLP.MAX_LENGTH;
var $be5b4f25eb084348$require$MAX_SAFE_INTEGER = $kRlLP.MAX_SAFE_INTEGER;

var $b95lY = parcelRequire("b95lY");
var $be5b4f25eb084348$require$re = $b95lY.safeRe;
var $be5b4f25eb084348$require$t = $b95lY.t;
var $1316d310c4e1471f$exports = {};
// parse out just the options we care about
const $1316d310c4e1471f$var$looseOption = Object.freeze({
    loose: true
});
const $1316d310c4e1471f$var$emptyOpts = Object.freeze({});
const $1316d310c4e1471f$var$parseOptions = (options)=>{
    if (!options) return $1316d310c4e1471f$var$emptyOpts;
    if (typeof options !== "object") return $1316d310c4e1471f$var$looseOption;
    return options;
};
$1316d310c4e1471f$exports = $1316d310c4e1471f$var$parseOptions;


var $f3570640aab49284$exports = {};
const $f3570640aab49284$var$numeric = /^[0-9]+$/;
const $f3570640aab49284$var$compareIdentifiers = (a, b)=>{
    const anum = $f3570640aab49284$var$numeric.test(a);
    const bnum = $f3570640aab49284$var$numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const $f3570640aab49284$var$rcompareIdentifiers = (a, b)=>$f3570640aab49284$var$compareIdentifiers(b, a);
$f3570640aab49284$exports = {
    compareIdentifiers: $f3570640aab49284$var$compareIdentifiers,
    rcompareIdentifiers: $f3570640aab49284$var$rcompareIdentifiers
};


var $be5b4f25eb084348$require$compareIdentifiers = $f3570640aab49284$exports.compareIdentifiers;
class $be5b4f25eb084348$var$SemVer {
    constructor(version, options){
        options = $1316d310c4e1471f$exports(options);
        if (version instanceof $be5b4f25eb084348$var$SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
            else version = version.version;
        } else if (typeof version !== "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        if (version.length > $be5b4f25eb084348$require$MAX_LENGTH) throw new TypeError(`version is longer than ${$be5b4f25eb084348$require$MAX_LENGTH} characters`);
        $kAJmv("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? $be5b4f25eb084348$require$re[$be5b4f25eb084348$require$t.LOOSE] : $be5b4f25eb084348$require$re[$be5b4f25eb084348$require$t.FULL]);
        if (!m) throw new TypeError(`Invalid Version: ${version}`);
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > $be5b4f25eb084348$require$MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > $be5b4f25eb084348$require$MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > $be5b4f25eb084348$require$MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        // numberify any prerelease numeric ids
        if (!m[4]) this.prerelease = [];
        else this.prerelease = m[4].split(".").map((id)=>{
            if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < $be5b4f25eb084348$require$MAX_SAFE_INTEGER) return num;
            }
            return id;
        });
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        $kAJmv("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof $be5b4f25eb084348$var$SemVer)) {
            if (typeof other === "string" && other === this.version) return 0;
            other = new $be5b4f25eb084348$var$SemVer(other, this.options);
        }
        if (other.version === this.version) return 0;
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof $be5b4f25eb084348$var$SemVer)) other = new $be5b4f25eb084348$var$SemVer(other, this.options);
        return $be5b4f25eb084348$require$compareIdentifiers(this.major, other.major) || $be5b4f25eb084348$require$compareIdentifiers(this.minor, other.minor) || $be5b4f25eb084348$require$compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
        if (!(other instanceof $be5b4f25eb084348$var$SemVer)) other = new $be5b4f25eb084348$var$SemVer(other, this.options);
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) return -1;
        else if (!this.prerelease.length && other.prerelease.length) return 1;
        else if (!this.prerelease.length && !other.prerelease.length) return 0;
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            $kAJmv("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) return 0;
            else if (b === undefined) return 1;
            else if (a === undefined) return -1;
            else if (a === b) continue;
            else return $be5b4f25eb084348$require$compareIdentifiers(a, b);
        }while (++i);
    }
    compareBuild(other) {
        if (!(other instanceof $be5b4f25eb084348$var$SemVer)) other = new $be5b4f25eb084348$var$SemVer(other, this.options);
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            $kAJmv("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) return 0;
            else if (b === undefined) return 1;
            else if (a === undefined) return -1;
            else if (a === b) continue;
            else return $be5b4f25eb084348$require$compareIdentifiers(a, b);
        }while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        switch(release){
            case "premajor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc("pre", identifier, identifierBase);
                break;
            case "preminor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc("pre", identifier, identifierBase);
                break;
            case "prepatch":
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc("patch", identifier, identifierBase);
                this.inc("pre", identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case "prerelease":
                if (this.prerelease.length === 0) this.inc("patch", identifier, identifierBase);
                this.inc("pre", identifier, identifierBase);
                break;
            case "major":
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "minor":
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "patch":
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) this.patch++;
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case "pre":
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (!identifier && identifierBase === false) throw new Error("invalid increment argument: identifier is empty");
                    if (this.prerelease.length === 0) this.prerelease = [
                        base
                    ];
                    else {
                        let i = this.prerelease.length;
                        while(--i >= 0)if (typeof this.prerelease[i] === "number") {
                            this.prerelease[i]++;
                            i = -2;
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join(".") && identifierBase === false) throw new Error("invalid increment argument: identifier already exists");
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) prerelease = [
                            identifier
                        ];
                        if ($be5b4f25eb084348$require$compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
                        } else this.prerelease = prerelease;
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) this.raw += `+${this.build.join(".")}`;
        return this;
    }
}
$be5b4f25eb084348$exports = $be5b4f25eb084348$var$SemVer;



var $d793791160a9ca3e$exports = {};

const $d793791160a9ca3e$var$parse = (version, options, throwErrors = false)=>{
    if (version instanceof $be5b4f25eb084348$exports) return version;
    try {
        return new $be5b4f25eb084348$exports(version, options);
    } catch (er) {
        if (!throwErrors) return null;
        throw er;
    }
};
$d793791160a9ca3e$exports = $d793791160a9ca3e$var$parse;


var $9dbc064d08157fde$exports = {};

const $9dbc064d08157fde$var$valid = (version, options)=>{
    const v = $d793791160a9ca3e$exports(version, options);
    return v ? v.version : null;
};
$9dbc064d08157fde$exports = $9dbc064d08157fde$var$valid;


var $d87f2d78cb92ca25$exports = {};

const $d87f2d78cb92ca25$var$clean = (version, options)=>{
    const s = $d793791160a9ca3e$exports(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
};
$d87f2d78cb92ca25$exports = $d87f2d78cb92ca25$var$clean;


var $705b8af747a198b3$exports = {};

const $705b8af747a198b3$var$inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new $be5b4f25eb084348$exports(version instanceof $be5b4f25eb084348$exports ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
$705b8af747a198b3$exports = $705b8af747a198b3$var$inc;


var $763ad2369f72148e$exports = {};

const $763ad2369f72148e$var$diff = (version1, version2)=>{
    const v1 = $d793791160a9ca3e$exports(version1, null, true);
    const v2 = $d793791160a9ca3e$exports(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) return null;
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) return "major";
        // Otherwise it can be determined by checking the high version
        if (highVersion.patch) // anything higher than a patch bump would result in the wrong version
        return "patch";
        if (highVersion.minor) // anything higher than a minor bump would result in the wrong version
        return "minor";
        // bumping major/minor/patch all have same result
        return "major";
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) return prefix + "major";
    if (v1.minor !== v2.minor) return prefix + "minor";
    if (v1.patch !== v2.patch) return prefix + "patch";
    // high and low are preleases
    return "prerelease";
};
$763ad2369f72148e$exports = $763ad2369f72148e$var$diff;


var $e3f7484f82706e16$exports = {};

const $e3f7484f82706e16$var$major = (a, loose)=>new $be5b4f25eb084348$exports(a, loose).major;
$e3f7484f82706e16$exports = $e3f7484f82706e16$var$major;


var $530023fc4b46c747$exports = {};

const $530023fc4b46c747$var$minor = (a, loose)=>new $be5b4f25eb084348$exports(a, loose).minor;
$530023fc4b46c747$exports = $530023fc4b46c747$var$minor;


var $f6f81ec9c06bfccd$exports = {};

const $f6f81ec9c06bfccd$var$patch = (a, loose)=>new $be5b4f25eb084348$exports(a, loose).patch;
$f6f81ec9c06bfccd$exports = $f6f81ec9c06bfccd$var$patch;


var $68d42bacbb289d7b$exports = {};

const $68d42bacbb289d7b$var$prerelease = (version, options)=>{
    const parsed = $d793791160a9ca3e$exports(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
$68d42bacbb289d7b$exports = $68d42bacbb289d7b$var$prerelease;


var $e3893a232aa2ca36$exports = {};

const $e3893a232aa2ca36$var$compare = (a, b, loose)=>new $be5b4f25eb084348$exports(a, loose).compare(new $be5b4f25eb084348$exports(b, loose));
$e3893a232aa2ca36$exports = $e3893a232aa2ca36$var$compare;


var $bef5534db7b26890$exports = {};

const $bef5534db7b26890$var$rcompare = (a, b, loose)=>$e3893a232aa2ca36$exports(b, a, loose);
$bef5534db7b26890$exports = $bef5534db7b26890$var$rcompare;


var $bbe64750043da469$exports = {};

const $bbe64750043da469$var$compareLoose = (a, b)=>$e3893a232aa2ca36$exports(a, b, true);
$bbe64750043da469$exports = $bbe64750043da469$var$compareLoose;


var $626d39458b1181ce$exports = {};

const $626d39458b1181ce$var$compareBuild = (a, b, loose)=>{
    const versionA = new $be5b4f25eb084348$exports(a, loose);
    const versionB = new $be5b4f25eb084348$exports(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
$626d39458b1181ce$exports = $626d39458b1181ce$var$compareBuild;


var $d409fa5d8babf1f6$exports = {};

const $d409fa5d8babf1f6$var$sort = (list, loose)=>list.sort((a, b)=>$626d39458b1181ce$exports(a, b, loose));
$d409fa5d8babf1f6$exports = $d409fa5d8babf1f6$var$sort;


var $2a85514ae626f8e3$exports = {};

const $2a85514ae626f8e3$var$rsort = (list, loose)=>list.sort((a, b)=>$626d39458b1181ce$exports(b, a, loose));
$2a85514ae626f8e3$exports = $2a85514ae626f8e3$var$rsort;


var $ce2e615526098bd1$exports = {};

const $ce2e615526098bd1$var$gt = (a, b, loose)=>$e3893a232aa2ca36$exports(a, b, loose) > 0;
$ce2e615526098bd1$exports = $ce2e615526098bd1$var$gt;


var $acb5cfc244b4e718$exports = {};

const $acb5cfc244b4e718$var$lt = (a, b, loose)=>$e3893a232aa2ca36$exports(a, b, loose) < 0;
$acb5cfc244b4e718$exports = $acb5cfc244b4e718$var$lt;


var $aeca99fa223731af$exports = {};

const $aeca99fa223731af$var$eq = (a, b, loose)=>$e3893a232aa2ca36$exports(a, b, loose) === 0;
$aeca99fa223731af$exports = $aeca99fa223731af$var$eq;


var $7844da3608efd6b5$exports = {};

const $7844da3608efd6b5$var$neq = (a, b, loose)=>$e3893a232aa2ca36$exports(a, b, loose) !== 0;
$7844da3608efd6b5$exports = $7844da3608efd6b5$var$neq;


var $40fb1ad98b49c054$exports = {};

const $40fb1ad98b49c054$var$gte = (a, b, loose)=>$e3893a232aa2ca36$exports(a, b, loose) >= 0;
$40fb1ad98b49c054$exports = $40fb1ad98b49c054$var$gte;


var $2da47d08648651b1$exports = {};

const $2da47d08648651b1$var$lte = (a, b, loose)=>$e3893a232aa2ca36$exports(a, b, loose) <= 0;
$2da47d08648651b1$exports = $2da47d08648651b1$var$lte;


var $40a512d771dfd461$exports = {};






const $40a512d771dfd461$var$cmp = (a, op, b, loose)=>{
    switch(op){
        case "===":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a === b;
        case "!==":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a !== b;
        case "":
        case "=":
        case "==":
            return $aeca99fa223731af$exports(a, b, loose);
        case "!=":
            return $7844da3608efd6b5$exports(a, b, loose);
        case ">":
            return $ce2e615526098bd1$exports(a, b, loose);
        case ">=":
            return $40fb1ad98b49c054$exports(a, b, loose);
        case "<":
            return $acb5cfc244b4e718$exports(a, b, loose);
        case "<=":
            return $2da47d08648651b1$exports(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
$40a512d771dfd461$exports = $40a512d771dfd461$var$cmp;


var $d821b1fee0b78495$exports = {};



var $b95lY = parcelRequire("b95lY");
var $d821b1fee0b78495$require$re = $b95lY.safeRe;
var $d821b1fee0b78495$require$t = $b95lY.t;
const $d821b1fee0b78495$var$coerce = (version, options)=>{
    if (version instanceof $be5b4f25eb084348$exports) return version;
    if (typeof version === "number") version = String(version);
    if (typeof version !== "string") return null;
    options = options || {};
    let match = null;
    if (!options.rtl) match = version.match($d821b1fee0b78495$require$re[$d821b1fee0b78495$require$t.COERCE]);
    else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        let next;
        while((next = $d821b1fee0b78495$require$re[$d821b1fee0b78495$require$t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
            $d821b1fee0b78495$require$re[$d821b1fee0b78495$require$t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        $d821b1fee0b78495$require$re[$d821b1fee0b78495$require$t.COERCERTL].lastIndex = -1;
    }
    if (match === null) return null;
    return $d793791160a9ca3e$exports(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
$d821b1fee0b78495$exports = $d821b1fee0b78495$var$coerce;


var $aeafedf2d2971e25$exports = {};
const $aeafedf2d2971e25$var$ANY = Symbol("SemVer ANY");
// hoisted class for cyclic dependency
class $aeafedf2d2971e25$var$Comparator {
    static get ANY() {
        return $aeafedf2d2971e25$var$ANY;
    }
    constructor(comp, options){
        options = $1316d310c4e1471f$exports(options);
        if (comp instanceof $aeafedf2d2971e25$var$Comparator) {
            if (comp.loose === !!options.loose) return comp;
            else comp = comp.value;
        }
        comp = comp.trim().split(/\s+/).join(" ");
        $kAJmv("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === $aeafedf2d2971e25$var$ANY) this.value = "";
        else this.value = this.operator + this.semver.version;
        $kAJmv("comp", this);
    }
    parse(comp) {
        const r = this.options.loose ? $aeafedf2d2971e25$require$re[$aeafedf2d2971e25$require$t.COMPARATORLOOSE] : $aeafedf2d2971e25$require$re[$aeafedf2d2971e25$require$t.COMPARATOR];
        const m = comp.match(r);
        if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
        this.operator = m[1] !== undefined ? m[1] : "";
        if (this.operator === "=") this.operator = "";
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) this.semver = $aeafedf2d2971e25$var$ANY;
        else this.semver = new $be5b4f25eb084348$exports(m[2], this.options.loose);
    }
    toString() {
        return this.value;
    }
    test(version) {
        $kAJmv("Comparator.test", version, this.options.loose);
        if (this.semver === $aeafedf2d2971e25$var$ANY || version === $aeafedf2d2971e25$var$ANY) return true;
        if (typeof version === "string") try {
            version = new $be5b4f25eb084348$exports(version, this.options);
        } catch (er) {
            return false;
        }
        return $40a512d771dfd461$exports(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof $aeafedf2d2971e25$var$Comparator)) throw new TypeError("a Comparator is required");
        if (this.operator === "") {
            if (this.value === "") return true;
            return new $63b582b3058aacef$exports(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
            if (comp.value === "") return true;
            return new $63b582b3058aacef$exports(this.value, options).test(comp.semver);
        }
        options = $1316d310c4e1471f$exports(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) return false;
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) return false;
        // Same direction increasing (> or >=)
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) return true;
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) return true;
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) return true;
        // opposite directions less than
        if ($40a512d771dfd461$exports(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) return true;
        // opposite directions greater than
        if ($40a512d771dfd461$exports(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) return true;
        return false;
    }
}
$aeafedf2d2971e25$exports = $aeafedf2d2971e25$var$Comparator;


var $b95lY = parcelRequire("b95lY");
var $aeafedf2d2971e25$require$re = $b95lY.safeRe;
var $aeafedf2d2971e25$require$t = $b95lY.t;


var $kAJmv = parcelRequire("kAJmv");

var $63b582b3058aacef$exports = {};
// hoisted class for cyclic dependency
class $63b582b3058aacef$var$Range {
    constructor(range, options){
        options = $1316d310c4e1471f$exports(options);
        if (range instanceof $63b582b3058aacef$var$Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) return range;
            else return new $63b582b3058aacef$var$Range(range.raw, options);
        }
        if (range instanceof $aeafedf2d2971e25$exports) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.format();
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().split(/\s+/).join(" ");
        // First, split on ||
        this.set = this.raw.split("||")// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!$63b582b3058aacef$var$isNullSet(c[0]));
            if (this.set.length === 0) this.set = [
                first
            ];
            else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set)if (c.length === 1 && $63b582b3058aacef$var$isAny(c[0])) {
                    this.set = [
                        c
                    ];
                    break;
                }
            }
        }
        this.format();
    }
    format() {
        this.range = this.set.map((comps)=>comps.join(" ").trim()).join("||").trim();
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && $63b582b3058aacef$require$FLAG_INCLUDE_PRERELEASE) | (this.options.loose && $63b582b3058aacef$require$FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = $63b582b3058aacef$var$cache.get(memoKey);
        if (cached) return cached;
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.HYPHENRANGELOOSE] : $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.HYPHENRANGE];
        range = range.replace(hr, $63b582b3058aacef$var$hyphenReplace(this.options.includePrerelease));
        $kAJmv("hyphen replace", range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace($63b582b3058aacef$require$re[$63b582b3058aacef$require$t.COMPARATORTRIM], $63b582b3058aacef$require$comparatorTrimReplace);
        $kAJmv("comparator trim", range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace($63b582b3058aacef$require$re[$63b582b3058aacef$require$t.TILDETRIM], $63b582b3058aacef$require$tildeTrimReplace);
        $kAJmv("tilde trim", range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace($63b582b3058aacef$require$re[$63b582b3058aacef$require$t.CARETTRIM], $63b582b3058aacef$require$caretTrimReplace);
        $kAJmv("caret trim", range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(" ").map((comp)=>$63b582b3058aacef$var$parseComparator(comp, this.options)).join(" ").split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>$63b582b3058aacef$var$replaceGTE0(comp, this.options));
        if (loose) // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter((comp)=>{
            $kAJmv("loose invalid filter", comp, this.options);
            return !!comp.match($63b582b3058aacef$require$re[$63b582b3058aacef$require$t.COMPARATORLOOSE]);
        });
        $kAJmv("range list", rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new $aeafedf2d2971e25$exports(comp, this.options));
        for (const comp of comparators){
            if ($63b582b3058aacef$var$isNullSet(comp)) return [
                comp
            ];
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) rangeMap.delete("");
        const result = [
            ...rangeMap.values()
        ];
        $63b582b3058aacef$var$cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof $63b582b3058aacef$var$Range)) throw new TypeError("a Range is required");
        return this.set.some((thisComparators)=>{
            return $63b582b3058aacef$var$isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return $63b582b3058aacef$var$isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) return false;
        if (typeof version === "string") try {
            version = new $be5b4f25eb084348$exports(version, this.options);
        } catch (er) {
            return false;
        }
        for(let i = 0; i < this.set.length; i++){
            if ($63b582b3058aacef$var$testSet(this.set[i], version, this.options)) return true;
        }
        return false;
    }
}
$63b582b3058aacef$exports = $63b582b3058aacef$var$Range;
var $da2c2e228d2649c7$exports = {};
"use strict";
var $954ac2a1ded0a834$exports = {};
"use strict";
$954ac2a1ded0a834$exports = $954ac2a1ded0a834$var$Yallist;
$954ac2a1ded0a834$var$Yallist.Node = $954ac2a1ded0a834$var$Node;
$954ac2a1ded0a834$var$Yallist.create = $954ac2a1ded0a834$var$Yallist;
function $954ac2a1ded0a834$var$Yallist(list) {
    var self = this;
    if (!(self instanceof $954ac2a1ded0a834$var$Yallist)) self = new $954ac2a1ded0a834$var$Yallist();
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") list.forEach(function(item) {
        self.push(item);
    });
    else if (arguments.length > 0) for(var i = 0, l = arguments.length; i < l; i++)self.push(arguments[i]);
    return self;
}
$954ac2a1ded0a834$var$Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) throw new Error("removing node which does not belong to this list");
    var next = node.next;
    var prev = node.prev;
    if (next) next.prev = prev;
    if (prev) prev.next = next;
    if (node === this.head) this.head = next;
    if (node === this.tail) this.tail = prev;
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
$954ac2a1ded0a834$var$Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) return;
    if (node.list) node.list.removeNode(node);
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) head.prev = node;
    this.head = node;
    if (!this.tail) this.tail = node;
    this.length++;
};
$954ac2a1ded0a834$var$Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) return;
    if (node.list) node.list.removeNode(node);
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) tail.next = node;
    this.tail = node;
    if (!this.head) this.head = node;
    this.length++;
};
$954ac2a1ded0a834$var$Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++)$954ac2a1ded0a834$var$push(this, arguments[i]);
    return this.length;
};
$954ac2a1ded0a834$var$Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++)$954ac2a1ded0a834$var$unshift(this, arguments[i]);
    return this.length;
};
$954ac2a1ded0a834$var$Yallist.prototype.pop = function() {
    if (!this.tail) return undefined;
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) this.tail.next = null;
    else this.head = null;
    this.length--;
    return res;
};
$954ac2a1ded0a834$var$Yallist.prototype.shift = function() {
    if (!this.head) return undefined;
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) this.head.prev = null;
    else this.tail = null;
    this.length--;
    return res;
};
$954ac2a1ded0a834$var$Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
$954ac2a1ded0a834$var$Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
$954ac2a1ded0a834$var$Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++)// abort out of the list early if we hit a cycle
    walker = walker.next;
    if (i === n && walker !== null) return walker.value;
};
$954ac2a1ded0a834$var$Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++)// abort out of the list early if we hit a cycle
    walker = walker.prev;
    if (i === n && walker !== null) return walker.value;
};
$954ac2a1ded0a834$var$Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new $954ac2a1ded0a834$var$Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
$954ac2a1ded0a834$var$Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new $954ac2a1ded0a834$var$Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
$954ac2a1ded0a834$var$Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) acc = initial;
    else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else throw new TypeError("Reduce of empty list with no initial value");
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
$954ac2a1ded0a834$var$Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) acc = initial;
    else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else throw new TypeError("Reduce of empty list with no initial value");
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
$954ac2a1ded0a834$var$Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
$954ac2a1ded0a834$var$Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
$954ac2a1ded0a834$var$Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) to += this.length;
    from = from || 0;
    if (from < 0) from += this.length;
    var ret = new $954ac2a1ded0a834$var$Yallist();
    if (to < from || to < 0) return ret;
    if (from < 0) from = 0;
    if (to > this.length) to = this.length;
    for(var i = 0, walker = this.head; walker !== null && i < from; i++)walker = walker.next;
    for(; walker !== null && i < to; i++, walker = walker.next)ret.push(walker.value);
    return ret;
};
$954ac2a1ded0a834$var$Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) to += this.length;
    from = from || 0;
    if (from < 0) from += this.length;
    var ret = new $954ac2a1ded0a834$var$Yallist();
    if (to < from || to < 0) return ret;
    if (from < 0) from = 0;
    if (to > this.length) to = this.length;
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--)walker = walker.prev;
    for(; walker !== null && i > from; i--, walker = walker.prev)ret.push(walker.value);
    return ret;
};
$954ac2a1ded0a834$var$Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) start = this.length - 1;
    if (start < 0) start = this.length + start;
    for(var i = 0, walker = this.head; walker !== null && i < start; i++)walker = walker.next;
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) walker = this.tail;
    if (walker !== this.head && walker !== this.tail) walker = walker.prev;
    for(var i = 0; i < nodes.length; i++)walker = $954ac2a1ded0a834$var$insert(this, walker, nodes[i]);
    return ret;
};
$954ac2a1ded0a834$var$Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function $954ac2a1ded0a834$var$insert(self, node, value) {
    var inserted = node === self.head ? new $954ac2a1ded0a834$var$Node(value, null, node, self) : new $954ac2a1ded0a834$var$Node(value, node, node.next, self);
    if (inserted.next === null) self.tail = inserted;
    if (inserted.prev === null) self.head = inserted;
    self.length++;
    return inserted;
}
function $954ac2a1ded0a834$var$push(self, item) {
    self.tail = new $954ac2a1ded0a834$var$Node(item, self.tail, null, self);
    if (!self.head) self.head = self.tail;
    self.length++;
}
function $954ac2a1ded0a834$var$unshift(self, item) {
    self.head = new $954ac2a1ded0a834$var$Node(item, null, self.head, self);
    if (!self.tail) self.tail = self.head;
    self.length++;
}
function $954ac2a1ded0a834$var$Node(value, prev, next, list) {
    if (!(this instanceof $954ac2a1ded0a834$var$Node)) return new $954ac2a1ded0a834$var$Node(value, prev, next, list);
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else this.prev = null;
    if (next) {
        next.prev = this;
        this.next = next;
    } else this.next = null;
}

try {
    // add if support for Symbol.iterator is present
    (parcelRequire("TLw5d"))($954ac2a1ded0a834$var$Yallist);
} catch (er) {}


const $da2c2e228d2649c7$var$MAX = Symbol("max");
const $da2c2e228d2649c7$var$LENGTH = Symbol("length");
const $da2c2e228d2649c7$var$LENGTH_CALCULATOR = Symbol("lengthCalculator");
const $da2c2e228d2649c7$var$ALLOW_STALE = Symbol("allowStale");
const $da2c2e228d2649c7$var$MAX_AGE = Symbol("maxAge");
const $da2c2e228d2649c7$var$DISPOSE = Symbol("dispose");
const $da2c2e228d2649c7$var$NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const $da2c2e228d2649c7$var$LRU_LIST = Symbol("lruList");
const $da2c2e228d2649c7$var$CACHE = Symbol("cache");
const $da2c2e228d2649c7$var$UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const $da2c2e228d2649c7$var$naiveLength = ()=>1;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class $da2c2e228d2649c7$var$LRUCache {
    constructor(options){
        if (typeof options === "number") options = {
            max: options
        };
        if (!options) options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[$da2c2e228d2649c7$var$MAX] = options.max || Infinity;
        const lc = options.length || $da2c2e228d2649c7$var$naiveLength;
        this[$da2c2e228d2649c7$var$LENGTH_CALCULATOR] = typeof lc !== "function" ? $da2c2e228d2649c7$var$naiveLength : lc;
        this[$da2c2e228d2649c7$var$ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
        this[$da2c2e228d2649c7$var$MAX_AGE] = options.maxAge || 0;
        this[$da2c2e228d2649c7$var$DISPOSE] = options.dispose;
        this[$da2c2e228d2649c7$var$NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[$da2c2e228d2649c7$var$UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[$da2c2e228d2649c7$var$MAX] = mL || Infinity;
        $da2c2e228d2649c7$var$trim(this);
    }
    get max() {
        return this[$da2c2e228d2649c7$var$MAX];
    }
    set allowStale(allowStale) {
        this[$da2c2e228d2649c7$var$ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[$da2c2e228d2649c7$var$ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
        this[$da2c2e228d2649c7$var$MAX_AGE] = mA;
        $da2c2e228d2649c7$var$trim(this);
    }
    get maxAge() {
        return this[$da2c2e228d2649c7$var$MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== "function") lC = $da2c2e228d2649c7$var$naiveLength;
        if (lC !== this[$da2c2e228d2649c7$var$LENGTH_CALCULATOR]) {
            this[$da2c2e228d2649c7$var$LENGTH_CALCULATOR] = lC;
            this[$da2c2e228d2649c7$var$LENGTH] = 0;
            this[$da2c2e228d2649c7$var$LRU_LIST].forEach((hit)=>{
                hit.length = this[$da2c2e228d2649c7$var$LENGTH_CALCULATOR](hit.value, hit.key);
                this[$da2c2e228d2649c7$var$LENGTH] += hit.length;
            });
        }
        $da2c2e228d2649c7$var$trim(this);
    }
    get lengthCalculator() {
        return this[$da2c2e228d2649c7$var$LENGTH_CALCULATOR];
    }
    get length() {
        return this[$da2c2e228d2649c7$var$LENGTH];
    }
    get itemCount() {
        return this[$da2c2e228d2649c7$var$LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[$da2c2e228d2649c7$var$LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            $da2c2e228d2649c7$var$forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[$da2c2e228d2649c7$var$LRU_LIST].head; walker !== null;){
            const next = walker.next;
            $da2c2e228d2649c7$var$forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[$da2c2e228d2649c7$var$LRU_LIST].toArray().map((k)=>k.key);
    }
    values() {
        return this[$da2c2e228d2649c7$var$LRU_LIST].toArray().map((k)=>k.value);
    }
    reset() {
        if (this[$da2c2e228d2649c7$var$DISPOSE] && this[$da2c2e228d2649c7$var$LRU_LIST] && this[$da2c2e228d2649c7$var$LRU_LIST].length) this[$da2c2e228d2649c7$var$LRU_LIST].forEach((hit)=>this[$da2c2e228d2649c7$var$DISPOSE](hit.key, hit.value));
        this[$da2c2e228d2649c7$var$CACHE] = new Map() // hash of items by key
        ;
        this[$da2c2e228d2649c7$var$LRU_LIST] = new $954ac2a1ded0a834$exports() // list of items in order of use recency
        ;
        this[$da2c2e228d2649c7$var$LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[$da2c2e228d2649c7$var$LRU_LIST].map((hit)=>$da2c2e228d2649c7$var$isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h)=>h);
    }
    dumpLru() {
        return this[$da2c2e228d2649c7$var$LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[$da2c2e228d2649c7$var$MAX_AGE];
        if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[$da2c2e228d2649c7$var$LENGTH_CALCULATOR](value, key);
        if (this[$da2c2e228d2649c7$var$CACHE].has(key)) {
            if (len > this[$da2c2e228d2649c7$var$MAX]) {
                $da2c2e228d2649c7$var$del(this, this[$da2c2e228d2649c7$var$CACHE].get(key));
                return false;
            }
            const node = this[$da2c2e228d2649c7$var$CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[$da2c2e228d2649c7$var$DISPOSE]) {
                if (!this[$da2c2e228d2649c7$var$NO_DISPOSE_ON_SET]) this[$da2c2e228d2649c7$var$DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[$da2c2e228d2649c7$var$LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            $da2c2e228d2649c7$var$trim(this);
            return true;
        }
        const hit = new $da2c2e228d2649c7$var$Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[$da2c2e228d2649c7$var$MAX]) {
            if (this[$da2c2e228d2649c7$var$DISPOSE]) this[$da2c2e228d2649c7$var$DISPOSE](key, value);
            return false;
        }
        this[$da2c2e228d2649c7$var$LENGTH] += hit.length;
        this[$da2c2e228d2649c7$var$LRU_LIST].unshift(hit);
        this[$da2c2e228d2649c7$var$CACHE].set(key, this[$da2c2e228d2649c7$var$LRU_LIST].head);
        $da2c2e228d2649c7$var$trim(this);
        return true;
    }
    has(key) {
        if (!this[$da2c2e228d2649c7$var$CACHE].has(key)) return false;
        const hit = this[$da2c2e228d2649c7$var$CACHE].get(key).value;
        return !$da2c2e228d2649c7$var$isStale(this, hit);
    }
    get(key) {
        return $da2c2e228d2649c7$var$get(this, key, true);
    }
    peek(key) {
        return $da2c2e228d2649c7$var$get(this, key, false);
    }
    pop() {
        const node = this[$da2c2e228d2649c7$var$LRU_LIST].tail;
        if (!node) return null;
        $da2c2e228d2649c7$var$del(this, node);
        return node.value;
    }
    del(key) {
        $da2c2e228d2649c7$var$del(this, this[$da2c2e228d2649c7$var$CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) this.set(hit.k, hit.v, maxAge);
            }
        }
    }
    prune() {
        this[$da2c2e228d2649c7$var$CACHE].forEach((value, key)=>$da2c2e228d2649c7$var$get(this, key, false));
    }
}
const $da2c2e228d2649c7$var$get = (self, key, doUse)=>{
    const node = self[$da2c2e228d2649c7$var$CACHE].get(key);
    if (node) {
        const hit = node.value;
        if ($da2c2e228d2649c7$var$isStale(self, hit)) {
            $da2c2e228d2649c7$var$del(self, node);
            if (!self[$da2c2e228d2649c7$var$ALLOW_STALE]) return undefined;
        } else if (doUse) {
            if (self[$da2c2e228d2649c7$var$UPDATE_AGE_ON_GET]) node.value.now = Date.now();
            self[$da2c2e228d2649c7$var$LRU_LIST].unshiftNode(node);
        }
        return hit.value;
    }
};
const $da2c2e228d2649c7$var$isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[$da2c2e228d2649c7$var$MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[$da2c2e228d2649c7$var$MAX_AGE] && diff > self[$da2c2e228d2649c7$var$MAX_AGE];
};
const $da2c2e228d2649c7$var$trim = (self)=>{
    if (self[$da2c2e228d2649c7$var$LENGTH] > self[$da2c2e228d2649c7$var$MAX]) for(let walker = self[$da2c2e228d2649c7$var$LRU_LIST].tail; self[$da2c2e228d2649c7$var$LENGTH] > self[$da2c2e228d2649c7$var$MAX] && walker !== null;){
        // We know that we're about to delete this one, and also
        // what the next least recently used key will be, so just
        // go ahead and set it now.
        const prev = walker.prev;
        $da2c2e228d2649c7$var$del(self, walker);
        walker = prev;
    }
};
const $da2c2e228d2649c7$var$del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[$da2c2e228d2649c7$var$DISPOSE]) self[$da2c2e228d2649c7$var$DISPOSE](hit.key, hit.value);
        self[$da2c2e228d2649c7$var$LENGTH] -= hit.length;
        self[$da2c2e228d2649c7$var$CACHE].delete(hit.key);
        self[$da2c2e228d2649c7$var$LRU_LIST].removeNode(node);
    }
};
class $da2c2e228d2649c7$var$Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const $da2c2e228d2649c7$var$forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if ($da2c2e228d2649c7$var$isStale(self, hit)) {
        $da2c2e228d2649c7$var$del(self, node);
        if (!self[$da2c2e228d2649c7$var$ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
$da2c2e228d2649c7$exports = $da2c2e228d2649c7$var$LRUCache;


const $63b582b3058aacef$var$cache = new $da2c2e228d2649c7$exports({
    max: 1000
});



var $kAJmv = parcelRequire("kAJmv");


var $b95lY = parcelRequire("b95lY");
var $63b582b3058aacef$require$re = $b95lY.safeRe;
var $63b582b3058aacef$require$t = $b95lY.t;
var $63b582b3058aacef$require$comparatorTrimReplace = $b95lY.comparatorTrimReplace;
var $63b582b3058aacef$require$tildeTrimReplace = $b95lY.tildeTrimReplace;
var $63b582b3058aacef$require$caretTrimReplace = $b95lY.caretTrimReplace;

var $kRlLP = parcelRequire("kRlLP");
var $63b582b3058aacef$require$FLAG_INCLUDE_PRERELEASE = $kRlLP.FLAG_INCLUDE_PRERELEASE;
var $63b582b3058aacef$require$FLAG_LOOSE = $kRlLP.FLAG_LOOSE;
const $63b582b3058aacef$var$isNullSet = (c)=>c.value === "<0.0.0-0";
const $63b582b3058aacef$var$isAny = (c)=>c.value === "";
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const $63b582b3058aacef$var$isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const $63b582b3058aacef$var$parseComparator = (comp, options)=>{
    $kAJmv("comp", comp, options);
    comp = $63b582b3058aacef$var$replaceCarets(comp, options);
    $kAJmv("caret", comp);
    comp = $63b582b3058aacef$var$replaceTildes(comp, options);
    $kAJmv("tildes", comp);
    comp = $63b582b3058aacef$var$replaceXRanges(comp, options);
    $kAJmv("xrange", comp);
    comp = $63b582b3058aacef$var$replaceStars(comp, options);
    $kAJmv("stars", comp);
    return comp;
};
const $63b582b3058aacef$var$isX = (id)=>!id || id.toLowerCase() === "x" || id === "*";
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const $63b582b3058aacef$var$replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>$63b582b3058aacef$var$replaceTilde(c, options)).join(" ");
};
const $63b582b3058aacef$var$replaceTilde = (comp, options)=>{
    const r = options.loose ? $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.TILDELOOSE] : $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        $kAJmv("tilde", comp, _, M, m, p, pr);
        let ret;
        if ($63b582b3058aacef$var$isX(M)) ret = "";
        else if ($63b582b3058aacef$var$isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        else if ($63b582b3058aacef$var$isX(p)) // ~1.2 == >=1.2.0 <1.3.0-0
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        else if (pr) {
            $kAJmv("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else // ~1.2.3 == >=1.2.3 <1.3.0-0
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        $kAJmv("tilde return", ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const $63b582b3058aacef$var$replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>$63b582b3058aacef$var$replaceCaret(c, options)).join(" ");
};
const $63b582b3058aacef$var$replaceCaret = (comp, options)=>{
    $kAJmv("caret", comp, options);
    const r = options.loose ? $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.CARETLOOSE] : $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr)=>{
        $kAJmv("caret", comp, _, M, m, p, pr);
        let ret;
        if ($63b582b3058aacef$var$isX(M)) ret = "";
        else if ($63b582b3058aacef$var$isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        else if ($63b582b3058aacef$var$isX(p)) {
            if (M === "0") ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            else ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        } else if (pr) {
            $kAJmv("replaceCaret pr", pr);
            if (M === "0") {
                if (m === "0") ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                else ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            } else ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        } else {
            $kAJmv("no pr");
            if (M === "0") {
                if (m === "0") ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                else ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            } else ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
        $kAJmv("caret return", ret);
        return ret;
    });
};
const $63b582b3058aacef$var$replaceXRanges = (comp, options)=>{
    $kAJmv("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c)=>$63b582b3058aacef$var$replaceXRange(c, options)).join(" ");
};
const $63b582b3058aacef$var$replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.XRANGELOOSE] : $63b582b3058aacef$require$re[$63b582b3058aacef$require$t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        $kAJmv("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = $63b582b3058aacef$var$isX(M);
        const xm = xM || $63b582b3058aacef$var$isX(m);
        const xp = xm || $63b582b3058aacef$var$isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) gtlt = "";
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
            if (gtlt === ">" || gtlt === "<") // nothing is allowed
            ret = "<0.0.0-0";
            else // nothing is forbidden
            ret = "*";
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) m = 0;
            p = 0;
            if (gtlt === ">") {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = ">=";
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === "<=") {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = "<";
                if (xm) M = +M + 1;
                else m = +m + 1;
            }
            if (gtlt === "<") pr = "-0";
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        $kAJmv("xRange return", ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const $63b582b3058aacef$var$replaceStars = (comp, options)=>{
    $kAJmv("replaceStars", comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace($63b582b3058aacef$require$re[$63b582b3058aacef$require$t.STAR], "");
};
const $63b582b3058aacef$var$replaceGTE0 = (comp, options)=>{
    $kAJmv("replaceGTE0", comp, options);
    return comp.trim().replace($63b582b3058aacef$require$re[options.includePrerelease ? $63b582b3058aacef$require$t.GTE0PRE : $63b582b3058aacef$require$t.GTE0], "");
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const $63b582b3058aacef$var$hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb)=>{
        if ($63b582b3058aacef$var$isX(fM)) from = "";
        else if ($63b582b3058aacef$var$isX(fm)) from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        else if ($63b582b3058aacef$var$isX(fp)) from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        else if (fpr) from = `>=${from}`;
        else from = `>=${from}${incPr ? "-0" : ""}`;
        if ($63b582b3058aacef$var$isX(tM)) to = "";
        else if ($63b582b3058aacef$var$isX(tm)) to = `<${+tM + 1}.0.0-0`;
        else if ($63b582b3058aacef$var$isX(tp)) to = `<${tM}.${+tm + 1}.0-0`;
        else if (tpr) to = `<=${tM}.${tm}.${tp}-${tpr}`;
        else if (incPr) to = `<${tM}.${tm}.${+tp + 1}-0`;
        else to = `<=${to}`;
        return `${from} ${to}`.trim();
    };
const $63b582b3058aacef$var$testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) return false;
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            $kAJmv(set[i].semver);
            if (set[i].semver === $aeafedf2d2971e25$exports.ANY) continue;
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};





var $8a5e79e32de102ce$exports = {};

const $8a5e79e32de102ce$var$satisfies = (version, range, options)=>{
    try {
        range = new $63b582b3058aacef$exports(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
$8a5e79e32de102ce$exports = $8a5e79e32de102ce$var$satisfies;


var $622afc0e29b6b365$exports = {};

// Mostly just for testing and legacy API reasons
const $622afc0e29b6b365$var$toComparators = (range, options)=>new $63b582b3058aacef$exports(range, options).set.map((comp)=>comp.map((c)=>c.value).join(" ").trim().split(" "));
$622afc0e29b6b365$exports = $622afc0e29b6b365$var$toComparators;


var $b629ab14a55b3015$exports = {};


const $b629ab14a55b3015$var$maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new $63b582b3058aacef$exports(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) // satisfies(v, range, options)
        {
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new $be5b4f25eb084348$exports(max, options);
            }
        }
    });
    return max;
};
$b629ab14a55b3015$exports = $b629ab14a55b3015$var$maxSatisfying;


var $65cceabb1740be8a$exports = {};


const $65cceabb1740be8a$var$minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new $63b582b3058aacef$exports(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) // satisfies(v, range, options)
        {
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new $be5b4f25eb084348$exports(min, options);
            }
        }
    });
    return min;
};
$65cceabb1740be8a$exports = $65cceabb1740be8a$var$minSatisfying;


var $2ac6db28812f7ce8$exports = {};



const $2ac6db28812f7ce8$var$minVersion = (range, loose)=>{
    range = new $63b582b3058aacef$exports(range, loose);
    let minver = new $be5b4f25eb084348$exports("0.0.0");
    if (range.test(minver)) return minver;
    minver = new $be5b4f25eb084348$exports("0.0.0-0");
    if (range.test(minver)) return minver;
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new $be5b4f25eb084348$exports(comparator.semver.version);
            switch(comparator.operator){
                case ">":
                    if (compver.prerelease.length === 0) compver.patch++;
                    else compver.prerelease.push(0);
                    compver.raw = compver.format();
                /* fallthrough */ case "":
                case ">=":
                    if (!setMin || $ce2e615526098bd1$exports(compver, setMin)) setMin = compver;
                    break;
                case "<":
                case "<=":
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || $ce2e615526098bd1$exports(minver, setMin))) minver = setMin;
    }
    if (minver && range.test(minver)) return minver;
    return null;
};
$2ac6db28812f7ce8$exports = $2ac6db28812f7ce8$var$minVersion;


var $8d192ae46e98a120$exports = {};

const $8d192ae46e98a120$var$validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new $63b582b3058aacef$exports(range, options).range || "*";
    } catch (er) {
        return null;
    }
};
$8d192ae46e98a120$exports = $8d192ae46e98a120$var$validRange;


var $747c18d146306f48$exports = {};


const { ANY: $747c18d146306f48$var$ANY } = $aeafedf2d2971e25$exports;






const $747c18d146306f48$var$outside = (version, range, hilo, options)=>{
    version = new $be5b4f25eb084348$exports(version, options);
    range = new $63b582b3058aacef$exports(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case ">":
            gtfn = $ce2e615526098bd1$exports;
            ltefn = $2da47d08648651b1$exports;
            ltfn = $acb5cfc244b4e718$exports;
            comp = ">";
            ecomp = ">=";
            break;
        case "<":
            gtfn = $acb5cfc244b4e718$exports;
            ltefn = $40fb1ad98b49c054$exports;
            ltfn = $ce2e615526098bd1$exports;
            comp = "<";
            ecomp = "<=";
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if ($8a5e79e32de102ce$exports(version, range, options)) return false;
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === $747c18d146306f48$var$ANY) comparator = new $aeafedf2d2971e25$exports(">=0.0.0");
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) high = comparator;
            else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) return false;
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
        else if (low.operator === ecomp && ltfn(version, low.semver)) return false;
    }
    return true;
};
$747c18d146306f48$exports = $747c18d146306f48$var$outside;


var $68dfc98d904085d2$exports = {};
// Determine if version is greater than all the versions possible in the range.

const $68dfc98d904085d2$var$gtr = (version, range, options)=>$747c18d146306f48$exports(version, range, ">", options);
$68dfc98d904085d2$exports = $68dfc98d904085d2$var$gtr;


var $0b0b8dd9693833b1$exports = {};

// Determine if version is less than all the versions possible in the range
const $0b0b8dd9693833b1$var$ltr = (version, range, options)=>$747c18d146306f48$exports(version, range, "<", options);
$0b0b8dd9693833b1$exports = $0b0b8dd9693833b1$var$ltr;


var $79327e7b64733f9f$exports = {};

const $79327e7b64733f9f$var$intersects = (r1, r2, options)=>{
    r1 = new $63b582b3058aacef$exports(r1, options);
    r2 = new $63b582b3058aacef$exports(r2, options);
    return r1.intersects(r2, options);
};
$79327e7b64733f9f$exports = $79327e7b64733f9f$var$intersects;


var $f3f24d8bd7c4e5ce$exports = {};
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.


$f3f24d8bd7c4e5ce$exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>$e3893a232aa2ca36$exports(a, b, options));
    for (const version of v){
        const included = $8a5e79e32de102ce$exports(version, range, options);
        if (included) {
            prev = version;
            if (!first) first = version;
        } else {
            if (prev) set.push([
                first,
                prev
            ]);
            prev = null;
            first = null;
        }
    }
    if (first) set.push([
        first,
        null
    ]);
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) ranges.push(min);
        else if (!max && min === v[0]) ranges.push("*");
        else if (!max) ranges.push(`>=${min}`);
        else if (min === v[0]) ranges.push(`<=${max}`);
        else ranges.push(`${min} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};


var $18a9f52ae66b1f20$exports = {};


const { ANY: $18a9f52ae66b1f20$var$ANY } = $aeafedf2d2971e25$exports;


// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const $18a9f52ae66b1f20$var$subset = (sub, dom, options = {})=>{
    if (sub === dom) return true;
    sub = new $63b582b3058aacef$exports(sub, options);
    dom = new $63b582b3058aacef$exports(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = $18a9f52ae66b1f20$var$simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) continue OUTER;
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) return false;
    }
    return true;
};
const $18a9f52ae66b1f20$var$minimumVersionWithPreRelease = [
    new $aeafedf2d2971e25$exports(">=0.0.0-0")
];
const $18a9f52ae66b1f20$var$minimumVersion = [
    new $aeafedf2d2971e25$exports(">=0.0.0")
];
const $18a9f52ae66b1f20$var$simpleSubset = (sub, dom, options)=>{
    if (sub === dom) return true;
    if (sub.length === 1 && sub[0].semver === $18a9f52ae66b1f20$var$ANY) {
        if (dom.length === 1 && dom[0].semver === $18a9f52ae66b1f20$var$ANY) return true;
        else if (options.includePrerelease) sub = $18a9f52ae66b1f20$var$minimumVersionWithPreRelease;
        else sub = $18a9f52ae66b1f20$var$minimumVersion;
    }
    if (dom.length === 1 && dom[0].semver === $18a9f52ae66b1f20$var$ANY) {
        if (options.includePrerelease) return true;
        else dom = $18a9f52ae66b1f20$var$minimumVersion;
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === ">" || c.operator === ">=") gt = $18a9f52ae66b1f20$var$higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=") lt = $18a9f52ae66b1f20$var$lowerLT(lt, c, options);
        else eqSet.add(c.semver);
    }
    if (eqSet.size > 1) return null;
    let gtltComp;
    if (gt && lt) {
        gtltComp = $e3893a232aa2ca36$exports(gt.semver, lt.semver, options);
        if (gtltComp > 0) return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) return null;
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !$8a5e79e32de102ce$exports(eq, String(gt), options)) return null;
        if (lt && !$8a5e79e32de102ce$exports(eq, String(lt), options)) return null;
        for (const c of dom){
            if (!$8a5e79e32de102ce$exports(eq, String(c), options)) return false;
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) needDomLTPre = false;
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) needDomGTPre = false;
            }
            if (c.operator === ">" || c.operator === ">=") {
                higher = $18a9f52ae66b1f20$var$higherGT(gt, c, options);
                if (higher === c && higher !== gt) return false;
            } else if (gt.operator === ">=" && !$8a5e79e32de102ce$exports(gt.semver, String(c), options)) return false;
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) needDomLTPre = false;
            }
            if (c.operator === "<" || c.operator === "<=") {
                lower = $18a9f52ae66b1f20$var$lowerLT(lt, c, options);
                if (lower === c && lower !== lt) return false;
            } else if (lt.operator === "<=" && !$8a5e79e32de102ce$exports(lt.semver, String(c), options)) return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) return false;
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) return false;
    return true;
};
// >=1.2.3 is lower than >1.2.3
const $18a9f52ae66b1f20$var$higherGT = (a, b, options)=>{
    if (!a) return b;
    const comp = $e3893a232aa2ca36$exports(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const $18a9f52ae66b1f20$var$lowerLT = (a, b, options)=>{
    if (!a) return b;
    const comp = $e3893a232aa2ca36$exports(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
$18a9f52ae66b1f20$exports = $18a9f52ae66b1f20$var$subset;


$6f38c44ac5aebb4f$exports = {
    parse: $d793791160a9ca3e$exports,
    valid: $9dbc064d08157fde$exports,
    clean: $d87f2d78cb92ca25$exports,
    inc: $705b8af747a198b3$exports,
    diff: $763ad2369f72148e$exports,
    major: $e3f7484f82706e16$exports,
    minor: $530023fc4b46c747$exports,
    patch: $f6f81ec9c06bfccd$exports,
    prerelease: $68d42bacbb289d7b$exports,
    compare: $e3893a232aa2ca36$exports,
    rcompare: $bef5534db7b26890$exports,
    compareLoose: $bbe64750043da469$exports,
    compareBuild: $626d39458b1181ce$exports,
    sort: $d409fa5d8babf1f6$exports,
    rsort: $2a85514ae626f8e3$exports,
    gt: $ce2e615526098bd1$exports,
    lt: $acb5cfc244b4e718$exports,
    eq: $aeca99fa223731af$exports,
    neq: $7844da3608efd6b5$exports,
    gte: $40fb1ad98b49c054$exports,
    lte: $2da47d08648651b1$exports,
    cmp: $40a512d771dfd461$exports,
    coerce: $d821b1fee0b78495$exports,
    Comparator: $aeafedf2d2971e25$exports,
    Range: $63b582b3058aacef$exports,
    satisfies: $8a5e79e32de102ce$exports,
    toComparators: $622afc0e29b6b365$exports,
    maxSatisfying: $b629ab14a55b3015$exports,
    minSatisfying: $65cceabb1740be8a$exports,
    minVersion: $2ac6db28812f7ce8$exports,
    validRange: $8d192ae46e98a120$exports,
    outside: $747c18d146306f48$exports,
    gtr: $68dfc98d904085d2$exports,
    ltr: $0b0b8dd9693833b1$exports,
    intersects: $79327e7b64733f9f$exports,
    simplifyRange: $f3f24d8bd7c4e5ce$exports,
    subset: $18a9f52ae66b1f20$exports,
    SemVer: $be5b4f25eb084348$exports,
    re: $b95lY.re,
    src: $b95lY.src,
    tokens: $b95lY.t,
    SEMVER_SPEC_VERSION: $kRlLP.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: $kRlLP.RELEASE_TYPES,
    compareIdentifiers: $f3570640aab49284$exports.compareIdentifiers,
    rcompareIdentifiers: $f3570640aab49284$exports.rcompareIdentifiers
};


// These agent options are chosen to match the npm client defaults and help with performance
// See: `npm config get maxsockets` and #50
const $a0405763bafae21d$var$agentOptions = {
    keepAlive: true,
    maxSockets: 50
};
const $a0405763bafae21d$var$httpAgent = new (0, $dAk3n$nodehttp.Agent)($a0405763bafae21d$var$agentOptions);
const $a0405763bafae21d$var$httpsAgent = new (0, $dAk3n$nodehttps.Agent)($a0405763bafae21d$var$agentOptions);
class $a0405763bafae21d$export$4b2bb69e64095e19 extends Error {
    constructor(packageName){
        super(`Package \`${packageName}\` could not be found`);
        this.name = "PackageNotFoundError";
    }
}
class $a0405763bafae21d$export$bd574ac0eb3da099 extends Error {
    constructor(packageName, version){
        super(`Version \`${version}\` for package \`${packageName}\` could not be found`);
        this.name = "VersionNotFoundError";
    }
}
async function $a0405763bafae21d$export$2e2bcd8739ae039(packageName, options) {
    options = {
        version: "latest",
        ...options
    };
    const scope = packageName.split("/")[0];
    const registryUrl_ = options.registryUrl || (0, $9f0f0be5e21eca3a$export$2e2bcd8739ae039)(scope);
    const packageUrl = new URL(encodeURIComponent(packageName).replace(/^%40/, "@"), registryUrl_);
    const authInfo = (0, (/*@__PURE__*/$parcel$interopDefault($88ef39e7e8a3750c$exports)))(registryUrl_.toString(), {
        recursive: true
    });
    const headers = {
        accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
    };
    if (options.fullMetadata) delete headers.accept;
    if (authInfo) headers.authorization = `${authInfo.type} ${authInfo.token}`;
    const gotOptions = {
        headers: headers,
        agent: {
            http: $a0405763bafae21d$var$httpAgent,
            https: $a0405763bafae21d$var$httpsAgent
        }
    };
    if (options.agent) gotOptions.agent = options.agent;
    let data;
    try {
        data = await (0, $466d778d0565266d$export$2e2bcd8739ae039)(packageUrl, gotOptions).json();
    } catch (error) {
        if (error?.response?.statusCode === 404) throw new $a0405763bafae21d$export$4b2bb69e64095e19(packageName);
        throw error;
    }
    if (options.allVersions) return data;
    let { version: version } = options;
    const versionError = new $a0405763bafae21d$export$bd574ac0eb3da099(packageName, version);
    if (data["dist-tags"][version]) {
        const time = data.time;
        data = data.versions[data["dist-tags"][version]];
        data.time = time;
    } else if (version) {
        if (!data.versions[version]) {
            const versions = Object.keys(data.versions);
            version = (0, (/*@__PURE__*/$parcel$interopDefault($6f38c44ac5aebb4f$exports))).maxSatisfying(versions, version);
            if (!version) throw versionError;
        }
        const time = data.time;
        data = data.versions[version];
        data.time = time;
        if (!data) throw versionError;
    }
    return data;
}


async function $2d0e8569f207513b$export$2e2bcd8739ae039(packageName, options) {
    const { version: version } = await (0, $a0405763bafae21d$export$2e2bcd8739ae039)(packageName.toLowerCase(), options);
    return version;
}


function $339004cb28bc6ac3$export$342063e11d6c3cad(input = "") {
    if (!input || !input.includes("\\")) return input;
    return input.replace(/\\/g, "/");
}
const $339004cb28bc6ac3$var$_UNC_REGEX = /^[/\\]{2}/;
const $339004cb28bc6ac3$var$_IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const $339004cb28bc6ac3$var$_DRIVE_LETTER_RE = /^[A-Za-z]:$/;
const $339004cb28bc6ac3$export$2408f22a0fab9ae5 = "/";
const $339004cb28bc6ac3$export$4368d992c4eafac0 = ":";
const $339004cb28bc6ac3$export$7ccc53e8f1e7dfc5 = function(path) {
    if (path.length === 0) return ".";
    path = $339004cb28bc6ac3$export$342063e11d6c3cad(path);
    const isUNCPath = path.match($339004cb28bc6ac3$var$_UNC_REGEX);
    const isPathAbsolute = $339004cb28bc6ac3$export$23f2a1d2818174ef(path);
    const trailingSeparator = path[path.length - 1] === "/";
    path = $339004cb28bc6ac3$export$407448d2b89b1813(path, !isPathAbsolute);
    if (path.length === 0) {
        if (isPathAbsolute) return "/";
        return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator) path += "/";
    if ($339004cb28bc6ac3$var$_DRIVE_LETTER_RE.test(path)) path += "/";
    if (isUNCPath) {
        if (!isPathAbsolute) return `//./${path}`;
        return `//${path}`;
    }
    return isPathAbsolute && !$339004cb28bc6ac3$export$23f2a1d2818174ef(path) ? `/${path}` : path;
};
const $339004cb28bc6ac3$export$35e795649ee09318 = function(...arguments_) {
    if (arguments_.length === 0) return ".";
    let joined;
    for (const argument of arguments_)if (argument && argument.length > 0) {
        if (joined === void 0) joined = argument;
        else joined += `/${argument}`;
    }
    if (joined === void 0) return ".";
    return $339004cb28bc6ac3$export$7ccc53e8f1e7dfc5(joined.replace(/\/\/+/g, "/"));
};
function $339004cb28bc6ac3$var$cwd() {
    if (typeof globalThis.process !== "undefined") return globalThis.process.cwd().replace(/\\/g, "/");
    return "/";
}
const $339004cb28bc6ac3$export$43caf9889c228507 = function(...arguments_) {
    arguments_ = arguments_.map((argument)=>$339004cb28bc6ac3$export$342063e11d6c3cad(argument));
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--){
        const path = index >= 0 ? arguments_[index] : $339004cb28bc6ac3$var$cwd();
        if (!path || path.length === 0) continue;
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = $339004cb28bc6ac3$export$23f2a1d2818174ef(path);
    }
    resolvedPath = $339004cb28bc6ac3$export$407448d2b89b1813(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute && !$339004cb28bc6ac3$export$23f2a1d2818174ef(resolvedPath)) return `/${resolvedPath}`;
    return resolvedPath.length > 0 ? resolvedPath : ".";
};
function $339004cb28bc6ac3$export$407448d2b89b1813(path, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let char = null;
    for(let index = 0; index <= path.length; ++index){
        if (index < path.length) char = path[index];
        else if (char === "/") break;
        else char = "/";
        if (char === "/") {
            if (lastSlash === index - 1 || dots === 1) ;
            else if (dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                        }
                        lastSlash = index;
                        dots = 0;
                        continue;
                    } else if (res.length > 0) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = index;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    res += res.length > 0 ? "/.." : "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += `/${path.slice(lastSlash + 1, index)}`;
                else res = path.slice(lastSlash + 1, index);
                lastSegmentLength = index - lastSlash - 1;
            }
            lastSlash = index;
            dots = 0;
        } else if (char === "." && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
const $339004cb28bc6ac3$export$23f2a1d2818174ef = function(p) {
    return $339004cb28bc6ac3$var$_IS_ABSOLUTE_RE.test(p);
};
const $339004cb28bc6ac3$export$625550452a3fa3ec = function(p) {
    return $339004cb28bc6ac3$export$342063e11d6c3cad(p);
};
const $339004cb28bc6ac3$var$_EXTNAME_RE = /.(\.[^./]+)$/;
const $339004cb28bc6ac3$export$f1e1789686576879 = function(p) {
    const match = $339004cb28bc6ac3$var$_EXTNAME_RE.exec($339004cb28bc6ac3$export$342063e11d6c3cad(p));
    return match && match[1] || "";
};
const $339004cb28bc6ac3$export$8b22cf2602fb60ce = function(from, to) {
    const _from = $339004cb28bc6ac3$export$43caf9889c228507(from).split("/");
    const _to = $339004cb28bc6ac3$export$43caf9889c228507(to).split("/");
    const _fromCopy = [
        ..._from
    ];
    for (const segment of _fromCopy){
        if (_to[0] !== segment) break;
        _from.shift();
        _to.shift();
    }
    return [
        ..._from.map(()=>".."),
        ..._to
    ].join("/");
};
const $339004cb28bc6ac3$export$db3b6bfb95261072 = function(p) {
    const segments = $339004cb28bc6ac3$export$342063e11d6c3cad(p).replace(/\/$/, "").split("/").slice(0, -1);
    if (segments.length === 1 && $339004cb28bc6ac3$var$_DRIVE_LETTER_RE.test(segments[0])) segments[0] += "/";
    return segments.join("/") || ($339004cb28bc6ac3$export$23f2a1d2818174ef(p) ? "/" : ".");
};
const $339004cb28bc6ac3$export$2d1720544b23b823 = function(p) {
    const segments = [
        p.root,
        p.dir,
        p.base ?? p.name + p.ext
    ].filter(Boolean);
    return $339004cb28bc6ac3$export$342063e11d6c3cad(p.root ? $339004cb28bc6ac3$export$43caf9889c228507(...segments) : segments.join("/"));
};
const $339004cb28bc6ac3$export$39b482c5e57630a8 = function(p, extension) {
    const lastSegment = $339004cb28bc6ac3$export$342063e11d6c3cad(p).split("/").pop();
    return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
};
const $339004cb28bc6ac3$export$dda1d9f60106f0e9 = function(p) {
    const root = $339004cb28bc6ac3$export$342063e11d6c3cad(p).split("/").shift() || "/";
    const base = $339004cb28bc6ac3$export$39b482c5e57630a8(p);
    const extension = $339004cb28bc6ac3$export$f1e1789686576879(base);
    return {
        root: root,
        dir: $339004cb28bc6ac3$export$db3b6bfb95261072(p),
        base: base,
        ext: extension,
        name: base.slice(0, base.length - extension.length)
    };
};
const $339004cb28bc6ac3$export$ffb5f4729a158638 = {
    __proto__: null,
    basename: $339004cb28bc6ac3$export$39b482c5e57630a8,
    delimiter: $339004cb28bc6ac3$export$4368d992c4eafac0,
    dirname: $339004cb28bc6ac3$export$db3b6bfb95261072,
    extname: $339004cb28bc6ac3$export$f1e1789686576879,
    format: $339004cb28bc6ac3$export$2d1720544b23b823,
    isAbsolute: $339004cb28bc6ac3$export$23f2a1d2818174ef,
    join: $339004cb28bc6ac3$export$35e795649ee09318,
    normalize: $339004cb28bc6ac3$export$7ccc53e8f1e7dfc5,
    normalizeString: $339004cb28bc6ac3$export$407448d2b89b1813,
    parse: $339004cb28bc6ac3$export$dda1d9f60106f0e9,
    relative: $339004cb28bc6ac3$export$8b22cf2602fb60ce,
    resolve: $339004cb28bc6ac3$export$43caf9889c228507,
    sep: $339004cb28bc6ac3$export$2408f22a0fab9ae5,
    toNamespacedPath: $339004cb28bc6ac3$export$625550452a3fa3ec
};






var $24ac6a41d0d29df9$exports = {};
"use strict";
var $04332ca065c38d8b$exports = {};
"use strict";
$04332ca065c38d8b$exports = (input)=>{
    const buf = new Uint8Array(input);
    if (!(buf && buf.length > 1)) return null;
    const check = (header, opts)=>{
        opts = Object.assign({
            offset: 0
        }, opts);
        for(let i = 0; i < header.length; i++){
            if (header[i] !== buf[i + opts.offset]) return false;
        }
        return true;
    };
    if (check([
        0xFF,
        0xD8,
        0xFF
    ])) return {
        ext: "jpg",
        mime: "image/jpeg"
    };
    if (check([
        0x89,
        0x50,
        0x4E,
        0x47,
        0x0D,
        0x0A,
        0x1A,
        0x0A
    ])) return {
        ext: "png",
        mime: "image/png"
    };
    if (check([
        0x47,
        0x49,
        0x46
    ])) return {
        ext: "gif",
        mime: "image/gif"
    };
    if (check([
        0x57,
        0x45,
        0x42,
        0x50
    ], {
        offset: 8
    })) return {
        ext: "webp",
        mime: "image/webp"
    };
    if (check([
        0x46,
        0x4C,
        0x49,
        0x46
    ])) return {
        ext: "flif",
        mime: "image/flif"
    };
    // Needs to be before `tif` check
    if ((check([
        0x49,
        0x49,
        0x2A,
        0x0
    ]) || check([
        0x4D,
        0x4D,
        0x0,
        0x2A
    ])) && check([
        0x43,
        0x52
    ], {
        offset: 8
    })) return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
    };
    if (check([
        0x49,
        0x49,
        0x2A,
        0x0
    ]) || check([
        0x4D,
        0x4D,
        0x0,
        0x2A
    ])) return {
        ext: "tif",
        mime: "image/tiff"
    };
    if (check([
        0x42,
        0x4D
    ])) return {
        ext: "bmp",
        mime: "image/bmp"
    };
    if (check([
        0x49,
        0x49,
        0xBC
    ])) return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
    };
    if (check([
        0x38,
        0x42,
        0x50,
        0x53
    ])) return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
    };
    // Needs to be before the `zip` check
    if (check([
        0x50,
        0x4B,
        0x3,
        0x4
    ]) && check([
        0x6D,
        0x69,
        0x6D,
        0x65,
        0x74,
        0x79,
        0x70,
        0x65,
        0x61,
        0x70,
        0x70,
        0x6C,
        0x69,
        0x63,
        0x61,
        0x74,
        0x69,
        0x6F,
        0x6E,
        0x2F,
        0x65,
        0x70,
        0x75,
        0x62,
        0x2B,
        0x7A,
        0x69,
        0x70
    ], {
        offset: 30
    })) return {
        ext: "epub",
        mime: "application/epub+zip"
    };
    // Needs to be before `zip` check
    // Assumes signed `.xpi` from addons.mozilla.org
    if (check([
        0x50,
        0x4B,
        0x3,
        0x4
    ]) && check([
        0x4D,
        0x45,
        0x54,
        0x41,
        0x2D,
        0x49,
        0x4E,
        0x46,
        0x2F,
        0x6D,
        0x6F,
        0x7A,
        0x69,
        0x6C,
        0x6C,
        0x61,
        0x2E,
        0x72,
        0x73,
        0x61
    ], {
        offset: 30
    })) return {
        ext: "xpi",
        mime: "application/x-xpinstall"
    };
    if (check([
        0x50,
        0x4B
    ]) && (buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) && (buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)) return {
        ext: "zip",
        mime: "application/zip"
    };
    if (check([
        0x75,
        0x73,
        0x74,
        0x61,
        0x72
    ], {
        offset: 257
    })) return {
        ext: "tar",
        mime: "application/x-tar"
    };
    if (check([
        0x52,
        0x61,
        0x72,
        0x21,
        0x1A,
        0x7
    ]) && (buf[6] === 0x0 || buf[6] === 0x1)) return {
        ext: "rar",
        mime: "application/x-rar-compressed"
    };
    if (check([
        0x1F,
        0x8B,
        0x8
    ])) return {
        ext: "gz",
        mime: "application/gzip"
    };
    if (check([
        0x42,
        0x5A,
        0x68
    ])) return {
        ext: "bz2",
        mime: "application/x-bzip2"
    };
    if (check([
        0x37,
        0x7A,
        0xBC,
        0xAF,
        0x27,
        0x1C
    ])) return {
        ext: "7z",
        mime: "application/x-7z-compressed"
    };
    if (check([
        0x78,
        0x01
    ])) return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
    };
    if (check([
        0x0,
        0x0,
        0x0
    ]) && (buf[3] === 0x18 || buf[3] === 0x20) && check([
        0x66,
        0x74,
        0x79,
        0x70
    ], {
        offset: 4
    }) || check([
        0x33,
        0x67,
        0x70,
        0x35
    ]) || check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x6D,
        0x70,
        0x34,
        0x32
    ]) && check([
        0x6D,
        0x70,
        0x34,
        0x31,
        0x6D,
        0x70,
        0x34,
        0x32,
        0x69,
        0x73,
        0x6F,
        0x6D
    ], {
        offset: 16
    }) || check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x69,
        0x73,
        0x6F,
        0x6D
    ]) || check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x6D,
        0x70,
        0x34,
        0x32,
        0x0,
        0x0,
        0x0,
        0x0
    ])) return {
        ext: "mp4",
        mime: "video/mp4"
    };
    if (check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x4D,
        0x34,
        0x56
    ])) return {
        ext: "m4v",
        mime: "video/x-m4v"
    };
    if (check([
        0x4D,
        0x54,
        0x68,
        0x64
    ])) return {
        ext: "mid",
        mime: "audio/midi"
    };
    // https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
    if (check([
        0x1A,
        0x45,
        0xDF,
        0xA3
    ])) {
        const sliced = buf.subarray(4, 4100);
        const idPos = sliced.findIndex((el, i, arr)=>arr[i] === 0x42 && arr[i + 1] === 0x82);
        if (idPos >= 0) {
            const docTypePos = idPos + 3;
            const findDocType = (type)=>Array.from(type).every((c, i)=>sliced[docTypePos + i] === c.charCodeAt(0));
            if (findDocType("matroska")) return {
                ext: "mkv",
                mime: "video/x-matroska"
            };
            if (findDocType("webm")) return {
                ext: "webm",
                mime: "video/webm"
            };
        }
    }
    if (check([
        0x0,
        0x0,
        0x0,
        0x14,
        0x66,
        0x74,
        0x79,
        0x70,
        0x71,
        0x74,
        0x20,
        0x20
    ]) || check([
        0x66,
        0x72,
        0x65,
        0x65
    ], {
        offset: 4
    }) || check([
        0x66,
        0x74,
        0x79,
        0x70,
        0x71,
        0x74,
        0x20,
        0x20
    ], {
        offset: 4
    }) || check([
        0x6D,
        0x64,
        0x61,
        0x74
    ], {
        offset: 4
    }) || // MJPEG
    check([
        0x77,
        0x69,
        0x64,
        0x65
    ], {
        offset: 4
    })) return {
        ext: "mov",
        mime: "video/quicktime"
    };
    if (check([
        0x52,
        0x49,
        0x46,
        0x46
    ]) && check([
        0x41,
        0x56,
        0x49
    ], {
        offset: 8
    })) return {
        ext: "avi",
        mime: "video/x-msvideo"
    };
    if (check([
        0x30,
        0x26,
        0xB2,
        0x75,
        0x8E,
        0x66,
        0xCF,
        0x11,
        0xA6,
        0xD9
    ])) return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
    };
    if (check([
        0x0,
        0x0,
        0x1,
        0xBA
    ])) return {
        ext: "mpg",
        mime: "video/mpeg"
    };
    if (check([
        0x49,
        0x44,
        0x33
    ]) || check([
        0xFF,
        0xFB
    ])) return {
        ext: "mp3",
        mime: "audio/mpeg"
    };
    if (check([
        0x66,
        0x74,
        0x79,
        0x70,
        0x4D,
        0x34,
        0x41
    ], {
        offset: 4
    }) || check([
        0x4D,
        0x34,
        0x41,
        0x20
    ])) return {
        ext: "m4a",
        mime: "audio/m4a"
    };
    // Needs to be before `ogg` check
    if (check([
        0x4F,
        0x70,
        0x75,
        0x73,
        0x48,
        0x65,
        0x61,
        0x64
    ], {
        offset: 28
    })) return {
        ext: "opus",
        mime: "audio/opus"
    };
    if (check([
        0x4F,
        0x67,
        0x67,
        0x53
    ])) return {
        ext: "ogg",
        mime: "audio/ogg"
    };
    if (check([
        0x66,
        0x4C,
        0x61,
        0x43
    ])) return {
        ext: "flac",
        mime: "audio/x-flac"
    };
    if (check([
        0x52,
        0x49,
        0x46,
        0x46
    ]) && check([
        0x57,
        0x41,
        0x56,
        0x45
    ], {
        offset: 8
    })) return {
        ext: "wav",
        mime: "audio/x-wav"
    };
    if (check([
        0x23,
        0x21,
        0x41,
        0x4D,
        0x52,
        0x0A
    ])) return {
        ext: "amr",
        mime: "audio/amr"
    };
    if (check([
        0x25,
        0x50,
        0x44,
        0x46
    ])) return {
        ext: "pdf",
        mime: "application/pdf"
    };
    if (check([
        0x4D,
        0x5A
    ])) return {
        ext: "exe",
        mime: "application/x-msdownload"
    };
    if ((buf[0] === 0x43 || buf[0] === 0x46) && check([
        0x57,
        0x53
    ], {
        offset: 1
    })) return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
    };
    if (check([
        0x7B,
        0x5C,
        0x72,
        0x74,
        0x66
    ])) return {
        ext: "rtf",
        mime: "application/rtf"
    };
    if (check([
        0x00,
        0x61,
        0x73,
        0x6D
    ])) return {
        ext: "wasm",
        mime: "application/wasm"
    };
    if (check([
        0x77,
        0x4F,
        0x46,
        0x46
    ]) && (check([
        0x00,
        0x01,
        0x00,
        0x00
    ], {
        offset: 4
    }) || check([
        0x4F,
        0x54,
        0x54,
        0x4F
    ], {
        offset: 4
    }))) return {
        ext: "woff",
        mime: "application/font-woff"
    };
    if (check([
        0x77,
        0x4F,
        0x46,
        0x32
    ]) && (check([
        0x00,
        0x01,
        0x00,
        0x00
    ], {
        offset: 4
    }) || check([
        0x4F,
        0x54,
        0x54,
        0x4F
    ], {
        offset: 4
    }))) return {
        ext: "woff2",
        mime: "application/font-woff"
    };
    if (check([
        0x4C,
        0x50
    ], {
        offset: 34
    }) && (check([
        0x00,
        0x00,
        0x01
    ], {
        offset: 8
    }) || check([
        0x01,
        0x00,
        0x02
    ], {
        offset: 8
    }) || check([
        0x02,
        0x00,
        0x02
    ], {
        offset: 8
    }))) return {
        ext: "eot",
        mime: "application/octet-stream"
    };
    if (check([
        0x00,
        0x01,
        0x00,
        0x00,
        0x00
    ])) return {
        ext: "ttf",
        mime: "application/font-sfnt"
    };
    if (check([
        0x4F,
        0x54,
        0x54,
        0x4F,
        0x00
    ])) return {
        ext: "otf",
        mime: "application/font-sfnt"
    };
    if (check([
        0x00,
        0x00,
        0x01,
        0x00
    ])) return {
        ext: "ico",
        mime: "image/x-icon"
    };
    if (check([
        0x46,
        0x4C,
        0x56,
        0x01
    ])) return {
        ext: "flv",
        mime: "video/x-flv"
    };
    if (check([
        0x25,
        0x21
    ])) return {
        ext: "ps",
        mime: "application/postscript"
    };
    if (check([
        0xFD,
        0x37,
        0x7A,
        0x58,
        0x5A,
        0x00
    ])) return {
        ext: "xz",
        mime: "application/x-xz"
    };
    if (check([
        0x53,
        0x51,
        0x4C,
        0x69
    ])) return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
    };
    if (check([
        0x4E,
        0x45,
        0x53,
        0x1A
    ])) return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
    };
    if (check([
        0x43,
        0x72,
        0x32,
        0x34
    ])) return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
    };
    if (check([
        0x4D,
        0x53,
        0x43,
        0x46
    ]) || check([
        0x49,
        0x53,
        0x63,
        0x28
    ])) return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
    };
    // Needs to be before `ar` check
    if (check([
        0x21,
        0x3C,
        0x61,
        0x72,
        0x63,
        0x68,
        0x3E,
        0x0A,
        0x64,
        0x65,
        0x62,
        0x69,
        0x61,
        0x6E,
        0x2D,
        0x62,
        0x69,
        0x6E,
        0x61,
        0x72,
        0x79
    ])) return {
        ext: "deb",
        mime: "application/x-deb"
    };
    if (check([
        0x21,
        0x3C,
        0x61,
        0x72,
        0x63,
        0x68,
        0x3E
    ])) return {
        ext: "ar",
        mime: "application/x-unix-archive"
    };
    if (check([
        0xED,
        0xAB,
        0xEE,
        0xDB
    ])) return {
        ext: "rpm",
        mime: "application/x-rpm"
    };
    if (check([
        0x1F,
        0xA0
    ]) || check([
        0x1F,
        0x9D
    ])) return {
        ext: "Z",
        mime: "application/x-compress"
    };
    if (check([
        0x4C,
        0x5A,
        0x49,
        0x50
    ])) return {
        ext: "lz",
        mime: "application/x-lzip"
    };
    if (check([
        0xD0,
        0xCF,
        0x11,
        0xE0,
        0xA1,
        0xB1,
        0x1A,
        0xE1
    ])) return {
        ext: "msi",
        mime: "application/x-msi"
    };
    if (check([
        0x06,
        0x0E,
        0x2B,
        0x34,
        0x02,
        0x05,
        0x01,
        0x01,
        0x0D,
        0x01,
        0x02,
        0x01,
        0x01,
        0x02
    ])) return {
        ext: "mxf",
        mime: "application/mxf"
    };
    if (check([
        0x42,
        0x4C,
        0x45,
        0x4E,
        0x44,
        0x45,
        0x52
    ])) return {
        ext: "blend",
        mime: "application/x-blender"
    };
    return null;
};


const $24ac6a41d0d29df9$var$exts = new Set([
    "7z",
    "bz2",
    "gz",
    "rar",
    "tar",
    "zip",
    "xz",
    "gz"
]);
$24ac6a41d0d29df9$exports = (input)=>{
    const ret = $04332ca065c38d8b$exports(input);
    return $24ac6a41d0d29df9$var$exts.has(ret && ret.ext) ? ret : null;
};


var $a11285a33b616655$exports = {};
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ "use strict";
/**
 * Module exports.
 * @public
 */ $a11285a33b616655$exports = $a11285a33b616655$var$contentDisposition;
$a11285a33b616655$exports.parse = $a11285a33b616655$var$parse;

var $a11285a33b616655$require$basename = $dAk3n$path.basename;

var $2uDEU = parcelRequire("2uDEU");
var $a11285a33b616655$require$Buffer = $2uDEU.Buffer;
/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */ var $a11285a33b616655$var$ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match percent encoding escape.
 * @private
 */ var $a11285a33b616655$var$HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var $a11285a33b616655$var$HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
/**
 * RegExp to match non-latin1 characters.
 * @private
 */ var $a11285a33b616655$var$NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */ var $a11285a33b616655$var$QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */ var $a11285a33b616655$var$QUOTE_REGEXP = /([\\"])/g;
/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */ var $a11285a33b616655$var$PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
;
var $a11285a33b616655$var$TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
var $a11285a33b616655$var$TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */ var $a11285a33b616655$var$EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */ var $a11285a33b616655$var$DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex
;
/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */ function $a11285a33b616655$var$contentDisposition(filename, options) {
    var opts = options || {};
    // get type
    var type = opts.type || "attachment";
    // get parameters
    var params = $a11285a33b616655$var$createparams(filename, opts.fallback);
    // format into string
    return $a11285a33b616655$var$format(new $a11285a33b616655$var$ContentDisposition(type, params));
}
/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */ function $a11285a33b616655$var$createparams(filename, fallback) {
    if (filename === undefined) return;
    var params = {};
    if (typeof filename !== "string") throw new TypeError("filename must be a string");
    // fallback defaults to true
    if (fallback === undefined) fallback = true;
    if (typeof fallback !== "string" && typeof fallback !== "boolean") throw new TypeError("fallback must be a string or boolean");
    if (typeof fallback === "string" && $a11285a33b616655$var$NON_LATIN1_REGEXP.test(fallback)) throw new TypeError("fallback must be ISO-8859-1 string");
    // restrict to file base name
    var name = $a11285a33b616655$require$basename(filename);
    // determine if name is suitable for quoted string
    var isQuotedString = $a11285a33b616655$var$TEXT_REGEXP.test(name);
    // generate fallback name
    var fallbackName = typeof fallback !== "string" ? fallback && $a11285a33b616655$var$getlatin1(name) : $a11285a33b616655$require$basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    // set extended filename parameter
    if (hasFallback || !isQuotedString || $a11285a33b616655$var$HEX_ESCAPE_REGEXP.test(name)) params["filename*"] = name;
    // set filename parameter
    if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
    return params;
}
/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$format(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== "string" || !$a11285a33b616655$var$TOKEN_REGEXP.test(type)) throw new TypeError("invalid type");
    // start with normalized type
    var string = String(type).toLowerCase();
    // append parameters
    if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for(var i = 0; i < params.length; i++){
            param = params[i];
            var val = param.substr(-1) === "*" ? $a11285a33b616655$var$ustring(parameters[param]) : $a11285a33b616655$var$qstring(parameters[param]);
            string += "; " + param + "=" + val;
        }
    }
    return string;
}
/**
 * Decode a RFC 5987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$decodefield(str) {
    var match = $a11285a33b616655$var$EXT_VALUE_REGEXP.exec(str);
    if (!match) throw new TypeError("invalid extended field value");
    var charset = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    // to binary string
    var binary = encoded.replace($a11285a33b616655$var$HEX_ESCAPE_REPLACE_REGEXP, $a11285a33b616655$var$pdecode);
    switch(charset){
        case "iso-8859-1":
            value = $a11285a33b616655$var$getlatin1(binary);
            break;
        case "utf-8":
            value = $a11285a33b616655$require$Buffer.from(binary, "binary").toString("utf8");
            break;
        default:
            throw new TypeError("unsupported charset in extended field");
    }
    return value;
}
/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$getlatin1(val) {
    // simple Unicode -> ISO-8859-1 transformation
    return String(val).replace($a11285a33b616655$var$NON_LATIN1_REGEXP, "?");
}
/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */ function $a11285a33b616655$var$parse(string) {
    if (!string || typeof string !== "string") throw new TypeError("argument string is required");
    var match = $a11285a33b616655$var$DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) throw new TypeError("invalid type format");
    // normalize type
    var index = match[0].length;
    var type = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    // calculate index to start at
    index = $a11285a33b616655$var$PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
    // match parameters
    while(match = $a11285a33b616655$var$PARAM_REGEXP.exec(string)){
        if (match.index !== index) throw new TypeError("invalid parameter format");
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) throw new TypeError("invalid duplicate parameter");
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
            // decode extended value
            key = key.slice(0, -1);
            value = $a11285a33b616655$var$decodefield(value);
            // overwrite existing value
            params[key] = value;
            continue;
        }
        if (typeof params[key] === "string") continue;
        if (value[0] === '"') // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace($a11285a33b616655$var$QESC_REGEXP, "$1");
        params[key] = value;
    }
    if (index !== -1 && index !== string.length) throw new TypeError("invalid parameter format");
    return new $a11285a33b616655$var$ContentDisposition(type, params);
}
/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
}
/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
}
/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$qstring(val) {
    var str = String(val);
    return '"' + str.replace($a11285a33b616655$var$QUOTE_REGEXP, "\\$1") + '"';
}
/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function $a11285a33b616655$var$ustring(val) {
    var str = String(val);
    // percent encode as UTF-8
    var encoded = encodeURIComponent(str).replace($a11285a33b616655$var$ENCODE_URL_ATTR_CHAR_REGEXP, $a11285a33b616655$var$pencode);
    return "UTF-8''" + encoded;
}
/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */ function $a11285a33b616655$var$ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
}


var $f51ecae46f19a31a$exports = {};
"use strict";

var $09851ef183fe50e4$exports = {};

var $062562a8c609a3b7$exports = {};

var $062562a8c609a3b7$var$origCwd = process.cwd;
var $062562a8c609a3b7$var$cwd = null;
var $062562a8c609a3b7$var$platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!$062562a8c609a3b7$var$cwd) $062562a8c609a3b7$var$cwd = $062562a8c609a3b7$var$origCwd.call(process);
    return $062562a8c609a3b7$var$cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === "function") {
    var $062562a8c609a3b7$var$chdir = process.chdir;
    process.chdir = function(d) {
        $062562a8c609a3b7$var$cwd = null;
        $062562a8c609a3b7$var$chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, $062562a8c609a3b7$var$chdir);
}
$062562a8c609a3b7$exports = $062562a8c609a3b7$var$patch;
function $062562a8c609a3b7$var$patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if ($dAk3n$constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs);
    // lutimes implementation, or no-op
    if (!fs.lutimes) patchLutimes(fs);
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if ($062562a8c609a3b7$var$platform === "win32") fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
                if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                    setTimeout(function() {
                        fs.stat(to, function(stater, st) {
                            if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                            else cb(er);
                        });
                    }, backoff);
                    if (backoff < 100) backoff += 10;
                    return;
                }
                if (cb) cb(er);
            });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
    }(fs.rename);
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === "function") {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true)try {
                return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
                if (er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    continue;
                }
                throw er;
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, $dAk3n$constants.O_WRONLY | $dAk3n$constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, $dAk3n$constants.O_WRONLY | $dAk3n$constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) try {
                    fs.closeSync(fd);
                } catch (er) {}
                else fs.closeSync(fd);
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if ($dAk3n$constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, $dAk3n$constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, $dAk3n$constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) try {
                        fs.closeSync(fd);
                    } catch (er) {}
                    else fs.closeSync(fd);
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === "function") {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}


var $e1c978209356d5b7$exports = {};

var $e1c978209356d5b7$require$Stream = $dAk3n$stream.Stream;
$e1c978209356d5b7$exports = $e1c978209356d5b7$var$legacy;
function $e1c978209356d5b7$var$legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        $e1c978209356d5b7$require$Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 65536;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) throw TypeError("start must be a Number");
            if (this.end === undefined) this.end = Infinity;
            else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
            if (this.start > this.end) throw new Error("start must be <= end");
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit("error", err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit("open", fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        $e1c978209356d5b7$require$Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) throw TypeError("start must be a Number");
            if (this.start < 0) throw new Error("start must be >= zero");
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}


var $63e4dbb06e7dc61b$exports = {};
"use strict";
$63e4dbb06e7dc61b$exports = $63e4dbb06e7dc61b$var$clone;
var $63e4dbb06e7dc61b$var$getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function $63e4dbb06e7dc61b$var$clone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (obj instanceof Object) var copy = {
        __proto__: $63e4dbb06e7dc61b$var$getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}



/* istanbul ignore next - node 0.x polyfill */ var $09851ef183fe50e4$var$gracefulQueue;
var $09851ef183fe50e4$var$previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    $09851ef183fe50e4$var$gracefulQueue = Symbol.for("graceful-fs.queue");
    // This is used in testing by future versions
    $09851ef183fe50e4$var$previousSymbol = Symbol.for("graceful-fs.previous");
} else {
    $09851ef183fe50e4$var$gracefulQueue = "___graceful-fs.queue";
    $09851ef183fe50e4$var$previousSymbol = "___graceful-fs.previous";
}
function $09851ef183fe50e4$var$noop() {}
function $09851ef183fe50e4$var$publishQueue(context, queue) {
    Object.defineProperty(context, $09851ef183fe50e4$var$gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var $09851ef183fe50e4$var$debug = $09851ef183fe50e4$var$noop;
if ($dAk3n$util.debuglog) $09851ef183fe50e4$var$debug = $dAk3n$util.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) $09851ef183fe50e4$var$debug = function() {
    var m = $dAk3n$util.format.apply($dAk3n$util, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
};

// Once time initialization
if (!$dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var $09851ef183fe50e4$var$queue = $parcel$global[$09851ef183fe50e4$var$gracefulQueue] || [];
    $09851ef183fe50e4$var$publishQueue($dAk3n$fs, $09851ef183fe50e4$var$queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    $dAk3n$fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call($dAk3n$fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) $09851ef183fe50e4$var$resetQueue();
                if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, $09851ef183fe50e4$var$previousSymbol, {
            value: fs$close
        });
        return close;
    }($dAk3n$fs.close);
    $dAk3n$fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply($dAk3n$fs, arguments);
            $09851ef183fe50e4$var$resetQueue();
        }
        Object.defineProperty(closeSync, $09851ef183fe50e4$var$previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }($dAk3n$fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
        $09851ef183fe50e4$var$debug($dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue]);
        $dAk3n$assert.equal($dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue].length, 0);
    });
}
if (!$parcel$global[$09851ef183fe50e4$var$gracefulQueue]) $09851ef183fe50e4$var$publishQueue($parcel$global, $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue]);
$09851ef183fe50e4$exports = $09851ef183fe50e4$var$patch($63e4dbb06e7dc61b$exports($dAk3n$fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !$dAk3n$fs.__patched) {
    $09851ef183fe50e4$exports = $09851ef183fe50e4$var$patch($dAk3n$fs);
    $dAk3n$fs.__patched = true;
}
function $09851ef183fe50e4$var$patch(fs) {
    // Everything that references the open() function needs to be in here
    $062562a8c609a3b7$exports(fs);
    fs.gracefulify = $09851ef183fe50e4$var$patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $09851ef183fe50e4$var$enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $09851ef183fe50e4$var$enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $09851ef183fe50e4$var$enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $09851ef183fe50e4$var$enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $09851ef183fe50e4$var$enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === "function") cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = $e1c978209356d5b7$exports(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, "ReadStream", {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, "WriteStream", {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, "FileReadStream", {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, "FileWriteStream", {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit("error", err);
            } else {
                that.fd = fd;
                that.emit("open", fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit("error", err);
            } else {
                that.fd = fd;
                that.emit("open", fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === "function") cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $09851ef183fe50e4$var$enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
    }
    return fs;
}
function $09851ef183fe50e4$var$enqueue(elem) {
    $09851ef183fe50e4$var$debug("ENQUEUE", elem[0].name, elem[1]);
    $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue].push(elem);
    $09851ef183fe50e4$var$retry();
}
// keep track of the timeout between retry() calls
var $09851ef183fe50e4$var$retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function $09851ef183fe50e4$var$resetQueue() {
    var now = Date.now();
    for(var i = 0; i < $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue].length; ++i)// entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if ($dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue][i].length > 2) {
        $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue][i][3] = now // startTime
        ;
        $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue][i][4] = now // lastTime
        ;
    }
    // call retry to make sure we're actively processing the queue
    $09851ef183fe50e4$var$retry();
}
function $09851ef183fe50e4$var$retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout($09851ef183fe50e4$var$retryTimer);
    $09851ef183fe50e4$var$retryTimer = undefined;
    if ($dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue].length === 0) return;
    var elem = $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        $09851ef183fe50e4$var$debug("RETRY", fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        $09851ef183fe50e4$var$debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function") cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            $09851ef183fe50e4$var$debug("RETRY", fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else // if we can't do this job yet, push it to the end of the queue
        // and let the next iteration check again
        $dAk3n$fs[$09851ef183fe50e4$var$gracefulQueue].push(elem);
    }
    // schedule our next run if one isn't already scheduled
    if ($09851ef183fe50e4$var$retryTimer === undefined) $09851ef183fe50e4$var$retryTimer = setTimeout($09851ef183fe50e4$var$retry, 0);
}


var $9d614d74911e0026$exports = {};
"use strict";
var $47ca99bd2820c44b$exports = {};
"use strict";
$47ca99bd2820c44b$exports = (input)=>{
    const buf = new Uint8Array(input);
    if (!(buf && buf.length > 1)) return null;
    const check = (header, opts)=>{
        opts = Object.assign({
            offset: 0
        }, opts);
        for(let i = 0; i < header.length; i++){
            if (header[i] !== buf[i + opts.offset]) return false;
        }
        return true;
    };
    if (check([
        0xFF,
        0xD8,
        0xFF
    ])) return {
        ext: "jpg",
        mime: "image/jpeg"
    };
    if (check([
        0x89,
        0x50,
        0x4E,
        0x47,
        0x0D,
        0x0A,
        0x1A,
        0x0A
    ])) return {
        ext: "png",
        mime: "image/png"
    };
    if (check([
        0x47,
        0x49,
        0x46
    ])) return {
        ext: "gif",
        mime: "image/gif"
    };
    if (check([
        0x57,
        0x45,
        0x42,
        0x50
    ], {
        offset: 8
    })) return {
        ext: "webp",
        mime: "image/webp"
    };
    if (check([
        0x46,
        0x4C,
        0x49,
        0x46
    ])) return {
        ext: "flif",
        mime: "image/flif"
    };
    // Needs to be before `tif` check
    if ((check([
        0x49,
        0x49,
        0x2A,
        0x0
    ]) || check([
        0x4D,
        0x4D,
        0x0,
        0x2A
    ])) && check([
        0x43,
        0x52
    ], {
        offset: 8
    })) return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
    };
    if (check([
        0x49,
        0x49,
        0x2A,
        0x0
    ]) || check([
        0x4D,
        0x4D,
        0x0,
        0x2A
    ])) return {
        ext: "tif",
        mime: "image/tiff"
    };
    if (check([
        0x42,
        0x4D
    ])) return {
        ext: "bmp",
        mime: "image/bmp"
    };
    if (check([
        0x49,
        0x49,
        0xBC
    ])) return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
    };
    if (check([
        0x38,
        0x42,
        0x50,
        0x53
    ])) return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
    };
    // Needs to be before the `zip` check
    if (check([
        0x50,
        0x4B,
        0x3,
        0x4
    ]) && check([
        0x6D,
        0x69,
        0x6D,
        0x65,
        0x74,
        0x79,
        0x70,
        0x65,
        0x61,
        0x70,
        0x70,
        0x6C,
        0x69,
        0x63,
        0x61,
        0x74,
        0x69,
        0x6F,
        0x6E,
        0x2F,
        0x65,
        0x70,
        0x75,
        0x62,
        0x2B,
        0x7A,
        0x69,
        0x70
    ], {
        offset: 30
    })) return {
        ext: "epub",
        mime: "application/epub+zip"
    };
    // Needs to be before `zip` check
    // Assumes signed `.xpi` from addons.mozilla.org
    if (check([
        0x50,
        0x4B,
        0x3,
        0x4
    ]) && check([
        0x4D,
        0x45,
        0x54,
        0x41,
        0x2D,
        0x49,
        0x4E,
        0x46,
        0x2F,
        0x6D,
        0x6F,
        0x7A,
        0x69,
        0x6C,
        0x6C,
        0x61,
        0x2E,
        0x72,
        0x73,
        0x61
    ], {
        offset: 30
    })) return {
        ext: "xpi",
        mime: "application/x-xpinstall"
    };
    if (check([
        0x50,
        0x4B
    ]) && (buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) && (buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)) return {
        ext: "zip",
        mime: "application/zip"
    };
    if (check([
        0x75,
        0x73,
        0x74,
        0x61,
        0x72
    ], {
        offset: 257
    })) return {
        ext: "tar",
        mime: "application/x-tar"
    };
    if (check([
        0x52,
        0x61,
        0x72,
        0x21,
        0x1A,
        0x7
    ]) && (buf[6] === 0x0 || buf[6] === 0x1)) return {
        ext: "rar",
        mime: "application/x-rar-compressed"
    };
    if (check([
        0x1F,
        0x8B,
        0x8
    ])) return {
        ext: "gz",
        mime: "application/gzip"
    };
    if (check([
        0x42,
        0x5A,
        0x68
    ])) return {
        ext: "bz2",
        mime: "application/x-bzip2"
    };
    if (check([
        0x37,
        0x7A,
        0xBC,
        0xAF,
        0x27,
        0x1C
    ])) return {
        ext: "7z",
        mime: "application/x-7z-compressed"
    };
    if (check([
        0x78,
        0x01
    ])) return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
    };
    if (check([
        0x0,
        0x0,
        0x0
    ]) && (buf[3] === 0x18 || buf[3] === 0x20) && check([
        0x66,
        0x74,
        0x79,
        0x70
    ], {
        offset: 4
    }) || check([
        0x33,
        0x67,
        0x70,
        0x35
    ]) || check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x6D,
        0x70,
        0x34,
        0x32
    ]) && check([
        0x6D,
        0x70,
        0x34,
        0x31,
        0x6D,
        0x70,
        0x34,
        0x32,
        0x69,
        0x73,
        0x6F,
        0x6D
    ], {
        offset: 16
    }) || check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x69,
        0x73,
        0x6F,
        0x6D
    ]) || check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x6D,
        0x70,
        0x34,
        0x32,
        0x0,
        0x0,
        0x0,
        0x0
    ])) return {
        ext: "mp4",
        mime: "video/mp4"
    };
    if (check([
        0x0,
        0x0,
        0x0,
        0x1C,
        0x66,
        0x74,
        0x79,
        0x70,
        0x4D,
        0x34,
        0x56
    ])) return {
        ext: "m4v",
        mime: "video/x-m4v"
    };
    if (check([
        0x4D,
        0x54,
        0x68,
        0x64
    ])) return {
        ext: "mid",
        mime: "audio/midi"
    };
    // https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
    if (check([
        0x1A,
        0x45,
        0xDF,
        0xA3
    ])) {
        const sliced = buf.subarray(4, 4100);
        const idPos = sliced.findIndex((el, i, arr)=>arr[i] === 0x42 && arr[i + 1] === 0x82);
        if (idPos >= 0) {
            const docTypePos = idPos + 3;
            const findDocType = (type)=>Array.from(type).every((c, i)=>sliced[docTypePos + i] === c.charCodeAt(0));
            if (findDocType("matroska")) return {
                ext: "mkv",
                mime: "video/x-matroska"
            };
            if (findDocType("webm")) return {
                ext: "webm",
                mime: "video/webm"
            };
        }
    }
    if (check([
        0x0,
        0x0,
        0x0,
        0x14,
        0x66,
        0x74,
        0x79,
        0x70,
        0x71,
        0x74,
        0x20,
        0x20
    ]) || check([
        0x66,
        0x72,
        0x65,
        0x65
    ], {
        offset: 4
    }) || check([
        0x66,
        0x74,
        0x79,
        0x70,
        0x71,
        0x74,
        0x20,
        0x20
    ], {
        offset: 4
    }) || check([
        0x6D,
        0x64,
        0x61,
        0x74
    ], {
        offset: 4
    }) || // MJPEG
    check([
        0x77,
        0x69,
        0x64,
        0x65
    ], {
        offset: 4
    })) return {
        ext: "mov",
        mime: "video/quicktime"
    };
    if (check([
        0x52,
        0x49,
        0x46,
        0x46
    ]) && check([
        0x41,
        0x56,
        0x49
    ], {
        offset: 8
    })) return {
        ext: "avi",
        mime: "video/x-msvideo"
    };
    if (check([
        0x30,
        0x26,
        0xB2,
        0x75,
        0x8E,
        0x66,
        0xCF,
        0x11,
        0xA6,
        0xD9
    ])) return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
    };
    if (check([
        0x0,
        0x0,
        0x1,
        0xBA
    ])) return {
        ext: "mpg",
        mime: "video/mpeg"
    };
    if (check([
        0x49,
        0x44,
        0x33
    ]) || check([
        0xFF,
        0xFB
    ])) return {
        ext: "mp3",
        mime: "audio/mpeg"
    };
    if (check([
        0x66,
        0x74,
        0x79,
        0x70,
        0x4D,
        0x34,
        0x41
    ], {
        offset: 4
    }) || check([
        0x4D,
        0x34,
        0x41,
        0x20
    ])) return {
        ext: "m4a",
        mime: "audio/m4a"
    };
    // Needs to be before `ogg` check
    if (check([
        0x4F,
        0x70,
        0x75,
        0x73,
        0x48,
        0x65,
        0x61,
        0x64
    ], {
        offset: 28
    })) return {
        ext: "opus",
        mime: "audio/opus"
    };
    if (check([
        0x4F,
        0x67,
        0x67,
        0x53
    ])) return {
        ext: "ogg",
        mime: "audio/ogg"
    };
    if (check([
        0x66,
        0x4C,
        0x61,
        0x43
    ])) return {
        ext: "flac",
        mime: "audio/x-flac"
    };
    if (check([
        0x52,
        0x49,
        0x46,
        0x46
    ]) && check([
        0x57,
        0x41,
        0x56,
        0x45
    ], {
        offset: 8
    })) return {
        ext: "wav",
        mime: "audio/x-wav"
    };
    if (check([
        0x23,
        0x21,
        0x41,
        0x4D,
        0x52,
        0x0A
    ])) return {
        ext: "amr",
        mime: "audio/amr"
    };
    if (check([
        0x25,
        0x50,
        0x44,
        0x46
    ])) return {
        ext: "pdf",
        mime: "application/pdf"
    };
    if (check([
        0x4D,
        0x5A
    ])) return {
        ext: "exe",
        mime: "application/x-msdownload"
    };
    if ((buf[0] === 0x43 || buf[0] === 0x46) && check([
        0x57,
        0x53
    ], {
        offset: 1
    })) return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
    };
    if (check([
        0x7B,
        0x5C,
        0x72,
        0x74,
        0x66
    ])) return {
        ext: "rtf",
        mime: "application/rtf"
    };
    if (check([
        0x00,
        0x61,
        0x73,
        0x6D
    ])) return {
        ext: "wasm",
        mime: "application/wasm"
    };
    if (check([
        0x77,
        0x4F,
        0x46,
        0x46
    ]) && (check([
        0x00,
        0x01,
        0x00,
        0x00
    ], {
        offset: 4
    }) || check([
        0x4F,
        0x54,
        0x54,
        0x4F
    ], {
        offset: 4
    }))) return {
        ext: "woff",
        mime: "font/woff"
    };
    if (check([
        0x77,
        0x4F,
        0x46,
        0x32
    ]) && (check([
        0x00,
        0x01,
        0x00,
        0x00
    ], {
        offset: 4
    }) || check([
        0x4F,
        0x54,
        0x54,
        0x4F
    ], {
        offset: 4
    }))) return {
        ext: "woff2",
        mime: "font/woff2"
    };
    if (check([
        0x4C,
        0x50
    ], {
        offset: 34
    }) && (check([
        0x00,
        0x00,
        0x01
    ], {
        offset: 8
    }) || check([
        0x01,
        0x00,
        0x02
    ], {
        offset: 8
    }) || check([
        0x02,
        0x00,
        0x02
    ], {
        offset: 8
    }))) return {
        ext: "eot",
        mime: "application/octet-stream"
    };
    if (check([
        0x00,
        0x01,
        0x00,
        0x00,
        0x00
    ])) return {
        ext: "ttf",
        mime: "font/ttf"
    };
    if (check([
        0x4F,
        0x54,
        0x54,
        0x4F,
        0x00
    ])) return {
        ext: "otf",
        mime: "font/otf"
    };
    if (check([
        0x00,
        0x00,
        0x01,
        0x00
    ])) return {
        ext: "ico",
        mime: "image/x-icon"
    };
    if (check([
        0x46,
        0x4C,
        0x56,
        0x01
    ])) return {
        ext: "flv",
        mime: "video/x-flv"
    };
    if (check([
        0x25,
        0x21
    ])) return {
        ext: "ps",
        mime: "application/postscript"
    };
    if (check([
        0xFD,
        0x37,
        0x7A,
        0x58,
        0x5A,
        0x00
    ])) return {
        ext: "xz",
        mime: "application/x-xz"
    };
    if (check([
        0x53,
        0x51,
        0x4C,
        0x69
    ])) return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
    };
    if (check([
        0x4E,
        0x45,
        0x53,
        0x1A
    ])) return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
    };
    if (check([
        0x43,
        0x72,
        0x32,
        0x34
    ])) return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
    };
    if (check([
        0x4D,
        0x53,
        0x43,
        0x46
    ]) || check([
        0x49,
        0x53,
        0x63,
        0x28
    ])) return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
    };
    // Needs to be before `ar` check
    if (check([
        0x21,
        0x3C,
        0x61,
        0x72,
        0x63,
        0x68,
        0x3E,
        0x0A,
        0x64,
        0x65,
        0x62,
        0x69,
        0x61,
        0x6E,
        0x2D,
        0x62,
        0x69,
        0x6E,
        0x61,
        0x72,
        0x79
    ])) return {
        ext: "deb",
        mime: "application/x-deb"
    };
    if (check([
        0x21,
        0x3C,
        0x61,
        0x72,
        0x63,
        0x68,
        0x3E
    ])) return {
        ext: "ar",
        mime: "application/x-unix-archive"
    };
    if (check([
        0xED,
        0xAB,
        0xEE,
        0xDB
    ])) return {
        ext: "rpm",
        mime: "application/x-rpm"
    };
    if (check([
        0x1F,
        0xA0
    ]) || check([
        0x1F,
        0x9D
    ])) return {
        ext: "Z",
        mime: "application/x-compress"
    };
    if (check([
        0x4C,
        0x5A,
        0x49,
        0x50
    ])) return {
        ext: "lz",
        mime: "application/x-lzip"
    };
    if (check([
        0xD0,
        0xCF,
        0x11,
        0xE0,
        0xA1,
        0xB1,
        0x1A,
        0xE1
    ])) return {
        ext: "msi",
        mime: "application/x-msi"
    };
    if (check([
        0x06,
        0x0E,
        0x2B,
        0x34,
        0x02,
        0x05,
        0x01,
        0x01,
        0x0D,
        0x01,
        0x02,
        0x01,
        0x01,
        0x02
    ])) return {
        ext: "mxf",
        mime: "application/mxf"
    };
    if (check([
        0x47
    ], {
        offset: 4
    }) && (check([
        0x47
    ], {
        offset: 192
    }) || check([
        0x47
    ], {
        offset: 196
    }))) return {
        ext: "mts",
        mime: "video/mp2t"
    };
    if (check([
        0x42,
        0x4C,
        0x45,
        0x4E,
        0x44,
        0x45,
        0x52
    ])) return {
        ext: "blend",
        mime: "application/x-blender"
    };
    if (check([
        0x42,
        0x50,
        0x47,
        0xFB
    ])) return {
        ext: "bpg",
        mime: "image/bpg"
    };
    return null;
};


var $7e24865fa78e5f40$exports = {};
"use strict";
var $7e24865fa78e5f40$var$isStream = $7e24865fa78e5f40$exports = function(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
};
$7e24865fa78e5f40$var$isStream.writable = function(stream) {
    return $7e24865fa78e5f40$var$isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
};
$7e24865fa78e5f40$var$isStream.readable = function(stream) {
    return $7e24865fa78e5f40$var$isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
};
$7e24865fa78e5f40$var$isStream.duplex = function(stream) {
    return $7e24865fa78e5f40$var$isStream.writable(stream) && $7e24865fa78e5f40$var$isStream.readable(stream);
};
$7e24865fa78e5f40$var$isStream.transform = function(stream) {
    return $7e24865fa78e5f40$var$isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
};


var $0404c4fd5eee67f3$export$f9380c9a627682d3;
var $0404c4fd5eee67f3$export$2a703dbb0cb35339;

$0404c4fd5eee67f3$export$f9380c9a627682d3 = (parcelRequire("39RQR"));

$0404c4fd5eee67f3$export$2a703dbb0cb35339 = (parcelRequire("9mXEg"));


$9d614d74911e0026$exports = ()=>(input)=>{
        if (!Buffer.isBuffer(input) && !$7e24865fa78e5f40$exports(input)) return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
        if (Buffer.isBuffer(input) && (!$47ca99bd2820c44b$exports(input) || $47ca99bd2820c44b$exports(input).ext !== "tar")) return Promise.resolve([]);
        const extract = $0404c4fd5eee67f3$export$f9380c9a627682d3();
        const files = [];
        extract.on("entry", (header, stream, cb)=>{
            const chunk = [];
            stream.on("data", (data)=>chunk.push(data));
            stream.on("end", ()=>{
                const file = {
                    data: Buffer.concat(chunk),
                    mode: header.mode,
                    mtime: header.mtime,
                    path: header.name,
                    type: header.type
                };
                if (header.type === "symlink" || header.type === "link") file.linkname = header.linkname;
                files.push(file);
                cb();
            });
        });
        const promise = new Promise((resolve, reject)=>{
            if (!Buffer.isBuffer(input)) input.on("error", reject);
            extract.on("finish", ()=>resolve(files));
            extract.on("error", reject);
        });
        extract.then = promise.then.bind(promise);
        extract.catch = promise.catch.bind(promise);
        if (Buffer.isBuffer(input)) extract.end(input);
        else input.pipe(extract);
        return extract;
    };


var $b05f17374a7517a3$exports = {};
"use strict";

var $3584865a960a1dc0$exports = {};
"use strict";
const $3584865a960a1dc0$var$toBytes = (s)=>Array.from(s).map((c)=>c.charCodeAt(0));
const $3584865a960a1dc0$var$xpiZipFilename = $3584865a960a1dc0$var$toBytes("META-INF/mozilla.rsa");
const $3584865a960a1dc0$var$oxmlContentTypes = $3584865a960a1dc0$var$toBytes("[Content_Types].xml");
const $3584865a960a1dc0$var$oxmlRels = $3584865a960a1dc0$var$toBytes("_rels/.rels");
$3584865a960a1dc0$exports = (input)=>{
    const buf = new Uint8Array(input);
    if (!(buf && buf.length > 1)) return null;
    const check = (header, opts)=>{
        opts = Object.assign({
            offset: 0
        }, opts);
        for(let i = 0; i < header.length; i++){
            // If a bitmask is set
            if (opts.mask) {
                // If header doesn't equal `buf` with bits masked off
                if (header[i] !== (opts.mask[i] & buf[i + opts.offset])) return false;
            } else if (header[i] !== buf[i + opts.offset]) return false;
        }
        return true;
    };
    if (check([
        0xFF,
        0xD8,
        0xFF
    ])) return {
        ext: "jpg",
        mime: "image/jpeg"
    };
    if (check([
        0x89,
        0x50,
        0x4E,
        0x47,
        0x0D,
        0x0A,
        0x1A,
        0x0A
    ])) return {
        ext: "png",
        mime: "image/png"
    };
    if (check([
        0x47,
        0x49,
        0x46
    ])) return {
        ext: "gif",
        mime: "image/gif"
    };
    if (check([
        0x57,
        0x45,
        0x42,
        0x50
    ], {
        offset: 8
    })) return {
        ext: "webp",
        mime: "image/webp"
    };
    if (check([
        0x46,
        0x4C,
        0x49,
        0x46
    ])) return {
        ext: "flif",
        mime: "image/flif"
    };
    // Needs to be before `tif` check
    if ((check([
        0x49,
        0x49,
        0x2A,
        0x0
    ]) || check([
        0x4D,
        0x4D,
        0x0,
        0x2A
    ])) && check([
        0x43,
        0x52
    ], {
        offset: 8
    })) return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
    };
    if (check([
        0x49,
        0x49,
        0x2A,
        0x0
    ]) || check([
        0x4D,
        0x4D,
        0x0,
        0x2A
    ])) return {
        ext: "tif",
        mime: "image/tiff"
    };
    if (check([
        0x42,
        0x4D
    ])) return {
        ext: "bmp",
        mime: "image/bmp"
    };
    if (check([
        0x49,
        0x49,
        0xBC
    ])) return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
    };
    if (check([
        0x38,
        0x42,
        0x50,
        0x53
    ])) return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
    };
    // Zip-based file formats
    // Need to be before the `zip` check
    if (check([
        0x50,
        0x4B,
        0x3,
        0x4
    ])) {
        if (check([
            0x6D,
            0x69,
            0x6D,
            0x65,
            0x74,
            0x79,
            0x70,
            0x65,
            0x61,
            0x70,
            0x70,
            0x6C,
            0x69,
            0x63,
            0x61,
            0x74,
            0x69,
            0x6F,
            0x6E,
            0x2F,
            0x65,
            0x70,
            0x75,
            0x62,
            0x2B,
            0x7A,
            0x69,
            0x70
        ], {
            offset: 30
        })) return {
            ext: "epub",
            mime: "application/epub+zip"
        };
        // Assumes signed `.xpi` from addons.mozilla.org
        if (check($3584865a960a1dc0$var$xpiZipFilename, {
            offset: 30
        })) return {
            ext: "xpi",
            mime: "application/x-xpinstall"
        };
        // https://github.com/file/file/blob/master/magic/Magdir/msooxml
        if (check($3584865a960a1dc0$var$oxmlContentTypes, {
            offset: 30
        }) || check($3584865a960a1dc0$var$oxmlRels, {
            offset: 30
        })) {
            const sliced = buf.subarray(4, 2004);
            const nextZipHeaderIndex = (arr)=>arr.findIndex((el, i, arr)=>arr[i] === 0x50 && arr[i + 1] === 0x4B && arr[i + 2] === 0x3 && arr[i + 3] === 0x4);
            const header2Pos = nextZipHeaderIndex(sliced);
            if (header2Pos !== -1) {
                const slicedAgain = buf.subarray(header2Pos + 8, header2Pos + 8 + 1000);
                const header3Pos = nextZipHeaderIndex(slicedAgain);
                if (header3Pos !== -1) {
                    const offset = 8 + header2Pos + header3Pos + 30;
                    if (check($3584865a960a1dc0$var$toBytes("word/"), {
                        offset: offset
                    })) return {
                        ext: "docx",
                        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                    };
                    if (check($3584865a960a1dc0$var$toBytes("ppt/"), {
                        offset: offset
                    })) return {
                        ext: "pptx",
                        mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                    };
                    if (check($3584865a960a1dc0$var$toBytes("xl/"), {
                        offset: offset
                    })) return {
                        ext: "xlsx",
                        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    };
                }
            }
        }
    }
    if (check([
        0x50,
        0x4B
    ]) && (buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) && (buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)) return {
        ext: "zip",
        mime: "application/zip"
    };
    if (check([
        0x75,
        0x73,
        0x74,
        0x61,
        0x72
    ], {
        offset: 257
    })) return {
        ext: "tar",
        mime: "application/x-tar"
    };
    if (check([
        0x52,
        0x61,
        0x72,
        0x21,
        0x1A,
        0x7
    ]) && (buf[6] === 0x0 || buf[6] === 0x1)) return {
        ext: "rar",
        mime: "application/x-rar-compressed"
    };
    if (check([
        0x1F,
        0x8B,
        0x8
    ])) return {
        ext: "gz",
        mime: "application/gzip"
    };
    if (check([
        0x42,
        0x5A,
        0x68
    ])) return {
        ext: "bz2",
        mime: "application/x-bzip2"
    };
    if (check([
        0x37,
        0x7A,
        0xBC,
        0xAF,
        0x27,
        0x1C
    ])) return {
        ext: "7z",
        mime: "application/x-7z-compressed"
    };
    if (check([
        0x78,
        0x01
    ])) return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
    };
    if (check([
        0x33,
        0x67,
        0x70,
        0x35
    ]) || // 3gp5
    check([
        0x0,
        0x0,
        0x0
    ]) && check([
        0x66,
        0x74,
        0x79,
        0x70
    ], {
        offset: 4
    }) && (check([
        0x6D,
        0x70,
        0x34,
        0x31
    ], {
        offset: 8
    }) || // MP41
    check([
        0x6D,
        0x70,
        0x34,
        0x32
    ], {
        offset: 8
    }) || // MP42
    check([
        0x69,
        0x73,
        0x6F,
        0x6D
    ], {
        offset: 8
    }) || // ISOM
    check([
        0x69,
        0x73,
        0x6F,
        0x32
    ], {
        offset: 8
    }) || // ISO2
    check([
        0x6D,
        0x6D,
        0x70,
        0x34
    ], {
        offset: 8
    }) || // MMP4
    check([
        0x4D,
        0x34,
        0x56
    ], {
        offset: 8
    }) || // M4V
    check([
        0x64,
        0x61,
        0x73,
        0x68
    ], {
        offset: 8
    }) // DASH
    )) return {
        ext: "mp4",
        mime: "video/mp4"
    };
    if (check([
        0x4D,
        0x54,
        0x68,
        0x64
    ])) return {
        ext: "mid",
        mime: "audio/midi"
    };
    // https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
    if (check([
        0x1A,
        0x45,
        0xDF,
        0xA3
    ])) {
        const sliced = buf.subarray(4, 4100);
        const idPos = sliced.findIndex((el, i, arr)=>arr[i] === 0x42 && arr[i + 1] === 0x82);
        if (idPos !== -1) {
            const docTypePos = idPos + 3;
            const findDocType = (type)=>Array.from(type).every((c, i)=>sliced[docTypePos + i] === c.charCodeAt(0));
            if (findDocType("matroska")) return {
                ext: "mkv",
                mime: "video/x-matroska"
            };
            if (findDocType("webm")) return {
                ext: "webm",
                mime: "video/webm"
            };
        }
    }
    if (check([
        0x0,
        0x0,
        0x0,
        0x14,
        0x66,
        0x74,
        0x79,
        0x70,
        0x71,
        0x74,
        0x20,
        0x20
    ]) || check([
        0x66,
        0x72,
        0x65,
        0x65
    ], {
        offset: 4
    }) || check([
        0x66,
        0x74,
        0x79,
        0x70,
        0x71,
        0x74,
        0x20,
        0x20
    ], {
        offset: 4
    }) || check([
        0x6D,
        0x64,
        0x61,
        0x74
    ], {
        offset: 4
    }) || // MJPEG
    check([
        0x77,
        0x69,
        0x64,
        0x65
    ], {
        offset: 4
    })) return {
        ext: "mov",
        mime: "video/quicktime"
    };
    if (check([
        0x52,
        0x49,
        0x46,
        0x46
    ]) && check([
        0x41,
        0x56,
        0x49
    ], {
        offset: 8
    })) return {
        ext: "avi",
        mime: "video/x-msvideo"
    };
    if (check([
        0x30,
        0x26,
        0xB2,
        0x75,
        0x8E,
        0x66,
        0xCF,
        0x11,
        0xA6,
        0xD9
    ])) return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
    };
    if (check([
        0x0,
        0x0,
        0x1,
        0xBA
    ])) return {
        ext: "mpg",
        mime: "video/mpeg"
    };
    // Check for MP3 header at different starting offsets
    for(let start = 0; start < 2 && start < buf.length - 16; start++){
        if (check([
            0x49,
            0x44,
            0x33
        ], {
            offset: start
        }) || // ID3 header
        check([
            0xFF,
            0xE2
        ], {
            offset: start,
            mask: [
                0xFF,
                0xE2
            ]
        }) // MPEG 1 or 2 Layer 3 header
        ) return {
            ext: "mp3",
            mime: "audio/mpeg"
        };
    }
    if (check([
        0x66,
        0x74,
        0x79,
        0x70,
        0x4D,
        0x34,
        0x41
    ], {
        offset: 4
    }) || check([
        0x4D,
        0x34,
        0x41,
        0x20
    ])) return {
        ext: "m4a",
        mime: "audio/m4a"
    };
    // Needs to be before `ogg` check
    if (check([
        0x4F,
        0x70,
        0x75,
        0x73,
        0x48,
        0x65,
        0x61,
        0x64
    ], {
        offset: 28
    })) return {
        ext: "opus",
        mime: "audio/opus"
    };
    if (check([
        0x4F,
        0x67,
        0x67,
        0x53
    ])) return {
        ext: "ogg",
        mime: "audio/ogg"
    };
    if (check([
        0x66,
        0x4C,
        0x61,
        0x43
    ])) return {
        ext: "flac",
        mime: "audio/x-flac"
    };
    if (check([
        0x52,
        0x49,
        0x46,
        0x46
    ]) && check([
        0x57,
        0x41,
        0x56,
        0x45
    ], {
        offset: 8
    })) return {
        ext: "wav",
        mime: "audio/x-wav"
    };
    if (check([
        0x23,
        0x21,
        0x41,
        0x4D,
        0x52,
        0x0A
    ])) return {
        ext: "amr",
        mime: "audio/amr"
    };
    if (check([
        0x25,
        0x50,
        0x44,
        0x46
    ])) return {
        ext: "pdf",
        mime: "application/pdf"
    };
    if (check([
        0x4D,
        0x5A
    ])) return {
        ext: "exe",
        mime: "application/x-msdownload"
    };
    if ((buf[0] === 0x43 || buf[0] === 0x46) && check([
        0x57,
        0x53
    ], {
        offset: 1
    })) return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
    };
    if (check([
        0x7B,
        0x5C,
        0x72,
        0x74,
        0x66
    ])) return {
        ext: "rtf",
        mime: "application/rtf"
    };
    if (check([
        0x00,
        0x61,
        0x73,
        0x6D
    ])) return {
        ext: "wasm",
        mime: "application/wasm"
    };
    if (check([
        0x77,
        0x4F,
        0x46,
        0x46
    ]) && (check([
        0x00,
        0x01,
        0x00,
        0x00
    ], {
        offset: 4
    }) || check([
        0x4F,
        0x54,
        0x54,
        0x4F
    ], {
        offset: 4
    }))) return {
        ext: "woff",
        mime: "font/woff"
    };
    if (check([
        0x77,
        0x4F,
        0x46,
        0x32
    ]) && (check([
        0x00,
        0x01,
        0x00,
        0x00
    ], {
        offset: 4
    }) || check([
        0x4F,
        0x54,
        0x54,
        0x4F
    ], {
        offset: 4
    }))) return {
        ext: "woff2",
        mime: "font/woff2"
    };
    if (check([
        0x4C,
        0x50
    ], {
        offset: 34
    }) && (check([
        0x00,
        0x00,
        0x01
    ], {
        offset: 8
    }) || check([
        0x01,
        0x00,
        0x02
    ], {
        offset: 8
    }) || check([
        0x02,
        0x00,
        0x02
    ], {
        offset: 8
    }))) return {
        ext: "eot",
        mime: "application/octet-stream"
    };
    if (check([
        0x00,
        0x01,
        0x00,
        0x00,
        0x00
    ])) return {
        ext: "ttf",
        mime: "font/ttf"
    };
    if (check([
        0x4F,
        0x54,
        0x54,
        0x4F,
        0x00
    ])) return {
        ext: "otf",
        mime: "font/otf"
    };
    if (check([
        0x00,
        0x00,
        0x01,
        0x00
    ])) return {
        ext: "ico",
        mime: "image/x-icon"
    };
    if (check([
        0x46,
        0x4C,
        0x56,
        0x01
    ])) return {
        ext: "flv",
        mime: "video/x-flv"
    };
    if (check([
        0x25,
        0x21
    ])) return {
        ext: "ps",
        mime: "application/postscript"
    };
    if (check([
        0xFD,
        0x37,
        0x7A,
        0x58,
        0x5A,
        0x00
    ])) return {
        ext: "xz",
        mime: "application/x-xz"
    };
    if (check([
        0x53,
        0x51,
        0x4C,
        0x69
    ])) return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
    };
    if (check([
        0x4E,
        0x45,
        0x53,
        0x1A
    ])) return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
    };
    if (check([
        0x43,
        0x72,
        0x32,
        0x34
    ])) return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
    };
    if (check([
        0x4D,
        0x53,
        0x43,
        0x46
    ]) || check([
        0x49,
        0x53,
        0x63,
        0x28
    ])) return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
    };
    // Needs to be before `ar` check
    if (check([
        0x21,
        0x3C,
        0x61,
        0x72,
        0x63,
        0x68,
        0x3E,
        0x0A,
        0x64,
        0x65,
        0x62,
        0x69,
        0x61,
        0x6E,
        0x2D,
        0x62,
        0x69,
        0x6E,
        0x61,
        0x72,
        0x79
    ])) return {
        ext: "deb",
        mime: "application/x-deb"
    };
    if (check([
        0x21,
        0x3C,
        0x61,
        0x72,
        0x63,
        0x68,
        0x3E
    ])) return {
        ext: "ar",
        mime: "application/x-unix-archive"
    };
    if (check([
        0xED,
        0xAB,
        0xEE,
        0xDB
    ])) return {
        ext: "rpm",
        mime: "application/x-rpm"
    };
    if (check([
        0x1F,
        0xA0
    ]) || check([
        0x1F,
        0x9D
    ])) return {
        ext: "Z",
        mime: "application/x-compress"
    };
    if (check([
        0x4C,
        0x5A,
        0x49,
        0x50
    ])) return {
        ext: "lz",
        mime: "application/x-lzip"
    };
    if (check([
        0xD0,
        0xCF,
        0x11,
        0xE0,
        0xA1,
        0xB1,
        0x1A,
        0xE1
    ])) return {
        ext: "msi",
        mime: "application/x-msi"
    };
    if (check([
        0x06,
        0x0E,
        0x2B,
        0x34,
        0x02,
        0x05,
        0x01,
        0x01,
        0x0D,
        0x01,
        0x02,
        0x01,
        0x01,
        0x02
    ])) return {
        ext: "mxf",
        mime: "application/mxf"
    };
    if (check([
        0x47
    ], {
        offset: 4
    }) && (check([
        0x47
    ], {
        offset: 192
    }) || check([
        0x47
    ], {
        offset: 196
    }))) return {
        ext: "mts",
        mime: "video/mp2t"
    };
    if (check([
        0x42,
        0x4C,
        0x45,
        0x4E,
        0x44,
        0x45,
        0x52
    ])) return {
        ext: "blend",
        mime: "application/x-blender"
    };
    if (check([
        0x42,
        0x50,
        0x47,
        0xFB
    ])) return {
        ext: "bpg",
        mime: "image/bpg"
    };
    return null;
};



var $ae4ce0e9653306c7$exports = {};
/*
seek-bzip - a pure-javascript module for seeking within bzip2 data

Copyright (C) 2013 C. Scott Ananian
Copyright (C) 2012 Eli Skeggs
Copyright (C) 2011 Kevin Kwok

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Adapted from node-bzip, copyright 2012 Eli Skeggs.
Adapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.
*/ var $5a30eabb7131920e$exports = {};
/*
node-bzip - a pure-javascript Node.JS module for decoding bzip2 data

Copyright (C) 2012 Eli Skeggs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Adapted from bzip2.js, copyright 2011 antimatter15 (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.
*/ var $5a30eabb7131920e$var$BITMASK = [
    0x00,
    0x01,
    0x03,
    0x07,
    0x0F,
    0x1F,
    0x3F,
    0x7F,
    0xFF
];
// offset in bytes
var $5a30eabb7131920e$var$BitReader = function(stream) {
    this.stream = stream;
    this.bitOffset = 0;
    this.curByte = 0;
    this.hasByte = false;
};
$5a30eabb7131920e$var$BitReader.prototype._ensureByte = function() {
    if (!this.hasByte) {
        this.curByte = this.stream.readByte();
        this.hasByte = true;
    }
};
// reads bits from the buffer
$5a30eabb7131920e$var$BitReader.prototype.read = function(bits) {
    var result = 0;
    while(bits > 0){
        this._ensureByte();
        var remaining = 8 - this.bitOffset;
        // if we're in a byte
        if (bits >= remaining) {
            result <<= remaining;
            result |= $5a30eabb7131920e$var$BITMASK[remaining] & this.curByte;
            this.hasByte = false;
            this.bitOffset = 0;
            bits -= remaining;
        } else {
            result <<= bits;
            var shift = remaining - bits;
            result |= (this.curByte & $5a30eabb7131920e$var$BITMASK[bits] << shift) >> shift;
            this.bitOffset += bits;
            bits = 0;
        }
    }
    return result;
};
// seek to an arbitrary point in the buffer (expressed in bits)
$5a30eabb7131920e$var$BitReader.prototype.seek = function(pos) {
    var n_bit = pos % 8;
    var n_byte = (pos - n_bit) / 8;
    this.bitOffset = n_bit;
    this.stream.seek(n_byte);
    this.hasByte = false;
};
// reads 6 bytes worth of data using the read method
$5a30eabb7131920e$var$BitReader.prototype.pi = function() {
    var buf = new Buffer(6), i;
    for(i = 0; i < buf.length; i++)buf[i] = this.read(8);
    return buf.toString("hex");
};
$5a30eabb7131920e$exports = $5a30eabb7131920e$var$BitReader;


var $257839c0bf369abd$exports = {};
/* very simple input/output stream interface */ var $257839c0bf369abd$var$Stream = function() {};
// input streams //////////////
/** Returns the next byte, or -1 for EOF. */ $257839c0bf369abd$var$Stream.prototype.readByte = function() {
    throw new Error("abstract method readByte() not implemented");
};
/** Attempts to fill the buffer; returns number of bytes read, or
 *  -1 for EOF. */ $257839c0bf369abd$var$Stream.prototype.read = function(buffer, bufOffset, length) {
    var bytesRead = 0;
    while(bytesRead < length){
        var c = this.readByte();
        if (c < 0) return bytesRead === 0 ? -1 : bytesRead;
        buffer[bufOffset++] = c;
        bytesRead++;
    }
    return bytesRead;
};
$257839c0bf369abd$var$Stream.prototype.seek = function(new_pos) {
    throw new Error("abstract method seek() not implemented");
};
// output streams ///////////
$257839c0bf369abd$var$Stream.prototype.writeByte = function(_byte) {
    throw new Error("abstract method readByte() not implemented");
};
$257839c0bf369abd$var$Stream.prototype.write = function(buffer, bufOffset, length) {
    var i;
    for(i = 0; i < length; i++)this.writeByte(buffer[bufOffset++]);
    return length;
};
$257839c0bf369abd$var$Stream.prototype.flush = function() {};
$257839c0bf369abd$exports = $257839c0bf369abd$var$Stream;


var $53e901237296740e$exports = {};
/* CRC32, used in Bzip2 implementation.
 * This is a port of CRC32.java from the jbzip2 implementation at
 *   https://code.google.com/p/jbzip2
 * which is:
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */ $53e901237296740e$exports = function() {
    /**
   * A static CRC lookup table
   */ var crc32Lookup = new Uint32Array([
        0x00000000,
        0x04c11db7,
        0x09823b6e,
        0x0d4326d9,
        0x130476dc,
        0x17c56b6b,
        0x1a864db2,
        0x1e475005,
        0x2608edb8,
        0x22c9f00f,
        0x2f8ad6d6,
        0x2b4bcb61,
        0x350c9b64,
        0x31cd86d3,
        0x3c8ea00a,
        0x384fbdbd,
        0x4c11db70,
        0x48d0c6c7,
        0x4593e01e,
        0x4152fda9,
        0x5f15adac,
        0x5bd4b01b,
        0x569796c2,
        0x52568b75,
        0x6a1936c8,
        0x6ed82b7f,
        0x639b0da6,
        0x675a1011,
        0x791d4014,
        0x7ddc5da3,
        0x709f7b7a,
        0x745e66cd,
        0x9823b6e0,
        0x9ce2ab57,
        0x91a18d8e,
        0x95609039,
        0x8b27c03c,
        0x8fe6dd8b,
        0x82a5fb52,
        0x8664e6e5,
        0xbe2b5b58,
        0xbaea46ef,
        0xb7a96036,
        0xb3687d81,
        0xad2f2d84,
        0xa9ee3033,
        0xa4ad16ea,
        0xa06c0b5d,
        0xd4326d90,
        0xd0f37027,
        0xddb056fe,
        0xd9714b49,
        0xc7361b4c,
        0xc3f706fb,
        0xceb42022,
        0xca753d95,
        0xf23a8028,
        0xf6fb9d9f,
        0xfbb8bb46,
        0xff79a6f1,
        0xe13ef6f4,
        0xe5ffeb43,
        0xe8bccd9a,
        0xec7dd02d,
        0x34867077,
        0x30476dc0,
        0x3d044b19,
        0x39c556ae,
        0x278206ab,
        0x23431b1c,
        0x2e003dc5,
        0x2ac12072,
        0x128e9dcf,
        0x164f8078,
        0x1b0ca6a1,
        0x1fcdbb16,
        0x018aeb13,
        0x054bf6a4,
        0x0808d07d,
        0x0cc9cdca,
        0x7897ab07,
        0x7c56b6b0,
        0x71159069,
        0x75d48dde,
        0x6b93dddb,
        0x6f52c06c,
        0x6211e6b5,
        0x66d0fb02,
        0x5e9f46bf,
        0x5a5e5b08,
        0x571d7dd1,
        0x53dc6066,
        0x4d9b3063,
        0x495a2dd4,
        0x44190b0d,
        0x40d816ba,
        0xaca5c697,
        0xa864db20,
        0xa527fdf9,
        0xa1e6e04e,
        0xbfa1b04b,
        0xbb60adfc,
        0xb6238b25,
        0xb2e29692,
        0x8aad2b2f,
        0x8e6c3698,
        0x832f1041,
        0x87ee0df6,
        0x99a95df3,
        0x9d684044,
        0x902b669d,
        0x94ea7b2a,
        0xe0b41de7,
        0xe4750050,
        0xe9362689,
        0xedf73b3e,
        0xf3b06b3b,
        0xf771768c,
        0xfa325055,
        0xfef34de2,
        0xc6bcf05f,
        0xc27dede8,
        0xcf3ecb31,
        0xcbffd686,
        0xd5b88683,
        0xd1799b34,
        0xdc3abded,
        0xd8fba05a,
        0x690ce0ee,
        0x6dcdfd59,
        0x608edb80,
        0x644fc637,
        0x7a089632,
        0x7ec98b85,
        0x738aad5c,
        0x774bb0eb,
        0x4f040d56,
        0x4bc510e1,
        0x46863638,
        0x42472b8f,
        0x5c007b8a,
        0x58c1663d,
        0x558240e4,
        0x51435d53,
        0x251d3b9e,
        0x21dc2629,
        0x2c9f00f0,
        0x285e1d47,
        0x36194d42,
        0x32d850f5,
        0x3f9b762c,
        0x3b5a6b9b,
        0x0315d626,
        0x07d4cb91,
        0x0a97ed48,
        0x0e56f0ff,
        0x1011a0fa,
        0x14d0bd4d,
        0x19939b94,
        0x1d528623,
        0xf12f560e,
        0xf5ee4bb9,
        0xf8ad6d60,
        0xfc6c70d7,
        0xe22b20d2,
        0xe6ea3d65,
        0xeba91bbc,
        0xef68060b,
        0xd727bbb6,
        0xd3e6a601,
        0xdea580d8,
        0xda649d6f,
        0xc423cd6a,
        0xc0e2d0dd,
        0xcda1f604,
        0xc960ebb3,
        0xbd3e8d7e,
        0xb9ff90c9,
        0xb4bcb610,
        0xb07daba7,
        0xae3afba2,
        0xaafbe615,
        0xa7b8c0cc,
        0xa379dd7b,
        0x9b3660c6,
        0x9ff77d71,
        0x92b45ba8,
        0x9675461f,
        0x8832161a,
        0x8cf30bad,
        0x81b02d74,
        0x857130c3,
        0x5d8a9099,
        0x594b8d2e,
        0x5408abf7,
        0x50c9b640,
        0x4e8ee645,
        0x4a4ffbf2,
        0x470cdd2b,
        0x43cdc09c,
        0x7b827d21,
        0x7f436096,
        0x7200464f,
        0x76c15bf8,
        0x68860bfd,
        0x6c47164a,
        0x61043093,
        0x65c52d24,
        0x119b4be9,
        0x155a565e,
        0x18197087,
        0x1cd86d30,
        0x029f3d35,
        0x065e2082,
        0x0b1d065b,
        0x0fdc1bec,
        0x3793a651,
        0x3352bbe6,
        0x3e119d3f,
        0x3ad08088,
        0x2497d08d,
        0x2056cd3a,
        0x2d15ebe3,
        0x29d4f654,
        0xc5a92679,
        0xc1683bce,
        0xcc2b1d17,
        0xc8ea00a0,
        0xd6ad50a5,
        0xd26c4d12,
        0xdf2f6bcb,
        0xdbee767c,
        0xe3a1cbc1,
        0xe760d676,
        0xea23f0af,
        0xeee2ed18,
        0xf0a5bd1d,
        0xf464a0aa,
        0xf9278673,
        0xfde69bc4,
        0x89b8fd09,
        0x8d79e0be,
        0x803ac667,
        0x84fbdbd0,
        0x9abc8bd5,
        0x9e7d9662,
        0x933eb0bb,
        0x97ffad0c,
        0xafb010b1,
        0xab710d06,
        0xa6322bdf,
        0xa2f33668,
        0xbcb4666d,
        0xb8757bda,
        0xb5365d03,
        0xb1f740b4
    ]);
    var CRC32 = function() {
        /**
     * The current CRC
     */ var crc = 0xffffffff;
        /**
     * @return The current CRC
     */ this.getCRC = function() {
            return ~crc >>> 0; // return an unsigned value
        };
        /**
     * Update the CRC with a single byte
     * @param value The value to update the CRC with
     */ this.updateCRC = function(value) {
            crc = crc << 8 ^ crc32Lookup[(crc >>> 24 ^ value) & 0xff];
        };
        /**
     * Update the CRC with a sequence of identical bytes
     * @param value The value to update the CRC with
     * @param count The number of bytes
     */ this.updateCRCRun = function(value, count) {
            while(count-- > 0)crc = crc << 8 ^ crc32Lookup[(crc >>> 24 ^ value) & 0xff];
        };
    };
    return CRC32;
}();


var $884729a90173e364$exports = {};
$884729a90173e364$exports = JSON.parse('{"name":"seek-bzip","version":"1.0.6","contributors":["C. Scott Ananian (http://cscott.net)","Eli Skeggs","Kevin Kwok","Rob Landley (http://landley.net)"],"description":"a pure-JavaScript Node.JS module for random-access decoding bzip2 data","main":"./lib/index.js","repository":{"type":"git","url":"https://github.com/cscott/seek-bzip.git"},"license":"MIT","bin":{"seek-bunzip":"./bin/seek-bunzip","seek-table":"./bin/seek-bzip-table"},"directories":{"test":"test"},"dependencies":{"commander":"^2.8.1"},"devDependencies":{"fibers":"~1.0.6","mocha":"~2.2.5"},"scripts":{"test":"mocha"}}');


var $ae4ce0e9653306c7$var$MAX_HUFCODE_BITS = 20;
var $ae4ce0e9653306c7$var$MAX_SYMBOLS = 258;
var $ae4ce0e9653306c7$var$SYMBOL_RUNA = 0;
var $ae4ce0e9653306c7$var$SYMBOL_RUNB = 1;
var $ae4ce0e9653306c7$var$MIN_GROUPS = 2;
var $ae4ce0e9653306c7$var$MAX_GROUPS = 6;
var $ae4ce0e9653306c7$var$GROUP_SIZE = 50;
var $ae4ce0e9653306c7$var$WHOLEPI = "314159265359";
var $ae4ce0e9653306c7$var$SQRTPI = "177245385090";
var $ae4ce0e9653306c7$var$mtf = function(array, index) {
    var src = array[index], i;
    for(i = index; i > 0; i--)array[i] = array[i - 1];
    array[0] = src;
    return src;
};
var $ae4ce0e9653306c7$var$Err = {
    OK: 0,
    LAST_BLOCK: -1,
    NOT_BZIP_DATA: -2,
    UNEXPECTED_INPUT_EOF: -3,
    UNEXPECTED_OUTPUT_EOF: -4,
    DATA_ERROR: -5,
    OUT_OF_MEMORY: -6,
    OBSOLETE_INPUT: -7,
    END_OF_BLOCK: -8
};
var $ae4ce0e9653306c7$var$ErrorMessages = {};
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.LAST_BLOCK] = "Bad file checksum";
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.NOT_BZIP_DATA] = "Not bzip data";
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.UNEXPECTED_INPUT_EOF] = "Unexpected input EOF";
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.DATA_ERROR] = "Data error";
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.OUT_OF_MEMORY] = "Out of memory";
$ae4ce0e9653306c7$var$ErrorMessages[$ae4ce0e9653306c7$var$Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";
var $ae4ce0e9653306c7$var$_throw = function(status, optDetail) {
    var msg = $ae4ce0e9653306c7$var$ErrorMessages[status] || "unknown error";
    if (optDetail) msg += ": " + optDetail;
    var e = new TypeError(msg);
    e.errorCode = status;
    throw e;
};
var $ae4ce0e9653306c7$var$Bunzip = function(inputStream, outputStream) {
    this.writePos = this.writeCurrent = this.writeCount = 0;
    this._start_bunzip(inputStream, outputStream);
};
$ae4ce0e9653306c7$var$Bunzip.prototype._init_block = function() {
    var moreBlocks = this._get_next_block();
    if (!moreBlocks) {
        this.writeCount = -1;
        return false; /* no more blocks */ 
    }
    this.blockCRC = new $53e901237296740e$exports();
    return true;
};
/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */ $ae4ce0e9653306c7$var$Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
    /* Ensure that file starts with "BZh['1'-'9']." */ var buf = new Buffer(4);
    if (inputStream.read(buf, 0, 4) !== 4 || String.fromCharCode(buf[0], buf[1], buf[2]) !== "BZh") $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.NOT_BZIP_DATA, "bad magic");
    var level = buf[3] - 0x30;
    if (level < 1 || level > 9) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.NOT_BZIP_DATA, "level out of range");
    this.reader = new $5a30eabb7131920e$exports(inputStream);
    /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of
     uncompressed data.  Allocate intermediate buffer for block. */ this.dbufSize = 100000 * level;
    this.nextoutput = 0;
    this.outputStream = outputStream;
    this.streamCRC = 0;
};
$ae4ce0e9653306c7$var$Bunzip.prototype._get_next_block = function() {
    var i, j, k;
    var reader = this.reader;
    // this is get_next_block() function from micro-bunzip:
    /* Read in header signature and CRC, then validate signature.
     (last block signature means CRC is for whole file, return now) */ var h = reader.pi();
    if (h === $ae4ce0e9653306c7$var$SQRTPI) return false; /* no more blocks */ 
    if (h !== $ae4ce0e9653306c7$var$WHOLEPI) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.NOT_BZIP_DATA);
    this.targetBlockCRC = reader.read(32) >>> 0; // (convert to unsigned)
    this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0;
    /* We can add support for blockRandomised if anybody complains.  There was
     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that
     it didn't actually work. */ if (reader.read(1)) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.OBSOLETE_INPUT);
    var origPointer = reader.read(24);
    if (origPointer > this.dbufSize) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR, "initial position out of bounds");
    /* mapping table: if some byte values are never used (encoding things
     like ascii text), the compression code removes the gaps to have fewer
     symbols to deal with, and writes a sparse bitfield indicating which
     values were present.  We make a translation table to convert the symbols
     back to the corresponding bytes. */ var t = reader.read(16);
    var symToByte = new Buffer(256), symTotal = 0;
    for(i = 0; i < 16; i++)if (t & 1 << 0xF - i) {
        var o = i * 16;
        k = reader.read(16);
        for(j = 0; j < 16; j++)if (k & 1 << 0xF - j) symToByte[symTotal++] = o + j;
    }
    /* How many different huffman coding groups does this block use? */ var groupCount = reader.read(3);
    if (groupCount < $ae4ce0e9653306c7$var$MIN_GROUPS || groupCount > $ae4ce0e9653306c7$var$MAX_GROUPS) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
    /* nSelectors: Every GROUP_SIZE many symbols we select a new huffman coding
     group.  Read in the group selector list, which is stored as MTF encoded
     bit runs.  (MTF=Move To Front, as each value is used it's moved to the
     start of the list.) */ var nSelectors = reader.read(15);
    if (nSelectors === 0) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
    var mtfSymbol = new Buffer(256);
    for(i = 0; i < groupCount; i++)mtfSymbol[i] = i;
    var selectors = new Buffer(nSelectors); // was 32768...
    for(i = 0; i < nSelectors; i++){
        /* Get next value */ for(j = 0; reader.read(1); j++)if (j >= groupCount) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
        /* Decode MTF to get the next selector */ selectors[i] = $ae4ce0e9653306c7$var$mtf(mtfSymbol, j);
    }
    /* Read the huffman coding tables for each group, which code for symTotal
     literal symbols, plus two run symbols (RUNA, RUNB) */ var symCount = symTotal + 2;
    var groups = [], hufGroup;
    for(j = 0; j < groupCount; j++){
        var length = new Buffer(symCount), temp = new Uint16Array($ae4ce0e9653306c7$var$MAX_HUFCODE_BITS + 1);
        /* Read huffman code lengths for each symbol.  They're stored in
       a way similar to mtf; record a starting value for the first symbol,
       and an offset from the previous value for everys symbol after that. */ t = reader.read(5); // lengths
        for(i = 0; i < symCount; i++){
            for(;;){
                if (t < 1 || t > $ae4ce0e9653306c7$var$MAX_HUFCODE_BITS) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
                /* If first bit is 0, stop.  Else second bit indicates whether
           to increment or decrement the value. */ if (!reader.read(1)) break;
                if (!reader.read(1)) t++;
                else t--;
            }
            length[i] = t;
        }
        /* Find largest and smallest lengths in this group */ var minLen, maxLen;
        minLen = maxLen = length[0];
        for(i = 1; i < symCount; i++){
            if (length[i] > maxLen) maxLen = length[i];
            else if (length[i] < minLen) minLen = length[i];
        }
        /* Calculate permute[], base[], and limit[] tables from length[].
     *
     * permute[] is the lookup table for converting huffman coded symbols
     * into decoded symbols.  base[] is the amount to subtract from the
     * value of a huffman symbol of a given length when using permute[].
     *
     * limit[] indicates the largest numerical value a symbol with a given
     * number of bits can have.  This is how the huffman codes can vary in
     * length: each code with a value>limit[length] needs another bit.
     */ hufGroup = {};
        groups.push(hufGroup);
        hufGroup.permute = new Uint16Array($ae4ce0e9653306c7$var$MAX_SYMBOLS);
        hufGroup.limit = new Uint32Array($ae4ce0e9653306c7$var$MAX_HUFCODE_BITS + 2);
        hufGroup.base = new Uint32Array($ae4ce0e9653306c7$var$MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        /* Calculate permute[].  Concurently, initialize temp[] and limit[]. */ var pp = 0;
        for(i = minLen; i <= maxLen; i++){
            temp[i] = hufGroup.limit[i] = 0;
            for(t = 0; t < symCount; t++)if (length[t] === i) hufGroup.permute[pp++] = t;
        }
        /* Count symbols coded for at each bit length */ for(i = 0; i < symCount; i++)temp[length[i]]++;
        /* Calculate limit[] (the largest symbol-coding value at each bit
     * length, which is (previous limit<<1)+symbols at this level), and
     * base[] (number of symbols to ignore at each bit length, which is
     * limit minus the cumulative count of symbols coded for already). */ pp = t = 0;
        for(i = minLen; i < maxLen; i++){
            pp += temp[i];
            /* We read the largest possible symbol size and then unget bits
         after determining how many we need, and those extra bits could
         be set to anything.  (They're noise from future symbols.)  At
         each level we're really only interested in the first few bits,
         so here we set all the trailing to-be-ignored bits to 1 so they
         don't affect the value>limit[length] comparison. */ hufGroup.limit[i] = pp - 1;
            pp <<= 1;
            t += temp[i];
            hufGroup.base[i + 1] = pp - t;
        }
        hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinal value for reading next sym. */ 
        hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
        hufGroup.base[minLen] = 0;
    }
    /* We've finished reading and digesting the block header.  Now read this
     block's huffman coded symbols from the file and undo the huffman coding
     and run length encoding, saving the result into dbuf[dbufCount++]=uc */ /* Initialize symbol occurrence counters and symbol Move To Front table */ var byteCount = new Uint32Array(256);
    for(i = 0; i < 256; i++)mtfSymbol[i] = i;
    /* Loop through compressed symbols. */ var runPos = 0, dbufCount = 0, selector = 0, uc;
    var dbuf = this.dbuf = new Uint32Array(this.dbufSize);
    symCount = 0;
    for(;;){
        /* Determine which huffman coding group to use. */ if (!symCount--) {
            symCount = $ae4ce0e9653306c7$var$GROUP_SIZE - 1;
            if (selector >= nSelectors) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
            hufGroup = groups[selectors[selector++]];
        }
        /* Read next huffman-coded symbol. */ i = hufGroup.minLen;
        j = reader.read(i);
        for(;; i++){
            if (i > hufGroup.maxLen) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
            if (j <= hufGroup.limit[i]) break;
            j = j << 1 | reader.read(1);
        }
        /* Huffman decode value to get nextSym (with bounds checking) */ j -= hufGroup.base[i];
        if (j < 0 || j >= $ae4ce0e9653306c7$var$MAX_SYMBOLS) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
        var nextSym = hufGroup.permute[j];
        /* We have now decoded the symbol, which indicates either a new literal
       byte, or a repeated run of the most recent literal byte.  First,
       check if nextSym indicates a repeated run, and if so loop collecting
       how many times to repeat the last literal. */ if (nextSym === $ae4ce0e9653306c7$var$SYMBOL_RUNA || nextSym === $ae4ce0e9653306c7$var$SYMBOL_RUNB) {
            /* If this is the start of a new run, zero out counter */ if (!runPos) {
                runPos = 1;
                t = 0;
            }
            /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at
         each bit position, add 1 or 2 instead.  For example,
         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.
         You can make any bit pattern that way using 1 less symbol than
         the basic or 0/1 method (except all bits 0, which would use no
         symbols, but a run of length 0 doesn't mean anything in this
         context).  Thus space is saved. */ if (nextSym === $ae4ce0e9653306c7$var$SYMBOL_RUNA) t += runPos;
            else t += 2 * runPos;
            runPos <<= 1;
            continue;
        }
        /* When we hit the first non-run symbol after a run, we now know
       how many times to repeat the last literal, so append that many
       copies to our buffer of decoded symbols (dbuf) now.  (The last
       literal used is the one at the head of the mtfSymbol array.) */ if (runPos) {
            runPos = 0;
            if (dbufCount + t > this.dbufSize) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
            uc = symToByte[mtfSymbol[0]];
            byteCount[uc] += t;
            while(t--)dbuf[dbufCount++] = uc;
        }
        /* Is this the terminating symbol? */ if (nextSym > symTotal) break;
        /* At this point, nextSym indicates a new literal character.  Subtract
       one to get the position in the MTF array at which this literal is
       currently to be found.  (Note that the result can't be -1 or 0,
       because 0 and 1 are RUNA and RUNB.  But another instance of the
       first symbol in the mtf array, position 0, would have been handled
       as part of a run above.  Therefore 1 unused mtf position minus
       2 non-literal nextSym values equals -1.) */ if (dbufCount >= this.dbufSize) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
        i = nextSym - 1;
        uc = $ae4ce0e9653306c7$var$mtf(mtfSymbol, i);
        uc = symToByte[uc];
        /* We have our literal byte.  Save it into dbuf. */ byteCount[uc]++;
        dbuf[dbufCount++] = uc;
    }
    /* At this point, we've read all the huffman-coded symbols (and repeated
     runs) for this block from the input stream, and decoded them into the
     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].
     Now undo the Burrows-Wheeler transform on dbuf.
     See http://dogma.net/markn/articles/bwt/bwt.htm
  */ if (origPointer < 0 || origPointer >= dbufCount) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR);
    /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */ j = 0;
    for(i = 0; i < 256; i++){
        k = j + byteCount[i];
        byteCount[i] = j;
        j = k;
    }
    /* Figure out what order dbuf would be in if we sorted it. */ for(i = 0; i < dbufCount; i++){
        uc = dbuf[i] & 0xff;
        dbuf[byteCount[uc]] |= i << 8;
        byteCount[uc]++;
    }
    /* Decode first byte by hand to initialize "previous" byte.  Note that it
     doesn't get output, and if the first three characters are identical
     it doesn't qualify as a run (hence writeRunCountdown=5). */ var pos = 0, current = 0, run = 0;
    if (dbufCount) {
        pos = dbuf[origPointer];
        current = pos & 0xff;
        pos >>= 8;
        run = -1;
    }
    this.writePos = pos;
    this.writeCurrent = current;
    this.writeCount = dbufCount;
    this.writeRun = run;
    return true; /* more blocks to come */ 
};
/* Undo burrows-wheeler transform on intermediate buffer to produce output.
   If start_bunzip was initialized with out_fd=-1, then up to len bytes of
   data are written to outbuf.  Return value is number of bytes written or
   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len
   are ignored, data is written to out_fd and return is RETVAL_OK or error.
*/ $ae4ce0e9653306c7$var$Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
    var copies, previous, outbyte;
    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully
       decoded, which results in this returning RETVAL_LAST_BLOCK, also
       equal to -1... Confusing, I'm returning 0 here to indicate no
       bytes written into the buffer */ if (this.writeCount < 0) return 0;
    var gotcount = 0;
    var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
    var dbufCount = this.writeCount, outputsize = this.outputsize;
    var run = this.writeRun;
    while(dbufCount){
        dbufCount--;
        previous = current;
        pos = dbuf[pos];
        current = pos & 0xff;
        pos >>= 8;
        if (run++ === 3) {
            copies = current;
            outbyte = previous;
            current = -1;
        } else {
            copies = 1;
            outbyte = current;
        }
        this.blockCRC.updateCRCRun(outbyte, copies);
        while(copies--){
            this.outputStream.writeByte(outbyte);
            this.nextoutput++;
        }
        if (current != previous) run = 0;
    }
    this.writeCount = dbufCount;
    // check CRC
    if (this.blockCRC.getCRC() !== this.targetBlockCRC) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR, "Bad block CRC (got " + this.blockCRC.getCRC().toString(16) + " expected " + this.targetBlockCRC.toString(16) + ")");
    return this.nextoutput;
};
var $ae4ce0e9653306c7$var$coerceInputStream = function(input) {
    if ("readByte" in input) return input;
    var inputStream = new $257839c0bf369abd$exports();
    inputStream.pos = 0;
    inputStream.readByte = function() {
        return input[this.pos++];
    };
    inputStream.seek = function(pos) {
        this.pos = pos;
    };
    inputStream.eof = function() {
        return this.pos >= input.length;
    };
    return inputStream;
};
var $ae4ce0e9653306c7$var$coerceOutputStream = function(output) {
    var outputStream = new $257839c0bf369abd$exports();
    var resizeOk = true;
    if (output) {
        if (typeof output === "number") {
            outputStream.buffer = new Buffer(output);
            resizeOk = false;
        } else if ("writeByte" in output) return output;
        else {
            outputStream.buffer = output;
            resizeOk = false;
        }
    } else outputStream.buffer = new Buffer(16384);
    outputStream.pos = 0;
    outputStream.writeByte = function(_byte) {
        if (resizeOk && this.pos >= this.buffer.length) {
            var newBuffer = new Buffer(this.buffer.length * 2);
            this.buffer.copy(newBuffer);
            this.buffer = newBuffer;
        }
        this.buffer[this.pos++] = _byte;
    };
    outputStream.getBuffer = function() {
        // trim buffer
        if (this.pos !== this.buffer.length) {
            if (!resizeOk) throw new TypeError("outputsize does not match decoded input");
            var newBuffer = new Buffer(this.pos);
            this.buffer.copy(newBuffer, 0, 0, this.pos);
            this.buffer = newBuffer;
        }
        return this.buffer;
    };
    outputStream._coerced = true;
    return outputStream;
};
/* Static helper functions */ $ae4ce0e9653306c7$var$Bunzip.Err = $ae4ce0e9653306c7$var$Err;
// 'input' can be a stream or a buffer
// 'output' can be a stream or a buffer or a number (buffer size)
$ae4ce0e9653306c7$var$Bunzip.decode = function(input, output, multistream) {
    // make a stream from a buffer, if necessary
    var inputStream = $ae4ce0e9653306c7$var$coerceInputStream(input);
    var outputStream = $ae4ce0e9653306c7$var$coerceOutputStream(output);
    var bz = new $ae4ce0e9653306c7$var$Bunzip(inputStream, outputStream);
    while(true){
        if ("eof" in inputStream && inputStream.eof()) break;
        if (bz._init_block()) bz._read_bunzip();
        else {
            var targetStreamCRC = bz.reader.read(32) >>> 0; // (convert to unsigned)
            if (targetStreamCRC !== bz.streamCRC) $ae4ce0e9653306c7$var$_throw($ae4ce0e9653306c7$var$Err.DATA_ERROR, "Bad stream CRC (got " + bz.streamCRC.toString(16) + " expected " + targetStreamCRC.toString(16) + ")");
            if (multistream && "eof" in inputStream && !inputStream.eof()) // note that start_bunzip will also resync the bit reader to next byte
            bz._start_bunzip(inputStream, outputStream);
            else break;
        }
    }
    if ("getBuffer" in outputStream) return outputStream.getBuffer();
};
$ae4ce0e9653306c7$var$Bunzip.decodeBlock = function(input, pos, output) {
    // make a stream from a buffer, if necessary
    var inputStream = $ae4ce0e9653306c7$var$coerceInputStream(input);
    var outputStream = $ae4ce0e9653306c7$var$coerceOutputStream(output);
    var bz = new $ae4ce0e9653306c7$var$Bunzip(inputStream, outputStream);
    bz.reader.seek(pos);
    /* Fill the decode buffer for the block */ var moreBlocks = bz._get_next_block();
    if (moreBlocks) {
        /* Init the CRC for writing */ bz.blockCRC = new $53e901237296740e$exports();
        /* Zero this so the current byte from before the seek is not written */ bz.writeCopies = 0;
        /* Decompress the block and write to stdout */ bz._read_bunzip();
    // XXX keep writing?
    }
    if ("getBuffer" in outputStream) return outputStream.getBuffer();
};
/* Reads bzip2 file from stream or buffer `input`, and invoke
 * `callback(position, size)` once for each bzip2 block,
 * where position gives the starting position (in *bits*)
 * and size gives uncompressed size of the block (in *bytes*). */ $ae4ce0e9653306c7$var$Bunzip.table = function(input, callback, multistream) {
    // make a stream from a buffer, if necessary
    var inputStream = new $257839c0bf369abd$exports();
    inputStream.delegate = $ae4ce0e9653306c7$var$coerceInputStream(input);
    inputStream.pos = 0;
    inputStream.readByte = function() {
        this.pos++;
        return this.delegate.readByte();
    };
    if (inputStream.delegate.eof) inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
    var outputStream = new $257839c0bf369abd$exports();
    outputStream.pos = 0;
    outputStream.writeByte = function() {
        this.pos++;
    };
    var bz = new $ae4ce0e9653306c7$var$Bunzip(inputStream, outputStream);
    var blockSize = bz.dbufSize;
    while(true){
        if ("eof" in inputStream && inputStream.eof()) break;
        var position = inputStream.pos * 8 + bz.reader.bitOffset;
        if (bz.reader.hasByte) position -= 8;
        if (bz._init_block()) {
            var start = outputStream.pos;
            bz._read_bunzip();
            callback(position, outputStream.pos - start);
        } else {
            var crc = bz.reader.read(32); // (but we ignore the crc)
            if (multistream && "eof" in inputStream && !inputStream.eof()) {
                // note that start_bunzip will also resync the bit reader to next byte
                bz._start_bunzip(inputStream, outputStream);
                console.assert(bz.dbufSize === blockSize, "shouldn't change block size within multistream file");
            } else break;
        }
    }
};
$ae4ce0e9653306c7$var$Bunzip.Stream = $257839c0bf369abd$exports;
$ae4ce0e9653306c7$var$Bunzip.version = $884729a90173e364$exports.version;
$ae4ce0e9653306c7$var$Bunzip.license = $884729a90173e364$exports.license;
$ae4ce0e9653306c7$exports = $ae4ce0e9653306c7$var$Bunzip;


var $abbabe373ecf5858$exports = {};

var $6IqSU = parcelRequire("6IqSU");
var $8743d18748c82e54$exports = {};
/* 
  bzip2.js - a small bzip2 decompression implementation
  
  Copyright 2011 by antimatter15 (antimatter15@gmail.com)
  
  Based on micro-bunzip by Rob Landley (rob@landley.net).

  Copyright (c) 2011 by antimatter15 (antimatter15@gmail.com).

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ function $8743d18748c82e54$var$Bzip2Error(message) {
    this.name = "Bzip2Error";
    this.message = message;
    this.stack = new Error().stack;
}
$8743d18748c82e54$var$Bzip2Error.prototype = new Error;
var $8743d18748c82e54$var$message = {
    Error: function(message) {
        throw new $8743d18748c82e54$var$Bzip2Error(message);
    }
};
var $8743d18748c82e54$var$bzip2 = {};
$8743d18748c82e54$var$bzip2.Bzip2Error = $8743d18748c82e54$var$Bzip2Error;
$8743d18748c82e54$var$bzip2.crcTable = [
    0x00000000,
    0x04c11db7,
    0x09823b6e,
    0x0d4326d9,
    0x130476dc,
    0x17c56b6b,
    0x1a864db2,
    0x1e475005,
    0x2608edb8,
    0x22c9f00f,
    0x2f8ad6d6,
    0x2b4bcb61,
    0x350c9b64,
    0x31cd86d3,
    0x3c8ea00a,
    0x384fbdbd,
    0x4c11db70,
    0x48d0c6c7,
    0x4593e01e,
    0x4152fda9,
    0x5f15adac,
    0x5bd4b01b,
    0x569796c2,
    0x52568b75,
    0x6a1936c8,
    0x6ed82b7f,
    0x639b0da6,
    0x675a1011,
    0x791d4014,
    0x7ddc5da3,
    0x709f7b7a,
    0x745e66cd,
    0x9823b6e0,
    0x9ce2ab57,
    0x91a18d8e,
    0x95609039,
    0x8b27c03c,
    0x8fe6dd8b,
    0x82a5fb52,
    0x8664e6e5,
    0xbe2b5b58,
    0xbaea46ef,
    0xb7a96036,
    0xb3687d81,
    0xad2f2d84,
    0xa9ee3033,
    0xa4ad16ea,
    0xa06c0b5d,
    0xd4326d90,
    0xd0f37027,
    0xddb056fe,
    0xd9714b49,
    0xc7361b4c,
    0xc3f706fb,
    0xceb42022,
    0xca753d95,
    0xf23a8028,
    0xf6fb9d9f,
    0xfbb8bb46,
    0xff79a6f1,
    0xe13ef6f4,
    0xe5ffeb43,
    0xe8bccd9a,
    0xec7dd02d,
    0x34867077,
    0x30476dc0,
    0x3d044b19,
    0x39c556ae,
    0x278206ab,
    0x23431b1c,
    0x2e003dc5,
    0x2ac12072,
    0x128e9dcf,
    0x164f8078,
    0x1b0ca6a1,
    0x1fcdbb16,
    0x018aeb13,
    0x054bf6a4,
    0x0808d07d,
    0x0cc9cdca,
    0x7897ab07,
    0x7c56b6b0,
    0x71159069,
    0x75d48dde,
    0x6b93dddb,
    0x6f52c06c,
    0x6211e6b5,
    0x66d0fb02,
    0x5e9f46bf,
    0x5a5e5b08,
    0x571d7dd1,
    0x53dc6066,
    0x4d9b3063,
    0x495a2dd4,
    0x44190b0d,
    0x40d816ba,
    0xaca5c697,
    0xa864db20,
    0xa527fdf9,
    0xa1e6e04e,
    0xbfa1b04b,
    0xbb60adfc,
    0xb6238b25,
    0xb2e29692,
    0x8aad2b2f,
    0x8e6c3698,
    0x832f1041,
    0x87ee0df6,
    0x99a95df3,
    0x9d684044,
    0x902b669d,
    0x94ea7b2a,
    0xe0b41de7,
    0xe4750050,
    0xe9362689,
    0xedf73b3e,
    0xf3b06b3b,
    0xf771768c,
    0xfa325055,
    0xfef34de2,
    0xc6bcf05f,
    0xc27dede8,
    0xcf3ecb31,
    0xcbffd686,
    0xd5b88683,
    0xd1799b34,
    0xdc3abded,
    0xd8fba05a,
    0x690ce0ee,
    0x6dcdfd59,
    0x608edb80,
    0x644fc637,
    0x7a089632,
    0x7ec98b85,
    0x738aad5c,
    0x774bb0eb,
    0x4f040d56,
    0x4bc510e1,
    0x46863638,
    0x42472b8f,
    0x5c007b8a,
    0x58c1663d,
    0x558240e4,
    0x51435d53,
    0x251d3b9e,
    0x21dc2629,
    0x2c9f00f0,
    0x285e1d47,
    0x36194d42,
    0x32d850f5,
    0x3f9b762c,
    0x3b5a6b9b,
    0x0315d626,
    0x07d4cb91,
    0x0a97ed48,
    0x0e56f0ff,
    0x1011a0fa,
    0x14d0bd4d,
    0x19939b94,
    0x1d528623,
    0xf12f560e,
    0xf5ee4bb9,
    0xf8ad6d60,
    0xfc6c70d7,
    0xe22b20d2,
    0xe6ea3d65,
    0xeba91bbc,
    0xef68060b,
    0xd727bbb6,
    0xd3e6a601,
    0xdea580d8,
    0xda649d6f,
    0xc423cd6a,
    0xc0e2d0dd,
    0xcda1f604,
    0xc960ebb3,
    0xbd3e8d7e,
    0xb9ff90c9,
    0xb4bcb610,
    0xb07daba7,
    0xae3afba2,
    0xaafbe615,
    0xa7b8c0cc,
    0xa379dd7b,
    0x9b3660c6,
    0x9ff77d71,
    0x92b45ba8,
    0x9675461f,
    0x8832161a,
    0x8cf30bad,
    0x81b02d74,
    0x857130c3,
    0x5d8a9099,
    0x594b8d2e,
    0x5408abf7,
    0x50c9b640,
    0x4e8ee645,
    0x4a4ffbf2,
    0x470cdd2b,
    0x43cdc09c,
    0x7b827d21,
    0x7f436096,
    0x7200464f,
    0x76c15bf8,
    0x68860bfd,
    0x6c47164a,
    0x61043093,
    0x65c52d24,
    0x119b4be9,
    0x155a565e,
    0x18197087,
    0x1cd86d30,
    0x029f3d35,
    0x065e2082,
    0x0b1d065b,
    0x0fdc1bec,
    0x3793a651,
    0x3352bbe6,
    0x3e119d3f,
    0x3ad08088,
    0x2497d08d,
    0x2056cd3a,
    0x2d15ebe3,
    0x29d4f654,
    0xc5a92679,
    0xc1683bce,
    0xcc2b1d17,
    0xc8ea00a0,
    0xd6ad50a5,
    0xd26c4d12,
    0xdf2f6bcb,
    0xdbee767c,
    0xe3a1cbc1,
    0xe760d676,
    0xea23f0af,
    0xeee2ed18,
    0xf0a5bd1d,
    0xf464a0aa,
    0xf9278673,
    0xfde69bc4,
    0x89b8fd09,
    0x8d79e0be,
    0x803ac667,
    0x84fbdbd0,
    0x9abc8bd5,
    0x9e7d9662,
    0x933eb0bb,
    0x97ffad0c,
    0xafb010b1,
    0xab710d06,
    0xa6322bdf,
    0xa2f33668,
    0xbcb4666d,
    0xb8757bda,
    0xb5365d03,
    0xb1f740b4
];
$8743d18748c82e54$var$bzip2.array = function(bytes) {
    var bit = 0, byte = 0;
    var BITMASK = [
        0,
        0x01,
        0x03,
        0x07,
        0x0F,
        0x1F,
        0x3F,
        0x7F,
        0xFF
    ];
    return function(n) {
        var result = 0;
        while(n > 0){
            var left = 8 - bit;
            if (n >= left) {
                result <<= left;
                result |= BITMASK[left] & bytes[byte++];
                bit = 0;
                n -= left;
            } else {
                result <<= n;
                result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
                bit += n;
                n = 0;
            }
        }
        return result;
    };
};
$8743d18748c82e54$var$bzip2.simple = function(srcbuffer, stream) {
    var bits = $8743d18748c82e54$var$bzip2.array(srcbuffer);
    var size = $8743d18748c82e54$var$bzip2.header(bits);
    var ret = false;
    var bufsize = 100000 * size;
    var buf = new Int32Array(bufsize);
    do ret = $8743d18748c82e54$var$bzip2.decompress(bits, stream, buf, bufsize);
    while (!ret);
};
$8743d18748c82e54$var$bzip2.header = function(bits) {
    this.byteCount = new Int32Array(256);
    this.symToByte = new Uint8Array(256);
    this.mtfSymbol = new Int32Array(256);
    this.selectors = new Uint8Array(0x8000);
    if (bits(24) != 4348520) $8743d18748c82e54$var$message.Error("No magic number found");
    var i = bits(8) - 48;
    if (i < 1 || i > 9) $8743d18748c82e54$var$message.Error("Not a BZIP archive");
    return i;
};
//takes a function for reading the block data (starting with 0x314159265359)
//a block size (0-9) (optional, defaults to 9)
//a length at which to stop decompressing and return the output
$8743d18748c82e54$var$bzip2.decompress = function(bits, stream, buf, bufsize, streamCRC) {
    var MAX_HUFCODE_BITS = 20;
    var MAX_SYMBOLS = 258;
    var SYMBOL_RUNA = 0;
    var SYMBOL_RUNB = 1;
    var GROUP_SIZE = 50;
    var crc = -1;
    for(var h = "", i = 0; i < 6; i++)h += bits(8).toString(16);
    if (h == "177245385090") {
        var finalCRC = bits(32) | 0;
        if (finalCRC !== streamCRC) $8743d18748c82e54$var$message.Error("Error in bzip2: crc32 do not match");
        // align stream to byte
        bits(null);
        return null; // reset streamCRC for next call
    }
    if (h != "314159265359") $8743d18748c82e54$var$message.Error("eek not valid bzip data");
    var crcblock = bits(32) | 0; // CRC code
    if (bits(1)) $8743d18748c82e54$var$message.Error("unsupported obsolete version");
    var origPtr = bits(24);
    if (origPtr > bufsize) $8743d18748c82e54$var$message.Error("Initial position larger than buffer size");
    var t = bits(16);
    var symTotal = 0;
    for(i = 0; i < 16; i++)if (t & 1 << 15 - i) {
        var k = bits(16);
        for(j = 0; j < 16; j++)if (k & 1 << 15 - j) this.symToByte[symTotal++] = 16 * i + j;
    }
    var groupCount = bits(3);
    if (groupCount < 2 || groupCount > 6) $8743d18748c82e54$var$message.Error("another error");
    var nSelectors = bits(15);
    if (nSelectors == 0) $8743d18748c82e54$var$message.Error("meh");
    for(var i = 0; i < groupCount; i++)this.mtfSymbol[i] = i;
    for(var i = 0; i < nSelectors; i++){
        for(var j = 0; bits(1); j++)if (j >= groupCount) $8743d18748c82e54$var$message.Error("whoops another error");
        var uc = this.mtfSymbol[j];
        for(var k = j - 1; k >= 0; k--)this.mtfSymbol[k + 1] = this.mtfSymbol[k];
        this.mtfSymbol[0] = uc;
        this.selectors[i] = uc;
    }
    var symCount = symTotal + 2;
    var groups = [];
    var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
    var hufGroup;
    for(var j = 0; j < groupCount; j++){
        t = bits(5); //lengths
        for(var i = 0; i < symCount; i++){
            while(true){
                if (t < 1 || t > MAX_HUFCODE_BITS) $8743d18748c82e54$var$message.Error("I gave up a while ago on writing error messages");
                if (!bits(1)) break;
                if (!bits(1)) t++;
                else t--;
            }
            length[i] = t;
        }
        var minLen, maxLen;
        minLen = maxLen = length[0];
        for(var i = 1; i < symCount; i++){
            if (length[i] > maxLen) maxLen = length[i];
            else if (length[i] < minLen) minLen = length[i];
        }
        hufGroup = groups[j] = {};
        hufGroup.permute = new Int32Array(MAX_SYMBOLS);
        hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var base = hufGroup.base;
        var limit = hufGroup.limit;
        var pp = 0;
        for(var i = minLen; i <= maxLen; i++)for(var t = 0; t < symCount; t++)if (length[t] == i) hufGroup.permute[pp++] = t;
        for(i = minLen; i <= maxLen; i++)temp[i] = limit[i] = 0;
        for(i = 0; i < symCount; i++)temp[length[i]]++;
        pp = t = 0;
        for(i = minLen; i < maxLen; i++){
            pp += temp[i];
            limit[i] = pp - 1;
            pp <<= 1;
            base[i + 1] = pp - (t += temp[i]);
        }
        limit[maxLen] = pp + temp[maxLen] - 1;
        base[minLen] = 0;
    }
    for(var i = 0; i < 256; i++){
        this.mtfSymbol[i] = i;
        this.byteCount[i] = 0;
    }
    var runPos, count, symCount, selector;
    runPos = count = symCount = selector = 0;
    while(true){
        if (!symCount--) {
            symCount = GROUP_SIZE - 1;
            if (selector >= nSelectors) $8743d18748c82e54$var$message.Error("meow i'm a kitty, that's an error");
            hufGroup = groups[this.selectors[selector++]];
            base = hufGroup.base;
            limit = hufGroup.limit;
        }
        i = hufGroup.minLen;
        j = bits(i);
        while(true){
            if (i > hufGroup.maxLen) $8743d18748c82e54$var$message.Error("rawr i'm a dinosaur");
            if (j <= limit[i]) break;
            i++;
            j = j << 1 | bits(1);
        }
        j -= base[i];
        if (j < 0 || j >= MAX_SYMBOLS) $8743d18748c82e54$var$message.Error("moo i'm a cow");
        var nextSym = hufGroup.permute[j];
        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
            if (!runPos) {
                runPos = 1;
                t = 0;
            }
            if (nextSym == SYMBOL_RUNA) t += runPos;
            else t += 2 * runPos;
            runPos <<= 1;
            continue;
        }
        if (runPos) {
            runPos = 0;
            if (count + t > bufsize) $8743d18748c82e54$var$message.Error("Boom.");
            uc = this.symToByte[this.mtfSymbol[0]];
            this.byteCount[uc] += t;
            while(t--)buf[count++] = uc;
        }
        if (nextSym > symTotal) break;
        if (count >= bufsize) $8743d18748c82e54$var$message.Error("I can't think of anything. Error");
        i = nextSym - 1;
        uc = this.mtfSymbol[i];
        for(var k = i - 1; k >= 0; k--)this.mtfSymbol[k + 1] = this.mtfSymbol[k];
        this.mtfSymbol[0] = uc;
        uc = this.symToByte[uc];
        this.byteCount[uc]++;
        buf[count++] = uc;
    }
    if (origPtr < 0 || origPtr >= count) $8743d18748c82e54$var$message.Error("I'm a monkey and I'm throwing something at someone, namely you");
    var j = 0;
    for(var i = 0; i < 256; i++){
        k = j + this.byteCount[i];
        this.byteCount[i] = j;
        j = k;
    }
    for(var i = 0; i < count; i++){
        uc = buf[i] & 0xff;
        buf[this.byteCount[uc]] |= i << 8;
        this.byteCount[uc]++;
    }
    var pos = 0, current = 0, run = 0;
    if (count) {
        pos = buf[origPtr];
        current = pos & 0xff;
        pos >>= 8;
        run = -1;
    }
    count;
    var copies, previous, outbyte;
    while(count){
        count--;
        previous = current;
        pos = buf[pos];
        current = pos & 0xff;
        pos >>= 8;
        if (run++ == 3) {
            copies = current;
            outbyte = previous;
            current = -1;
        } else {
            copies = 1;
            outbyte = current;
        }
        while(copies--){
            crc = (crc << 8 ^ this.crcTable[(crc >> 24 ^ outbyte) & 0xFF]) & 0xFFFFFFFF; // crc32
            stream(outbyte);
        }
        if (current != previous) run = 0;
    }
    crc = (crc ^ -1) >>> 0;
    if ((crc | 0) != (crcblock | 0)) $8743d18748c82e54$var$message.Error("Error in bzip2: crc32 do not match");
    streamCRC = (crc ^ (streamCRC << 1 | streamCRC >>> 31)) & 0xFFFFFFFF;
    return streamCRC;
};
$8743d18748c82e54$exports = $8743d18748c82e54$var$bzip2;


var $47e27c02af497b9d$exports = {};
var $47e27c02af497b9d$var$BITMASK = [
    0,
    0x01,
    0x03,
    0x07,
    0x0F,
    0x1F,
    0x3F,
    0x7F,
    0xFF
];
// returns a function that reads bits.
// takes a buffer iterator as input
$47e27c02af497b9d$exports = function bitIterator(nextBuffer) {
    var bit = 0, byte = 0;
    var bytes = nextBuffer();
    var f = function(n) {
        if (n === null && bit != 0) {
            bit = 0;
            byte++;
            return;
        }
        var result = 0;
        while(n > 0){
            if (byte >= bytes.length) {
                byte = 0;
                bytes = nextBuffer();
            }
            var left = 8 - bit;
            if (bit === 0 && n > 0) f.bytesRead++;
            if (n >= left) {
                result <<= left;
                result |= $47e27c02af497b9d$var$BITMASK[left] & bytes[byte++];
                bit = 0;
                n -= left;
            } else {
                result <<= n;
                result |= (bytes[byte] & $47e27c02af497b9d$var$BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
                bit += n;
                n = 0;
            }
        }
        return result;
    };
    f.bytesRead = 0;
    return f;
};


$abbabe373ecf5858$exports = $abbabe373ecf5858$var$unbzip2Stream;
function $abbabe373ecf5858$var$unbzip2Stream() {
    var bufferQueue = [];
    var hasBytes = 0;
    var blockSize = 0;
    var broken = false;
    var done = false;
    var bitReader = null;
    var streamCRC = null;
    function decompressBlock(push) {
        if (!blockSize) {
            blockSize = $8743d18748c82e54$exports.header(bitReader);
            //console.error("got header of", blockSize);
            streamCRC = 0;
            return true;
        } else {
            var bufsize = 100000 * blockSize;
            var buf = new Int32Array(bufsize);
            var chunk = [];
            var f = function(b) {
                chunk.push(b);
            };
            streamCRC = $8743d18748c82e54$exports.decompress(bitReader, f, buf, bufsize, streamCRC);
            if (streamCRC === null) {
                // reset for next bzip2 header
                blockSize = 0;
                return false;
            } else {
                //console.error('decompressed', chunk.length,'bytes');
                push(Buffer.from(chunk));
                return true;
            }
        }
    }
    var outlength = 0;
    function decompressAndQueue(stream) {
        if (broken) return;
        try {
            return decompressBlock(function(d) {
                stream.queue(d);
                if (d !== null) //console.error('write at', outlength.toString(16));
                outlength += d.length;
            });
        } catch (e) {
            //console.error(e);
            stream.emit("error", e);
            broken = true;
            return false;
        }
    }
    return $6IqSU(function write(data) {
        //console.error('received', data.length,'bytes in', typeof data);
        bufferQueue.push(data);
        hasBytes += data.length;
        if (bitReader === null) bitReader = $47e27c02af497b9d$exports(function() {
            return bufferQueue.shift();
        });
        while(!broken && hasBytes - bitReader.bytesRead + 1 >= (25000 + 100000 * blockSize || 4))//console.error('decompressing with', hasBytes - bitReader.bytesRead + 1, 'bytes in buffer');
        decompressAndQueue(this);
    }, function end(x) {
        //console.error(x,'last compressing with', hasBytes, 'bytes in buffer');
        while(!broken && bitReader && hasBytes > bitReader.bytesRead)decompressAndQueue(this);
        if (!broken) {
            if (streamCRC !== null) this.emit("error", new Error("input stream ended prematurely"));
            this.queue(null);
        }
    });
}


$b05f17374a7517a3$exports = ()=>(input)=>{
        if (!Buffer.isBuffer(input) && !$7e24865fa78e5f40$exports(input)) return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
        if (Buffer.isBuffer(input) && (!$3584865a960a1dc0$exports(input) || $3584865a960a1dc0$exports(input).ext !== "bz2")) return Promise.resolve([]);
        if (Buffer.isBuffer(input)) return $9d614d74911e0026$exports()($ae4ce0e9653306c7$exports.decode(input));
        return $9d614d74911e0026$exports()(input.pipe($abbabe373ecf5858$exports()));
    };


var $a9641a5c75629d2a$exports = {};
"use strict";




$a9641a5c75629d2a$exports = ()=>(input)=>{
        if (!Buffer.isBuffer(input) && !$7e24865fa78e5f40$exports(input)) return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
        if (Buffer.isBuffer(input) && (!$47ca99bd2820c44b$exports(input) || $47ca99bd2820c44b$exports(input).ext !== "gz")) return Promise.resolve([]);
        const unzip = $dAk3n$zlib.createGunzip();
        const result = $9d614d74911e0026$exports()(unzip);
        if (Buffer.isBuffer(input)) unzip.end(input);
        else input.pipe(unzip);
        return result;
    };


var $2cde43dad30286f7$exports = {};
"use strict";
var $819bbe6523f48390$exports = {};
"use strict";
$819bbe6523f48390$exports = function(buf) {
    if (!(buf && buf.length > 1)) return null;
    if (buf[0] === 0xFF && buf[1] === 0xD8 && buf[2] === 0xFF) return {
        ext: "jpg",
        mime: "image/jpeg"
    };
    if (buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4E && buf[3] === 0x47) return {
        ext: "png",
        mime: "image/png"
    };
    if (buf[0] === 0x47 && buf[1] === 0x49 && buf[2] === 0x46) return {
        ext: "gif",
        mime: "image/gif"
    };
    if (buf[8] === 0x57 && buf[9] === 0x45 && buf[10] === 0x42 && buf[11] === 0x50) return {
        ext: "webp",
        mime: "image/webp"
    };
    if (buf[0] === 0x46 && buf[1] === 0x4C && buf[2] === 0x49 && buf[3] === 0x46) return {
        ext: "flif",
        mime: "image/flif"
    };
    // needs to be before `tif` check
    if ((buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2A && buf[3] === 0x0 || buf[0] === 0x4D && buf[1] === 0x4D && buf[2] === 0x0 && buf[3] === 0x2A) && buf[8] === 0x43 && buf[9] === 0x52) return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
    };
    if (buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2A && buf[3] === 0x0 || buf[0] === 0x4D && buf[1] === 0x4D && buf[2] === 0x0 && buf[3] === 0x2A) return {
        ext: "tif",
        mime: "image/tiff"
    };
    if (buf[0] === 0x42 && buf[1] === 0x4D) return {
        ext: "bmp",
        mime: "image/bmp"
    };
    if (buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0xBC) return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
    };
    if (buf[0] === 0x38 && buf[1] === 0x42 && buf[2] === 0x50 && buf[3] === 0x53) return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
    };
    // needs to be before `zip` check
    if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x3 && buf[3] === 0x4 && buf[30] === 0x6D && buf[31] === 0x69 && buf[32] === 0x6D && buf[33] === 0x65 && buf[34] === 0x74 && buf[35] === 0x79 && buf[36] === 0x70 && buf[37] === 0x65 && buf[38] === 0x61 && buf[39] === 0x70 && buf[40] === 0x70 && buf[41] === 0x6C && buf[42] === 0x69 && buf[43] === 0x63 && buf[44] === 0x61 && buf[45] === 0x74 && buf[46] === 0x69 && buf[47] === 0x6F && buf[48] === 0x6E && buf[49] === 0x2F && buf[50] === 0x65 && buf[51] === 0x70 && buf[52] === 0x75 && buf[53] === 0x62 && buf[54] === 0x2B && buf[55] === 0x7A && buf[56] === 0x69 && buf[57] === 0x70) return {
        ext: "epub",
        mime: "application/epub+zip"
    };
    // needs to be before `zip` check
    // assumes signed .xpi from addons.mozilla.org
    if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x3 && buf[3] === 0x4 && buf[30] === 0x4D && buf[31] === 0x45 && buf[32] === 0x54 && buf[33] === 0x41 && buf[34] === 0x2D && buf[35] === 0x49 && buf[36] === 0x4E && buf[37] === 0x46 && buf[38] === 0x2F && buf[39] === 0x6D && buf[40] === 0x6F && buf[41] === 0x7A && buf[42] === 0x69 && buf[43] === 0x6C && buf[44] === 0x6C && buf[45] === 0x61 && buf[46] === 0x2E && buf[47] === 0x72 && buf[48] === 0x73 && buf[49] === 0x61) return {
        ext: "xpi",
        mime: "application/x-xpinstall"
    };
    if (buf[0] === 0x50 && buf[1] === 0x4B && (buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) && (buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)) return {
        ext: "zip",
        mime: "application/zip"
    };
    if (buf[257] === 0x75 && buf[258] === 0x73 && buf[259] === 0x74 && buf[260] === 0x61 && buf[261] === 0x72) return {
        ext: "tar",
        mime: "application/x-tar"
    };
    if (buf[0] === 0x52 && buf[1] === 0x61 && buf[2] === 0x72 && buf[3] === 0x21 && buf[4] === 0x1A && buf[5] === 0x7 && (buf[6] === 0x0 || buf[6] === 0x1)) return {
        ext: "rar",
        mime: "application/x-rar-compressed"
    };
    if (buf[0] === 0x1F && buf[1] === 0x8B && buf[2] === 0x8) return {
        ext: "gz",
        mime: "application/gzip"
    };
    if (buf[0] === 0x42 && buf[1] === 0x5A && buf[2] === 0x68) return {
        ext: "bz2",
        mime: "application/x-bzip2"
    };
    if (buf[0] === 0x37 && buf[1] === 0x7A && buf[2] === 0xBC && buf[3] === 0xAF && buf[4] === 0x27 && buf[5] === 0x1C) return {
        ext: "7z",
        mime: "application/x-7z-compressed"
    };
    if (buf[0] === 0x78 && buf[1] === 0x01) return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
    };
    if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && (buf[3] === 0x18 || buf[3] === 0x20) && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 || buf[0] === 0x33 && buf[1] === 0x67 && buf[2] === 0x70 && buf[3] === 0x35 || buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x6D && buf[9] === 0x70 && buf[10] === 0x34 && buf[11] === 0x32 && buf[16] === 0x6D && buf[17] === 0x70 && buf[18] === 0x34 && buf[19] === 0x31 && buf[20] === 0x6D && buf[21] === 0x70 && buf[22] === 0x34 && buf[23] === 0x32 && buf[24] === 0x69 && buf[25] === 0x73 && buf[26] === 0x6F && buf[27] === 0x6D || buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x69 && buf[9] === 0x73 && buf[10] === 0x6F && buf[11] === 0x6D || buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1c && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x6D && buf[9] === 0x70 && buf[10] === 0x34 && buf[11] === 0x32 && buf[12] === 0x0 && buf[13] === 0x0 && buf[14] === 0x0 && buf[15] === 0x0) return {
        ext: "mp4",
        mime: "video/mp4"
    };
    if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x1C && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x4D && buf[9] === 0x34 && buf[10] === 0x56) return {
        ext: "m4v",
        mime: "video/x-m4v"
    };
    if (buf[0] === 0x4D && buf[1] === 0x54 && buf[2] === 0x68 && buf[3] === 0x64) return {
        ext: "mid",
        mime: "audio/midi"
    };
    // needs to be before the `webm` check
    if (buf[31] === 0x6D && buf[32] === 0x61 && buf[33] === 0x74 && buf[34] === 0x72 && buf[35] === 0x6f && buf[36] === 0x73 && buf[37] === 0x6B && buf[38] === 0x61) return {
        ext: "mkv",
        mime: "video/x-matroska"
    };
    if (buf[0] === 0x1A && buf[1] === 0x45 && buf[2] === 0xDF && buf[3] === 0xA3) return {
        ext: "webm",
        mime: "video/webm"
    };
    if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x0 && buf[3] === 0x14 && buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70) return {
        ext: "mov",
        mime: "video/quicktime"
    };
    if (buf[0] === 0x52 && buf[1] === 0x49 && buf[2] === 0x46 && buf[3] === 0x46 && buf[8] === 0x41 && buf[9] === 0x56 && buf[10] === 0x49) return {
        ext: "avi",
        mime: "video/x-msvideo"
    };
    if (buf[0] === 0x30 && buf[1] === 0x26 && buf[2] === 0xB2 && buf[3] === 0x75 && buf[4] === 0x8E && buf[5] === 0x66 && buf[6] === 0xCF && buf[7] === 0x11 && buf[8] === 0xA6 && buf[9] === 0xD9) return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
    };
    if (buf[0] === 0x0 && buf[1] === 0x0 && buf[2] === 0x1 && buf[3].toString(16)[0] === "b") return {
        ext: "mpg",
        mime: "video/mpeg"
    };
    if (buf[0] === 0x49 && buf[1] === 0x44 && buf[2] === 0x33 || buf[0] === 0xFF && buf[1] === 0xfb) return {
        ext: "mp3",
        mime: "audio/mpeg"
    };
    if (buf[4] === 0x66 && buf[5] === 0x74 && buf[6] === 0x79 && buf[7] === 0x70 && buf[8] === 0x4D && buf[9] === 0x34 && buf[10] === 0x41 || buf[0] === 0x4D && buf[1] === 0x34 && buf[2] === 0x41 && buf[3] === 0x20) return {
        ext: "m4a",
        mime: "audio/m4a"
    };
    // needs to be before `ogg` check
    if (buf[28] === 0x4F && buf[29] === 0x70 && buf[30] === 0x75 && buf[31] === 0x73 && buf[32] === 0x48 && buf[33] === 0x65 && buf[34] === 0x61 && buf[35] === 0x64) return {
        ext: "opus",
        mime: "audio/opus"
    };
    if (buf[0] === 0x4F && buf[1] === 0x67 && buf[2] === 0x67 && buf[3] === 0x53) return {
        ext: "ogg",
        mime: "audio/ogg"
    };
    if (buf[0] === 0x66 && buf[1] === 0x4C && buf[2] === 0x61 && buf[3] === 0x43) return {
        ext: "flac",
        mime: "audio/x-flac"
    };
    if (buf[0] === 0x52 && buf[1] === 0x49 && buf[2] === 0x46 && buf[3] === 0x46 && buf[8] === 0x57 && buf[9] === 0x41 && buf[10] === 0x56 && buf[11] === 0x45) return {
        ext: "wav",
        mime: "audio/x-wav"
    };
    if (buf[0] === 0x23 && buf[1] === 0x21 && buf[2] === 0x41 && buf[3] === 0x4D && buf[4] === 0x52 && buf[5] === 0x0A) return {
        ext: "amr",
        mime: "audio/amr"
    };
    if (buf[0] === 0x25 && buf[1] === 0x50 && buf[2] === 0x44 && buf[3] === 0x46) return {
        ext: "pdf",
        mime: "application/pdf"
    };
    if (buf[0] === 0x4D && buf[1] === 0x5A) return {
        ext: "exe",
        mime: "application/x-msdownload"
    };
    if ((buf[0] === 0x43 || buf[0] === 0x46) && buf[1] === 0x57 && buf[2] === 0x53) return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
    };
    if (buf[0] === 0x7B && buf[1] === 0x5C && buf[2] === 0x72 && buf[3] === 0x74 && buf[4] === 0x66) return {
        ext: "rtf",
        mime: "application/rtf"
    };
    if (buf[0] === 0x77 && buf[1] === 0x4F && buf[2] === 0x46 && buf[3] === 0x46 && (buf[4] === 0x00 && buf[5] === 0x01 && buf[6] === 0x00 && buf[7] === 0x00 || buf[4] === 0x4F && buf[5] === 0x54 && buf[6] === 0x54 && buf[7] === 0x4F)) return {
        ext: "woff",
        mime: "application/font-woff"
    };
    if (buf[0] === 0x77 && buf[1] === 0x4F && buf[2] === 0x46 && buf[3] === 0x32 && (buf[4] === 0x00 && buf[5] === 0x01 && buf[6] === 0x00 && buf[7] === 0x00 || buf[4] === 0x4F && buf[5] === 0x54 && buf[6] === 0x54 && buf[7] === 0x4F)) return {
        ext: "woff2",
        mime: "application/font-woff"
    };
    if (buf[34] === 0x4C && buf[35] === 0x50 && (buf[8] === 0x00 && buf[9] === 0x00 && buf[10] === 0x01 || buf[8] === 0x01 && buf[9] === 0x00 && buf[10] === 0x02 || buf[8] === 0x02 && buf[9] === 0x00 && buf[10] === 0x02)) return {
        ext: "eot",
        mime: "application/octet-stream"
    };
    if (buf[0] === 0x00 && buf[1] === 0x01 && buf[2] === 0x00 && buf[3] === 0x00 && buf[4] === 0x00) return {
        ext: "ttf",
        mime: "application/font-sfnt"
    };
    if (buf[0] === 0x4F && buf[1] === 0x54 && buf[2] === 0x54 && buf[3] === 0x4F && buf[4] === 0x00) return {
        ext: "otf",
        mime: "application/font-sfnt"
    };
    if (buf[0] === 0x00 && buf[1] === 0x00 && buf[2] === 0x01 && buf[3] === 0x00) return {
        ext: "ico",
        mime: "image/x-icon"
    };
    if (buf[0] === 0x46 && buf[1] === 0x4C && buf[2] === 0x56 && buf[3] === 0x01) return {
        ext: "flv",
        mime: "video/x-flv"
    };
    if (buf[0] === 0x25 && buf[1] === 0x21) return {
        ext: "ps",
        mime: "application/postscript"
    };
    if (buf[0] === 0xFD && buf[1] === 0x37 && buf[2] === 0x7A && buf[3] === 0x58 && buf[4] === 0x5A && buf[5] === 0x00) return {
        ext: "xz",
        mime: "application/x-xz"
    };
    if (buf[0] === 0x53 && buf[1] === 0x51 && buf[2] === 0x4C && buf[3] === 0x69) return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
    };
    if (buf[0] === 0x4E && buf[1] === 0x45 && buf[2] === 0x53 && buf[3] === 0x1A) return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
    };
    if (buf[0] === 0x43 && buf[1] === 0x72 && buf[2] === 0x32 && buf[3] === 0x34) return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
    };
    if (buf[0] === 0x4D && buf[1] === 0x53 && buf[2] === 0x43 && buf[3] === 0x46 || buf[0] === 0x49 && buf[1] === 0x53 && buf[2] === 0x63 && buf[3] === 0x28) return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
    };
    // needs to be before `ar` check
    if (buf[0] === 0x21 && buf[1] === 0x3C && buf[2] === 0x61 && buf[3] === 0x72 && buf[4] === 0x63 && buf[5] === 0x68 && buf[6] === 0x3E && buf[7] === 0x0A && buf[8] === 0x64 && buf[9] === 0x65 && buf[10] === 0x62 && buf[11] === 0x69 && buf[12] === 0x61 && buf[13] === 0x6E && buf[14] === 0x2D && buf[15] === 0x62 && buf[16] === 0x69 && buf[17] === 0x6E && buf[18] === 0x61 && buf[19] === 0x72 && buf[20] === 0x79) return {
        ext: "deb",
        mime: "application/x-deb"
    };
    if (buf[0] === 0x21 && buf[1] === 0x3C && buf[2] === 0x61 && buf[3] === 0x72 && buf[4] === 0x63 && buf[5] === 0x68 && buf[6] === 0x3E) return {
        ext: "ar",
        mime: "application/x-unix-archive"
    };
    if (buf[0] === 0xED && buf[1] === 0xAB && buf[2] === 0xEE && buf[3] === 0xDB) return {
        ext: "rpm",
        mime: "application/x-rpm"
    };
    if (buf[0] === 0x1F && buf[1] === 0xA0 || buf[0] === 0x1F && buf[1] === 0x9D) return {
        ext: "Z",
        mime: "application/x-compress"
    };
    if (buf[0] === 0x4C && buf[1] === 0x5A && buf[2] === 0x49 && buf[3] === 0x50) return {
        ext: "lz",
        mime: "application/x-lzip"
    };
    if (buf[0] === 0xD0 && buf[1] === 0xCF && buf[2] === 0x11 && buf[3] === 0xE0 && buf[4] === 0xA1 && buf[5] === 0xB1 && buf[6] === 0x1A && buf[7] === 0xE1) return {
        ext: "msi",
        mime: "application/x-msi"
    };
    return null;
};


var $cad08794b0acdd42$exports = {};
"use strict";
var $366e887de2aa76f2$exports = {};
"use strict";

$366e887de2aa76f2$exports = typeof Promise === "function" ? Promise : (parcelRequire("ekQJU"));


var $82edc05e3e4e64bc$exports = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ "use strict";
/* eslint-disable no-unused-vars */ var $82edc05e3e4e64bc$var$getOwnPropertySymbols = Object.getOwnPropertySymbols;
var $82edc05e3e4e64bc$var$hasOwnProperty = Object.prototype.hasOwnProperty;
var $82edc05e3e4e64bc$var$propIsEnumerable = Object.prototype.propertyIsEnumerable;
function $82edc05e3e4e64bc$var$toObject(val) {
    if (val === null || val === undefined) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(val);
}
function $82edc05e3e4e64bc$var$shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String("abc"); // eslint-disable-line no-new-wrappers
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for(var i = 0; i < 10; i++)test2["_" + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
$82edc05e3e4e64bc$exports = $82edc05e3e4e64bc$var$shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = $82edc05e3e4e64bc$var$toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if ($82edc05e3e4e64bc$var$hasOwnProperty.call(from, key)) to[key] = from[key];
        if ($82edc05e3e4e64bc$var$getOwnPropertySymbols) {
            symbols = $82edc05e3e4e64bc$var$getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if ($82edc05e3e4e64bc$var$propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};


var $0b626e0d253e9811$exports = {};

var $0b626e0d253e9811$require$PassThrough = $dAk3n$stream.PassThrough;

$0b626e0d253e9811$exports = function(opts) {
    opts = $82edc05e3e4e64bc$exports({}, opts);
    var array = opts.array;
    var encoding = opts.encoding;
    var buffer = encoding === "buffer";
    var objectMode = false;
    if (array) objectMode = !(encoding || buffer);
    else encoding = encoding || "utf8";
    if (buffer) encoding = null;
    var len = 0;
    var ret = [];
    var stream = new $0b626e0d253e9811$require$PassThrough({
        objectMode: objectMode
    });
    if (encoding) stream.setEncoding(encoding);
    stream.on("data", function(chunk) {
        ret.push(chunk);
        if (objectMode) len = ret.length;
        else len += chunk.length;
    });
    stream.getBufferedValue = function() {
        if (array) return ret;
        return buffer ? Buffer.concat(ret, len) : ret.join("");
    };
    stream.getBufferedLength = function() {
        return len;
    };
    return stream;
};


function $cad08794b0acdd42$var$getStream(inputStream, opts) {
    if (!inputStream) return $366e887de2aa76f2$exports.reject(new Error("Expected a stream"));
    opts = $82edc05e3e4e64bc$exports({
        maxBuffer: Infinity
    }, opts);
    var maxBuffer = opts.maxBuffer;
    var stream;
    var clean;
    var p = new $366e887de2aa76f2$exports(function(resolve, reject) {
        stream = $0b626e0d253e9811$exports(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream);
        stream.on("data", function() {
            if (stream.getBufferedLength() > maxBuffer) reject(new Error("maxBuffer exceeded"));
        });
        stream.once("error", error);
        stream.on("end", resolve);
        clean = function() {
            // some streams doesn't implement the stream.Readable interface correctly
            if (inputStream.unpipe) inputStream.unpipe(stream);
        };
        function error(err) {
            if (err) err.bufferedData = stream.getBufferedValue();
            reject(err);
        }
    });
    p.then(clean, clean);
    return p.then(function() {
        return stream.getBufferedValue();
    });
}
$cad08794b0acdd42$exports = $cad08794b0acdd42$var$getStream;
$cad08794b0acdd42$exports.buffer = function(stream, opts) {
    return $cad08794b0acdd42$var$getStream(stream, $82edc05e3e4e64bc$exports({}, opts, {
        encoding: "buffer"
    }));
};
$cad08794b0acdd42$exports.array = function(stream, opts) {
    return $cad08794b0acdd42$var$getStream(stream, $82edc05e3e4e64bc$exports({}, opts, {
        array: true
    }));
};


var $1d7c960cf32ac643$exports = {};
"use strict";
var $1d7c960cf32ac643$var$processFn = function(fn, P, opts) {
    return function() {
        var that = this;
        var args = new Array(arguments.length);
        for(var i = 0; i < arguments.length; i++)args[i] = arguments[i];
        return new P(function(resolve, reject) {
            args.push(function(err, result) {
                if (err) reject(err);
                else if (opts.multiArgs) {
                    var results = new Array(arguments.length - 1);
                    for(var i = 1; i < arguments.length; i++)results[i - 1] = arguments[i];
                    resolve(results);
                } else resolve(result);
            });
            fn.apply(that, args);
        });
    };
};
var $1d7c960cf32ac643$var$pify = $1d7c960cf32ac643$exports = function(obj, P, opts) {
    if (typeof P !== "function") {
        opts = P;
        P = Promise;
    }
    opts = opts || {};
    opts.exclude = opts.exclude || [
        /.+Sync$/
    ];
    var filter = function(key) {
        var match = function(pattern) {
            return typeof pattern === "string" ? key === pattern : pattern.test(key);
        };
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    };
    var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) return obj.apply(this, arguments);
        return $1d7c960cf32ac643$var$processFn(obj, P, opts).apply(this, arguments);
    } : {};
    return Object.keys(obj).reduce(function(ret, key) {
        var x = obj[key];
        ret[key] = typeof x === "function" && filter(key) ? $1d7c960cf32ac643$var$processFn(x, P, opts) : x;
        return ret;
    }, ret);
};
$1d7c960cf32ac643$var$pify.all = $1d7c960cf32ac643$var$pify;


var $9327dbea45d806c8$export$3ce6949f20cea765;
var $9327dbea45d806c8$export$e74adcc69ca6d332;
var $9327dbea45d806c8$export$d573cdcf1a515b2;
var $9327dbea45d806c8$export$2743bcf0109a5529;
var $9327dbea45d806c8$export$9f59f5eb9355b723;
var $9327dbea45d806c8$export$74cd253e69ae5d6;
var $9327dbea45d806c8$export$361a87d8d0c7288a;
var $9327dbea45d806c8$export$3bb977b3ba9d3b59;
var $9327dbea45d806c8$export$20e0d31d48ad8a6;


var $db8caba3e2b324f4$export$2f2091512d4ea5d1;
var $db8caba3e2b324f4$export$c1424497e0182b46;
var $db8caba3e2b324f4$export$46ba22c707fcd454;
var $db8caba3e2b324f4$export$fbcb7e4b44767f77;



var $db8caba3e2b324f4$var$Readable = $dAk3n$stream.Readable;
var $db8caba3e2b324f4$var$Writable = $dAk3n$stream.Writable;
var $db8caba3e2b324f4$var$PassThrough = $dAk3n$stream.PassThrough;
var $2dae99500e9cba80$exports = {};
$2dae99500e9cba80$exports = $2dae99500e9cba80$var$Pend;
function $2dae99500e9cba80$var$Pend() {
    this.pending = 0;
    this.max = Infinity;
    this.listeners = [];
    this.waiting = [];
    this.error = null;
}
$2dae99500e9cba80$var$Pend.prototype.go = function(fn) {
    if (this.pending < this.max) $2dae99500e9cba80$var$pendGo(this, fn);
    else this.waiting.push(fn);
};
$2dae99500e9cba80$var$Pend.prototype.wait = function(cb) {
    if (this.pending === 0) cb(this.error);
    else this.listeners.push(cb);
};
$2dae99500e9cba80$var$Pend.prototype.hold = function() {
    return $2dae99500e9cba80$var$pendHold(this);
};
function $2dae99500e9cba80$var$pendHold(self) {
    self.pending += 1;
    var called = false;
    return onCb;
    function onCb(err) {
        if (called) throw new Error("callback called twice");
        called = true;
        self.error = self.error || err;
        self.pending -= 1;
        if (self.waiting.length > 0 && self.pending < self.max) $2dae99500e9cba80$var$pendGo(self, self.waiting.shift());
        else if (self.pending === 0) {
            var listeners = self.listeners;
            self.listeners = [];
            listeners.forEach(cbListener);
        }
    }
    function cbListener(listener) {
        listener(self.error);
    }
}
function $2dae99500e9cba80$var$pendGo(self, fn) {
    fn($2dae99500e9cba80$var$pendHold(self));
}



var $db8caba3e2b324f4$require$EventEmitter = $dAk3n$events.EventEmitter;
$db8caba3e2b324f4$export$2f2091512d4ea5d1 = $db8caba3e2b324f4$var$createFromBuffer;
$db8caba3e2b324f4$export$c1424497e0182b46 = $db8caba3e2b324f4$var$createFromFd;
$db8caba3e2b324f4$export$46ba22c707fcd454 = $db8caba3e2b324f4$var$BufferSlicer;
$db8caba3e2b324f4$export$fbcb7e4b44767f77 = $db8caba3e2b324f4$var$FdSlicer;
$dAk3n$util.inherits($db8caba3e2b324f4$var$FdSlicer, $db8caba3e2b324f4$require$EventEmitter);
function $db8caba3e2b324f4$var$FdSlicer(fd, options) {
    options = options || {};
    $db8caba3e2b324f4$require$EventEmitter.call(this);
    this.fd = fd;
    this.pend = new $2dae99500e9cba80$exports();
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options.autoClose;
}
$db8caba3e2b324f4$var$FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var self = this;
    self.pend.go(function(cb) {
        $dAk3n$fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
            cb();
            callback(err, bytesRead, buffer);
        });
    });
};
$db8caba3e2b324f4$var$FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    var self = this;
    self.pend.go(function(cb) {
        $dAk3n$fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
            cb();
            callback(err, written, buffer);
        });
    });
};
$db8caba3e2b324f4$var$FdSlicer.prototype.createReadStream = function(options) {
    return new $db8caba3e2b324f4$var$ReadStream(this, options);
};
$db8caba3e2b324f4$var$FdSlicer.prototype.createWriteStream = function(options) {
    return new $db8caba3e2b324f4$var$WriteStream(this, options);
};
$db8caba3e2b324f4$var$FdSlicer.prototype.ref = function() {
    this.refCount += 1;
};
$db8caba3e2b324f4$var$FdSlicer.prototype.unref = function() {
    var self = this;
    self.refCount -= 1;
    if (self.refCount > 0) return;
    if (self.refCount < 0) throw new Error("invalid unref");
    if (self.autoClose) $dAk3n$fs.close(self.fd, onCloseDone);
    function onCloseDone(err) {
        if (err) self.emit("error", err);
        else self.emit("close");
    }
};
$dAk3n$util.inherits($db8caba3e2b324f4$var$ReadStream, $db8caba3e2b324f4$var$Readable);
function $db8caba3e2b324f4$var$ReadStream(context, options) {
    options = options || {};
    $db8caba3e2b324f4$var$Readable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end;
    this.pos = this.start;
    this.destroyed = false;
}
$db8caba3e2b324f4$var$ReadStream.prototype._read = function(n) {
    var self = this;
    if (self.destroyed) return;
    var toRead = Math.min(self._readableState.highWaterMark, n);
    if (self.endOffset != null) toRead = Math.min(toRead, self.endOffset - self.pos);
    if (toRead <= 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
        return;
    }
    self.context.pend.go(function(cb) {
        if (self.destroyed) return cb();
        var buffer = new Buffer(toRead);
        $dAk3n$fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
            if (err) self.destroy(err);
            else if (bytesRead === 0) {
                self.destroyed = true;
                self.push(null);
                self.context.unref();
            } else {
                self.pos += bytesRead;
                self.push(buffer.slice(0, bytesRead));
            }
            cb();
        });
    });
};
$db8caba3e2b324f4$var$ReadStream.prototype.destroy = function(err) {
    if (this.destroyed) return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit("error", err);
    this.context.unref();
};
$dAk3n$util.inherits($db8caba3e2b324f4$var$WriteStream, $db8caba3e2b324f4$var$Writable);
function $db8caba3e2b324f4$var$WriteStream(context, options) {
    options = options || {};
    $db8caba3e2b324f4$var$Writable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end == null ? Infinity : +options.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
}
$db8caba3e2b324f4$var$WriteStream.prototype._write = function(buffer, encoding, callback) {
    var self = this;
    if (self.destroyed) return;
    if (self.pos + buffer.length > self.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self.destroy();
        callback(err);
        return;
    }
    self.context.pend.go(function(cb) {
        if (self.destroyed) return cb();
        $dAk3n$fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
            if (err) {
                self.destroy();
                cb();
                callback(err);
            } else {
                self.bytesWritten += bytes;
                self.pos += bytes;
                self.emit("progress");
                cb();
                callback();
            }
        });
    });
};
$db8caba3e2b324f4$var$WriteStream.prototype.destroy = function() {
    if (this.destroyed) return;
    this.destroyed = true;
    this.context.unref();
};
$dAk3n$util.inherits($db8caba3e2b324f4$var$BufferSlicer, $db8caba3e2b324f4$require$EventEmitter);
function $db8caba3e2b324f4$var$BufferSlicer(buffer, options) {
    $db8caba3e2b324f4$require$EventEmitter.call(this);
    options = options || {};
    this.refCount = 0;
    this.buffer = buffer;
    this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}
$db8caba3e2b324f4$var$BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var end = position + length;
    var delta = end - this.buffer.length;
    var written = delta > 0 ? delta : length;
    this.buffer.copy(buffer, offset, position, end);
    setImmediate(function() {
        callback(null, written);
    });
};
$db8caba3e2b324f4$var$BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    buffer.copy(this.buffer, position, offset, offset + length);
    setImmediate(function() {
        callback(null, length, buffer);
    });
};
$db8caba3e2b324f4$var$BufferSlicer.prototype.createReadStream = function(options) {
    options = options || {};
    var readStream = new $db8caba3e2b324f4$var$PassThrough(options);
    readStream.destroyed = false;
    readStream.start = options.start || 0;
    readStream.endOffset = options.end;
    // by the time this function returns, we'll be done.
    readStream.pos = readStream.endOffset || this.buffer.length;
    // respect the maxChunkSize option to slice up the chunk into smaller pieces.
    var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
    var offset = 0;
    while(true){
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
            // last chunk
            if (offset < entireSlice.length) readStream.write(entireSlice.slice(offset, entireSlice.length));
            break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
    }
    readStream.end();
    readStream.destroy = function() {
        readStream.destroyed = true;
    };
    return readStream;
};
$db8caba3e2b324f4$var$BufferSlicer.prototype.createWriteStream = function(options) {
    var bufferSlicer = this;
    options = options || {};
    var writeStream = new $db8caba3e2b324f4$var$Writable(options);
    writeStream.start = options.start || 0;
    writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed) return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
            var err = new Error("maximum file length exceeded");
            err.code = "ETOOBIG";
            writeStream.destroyed = true;
            callback(err);
            return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
    };
    writeStream.destroy = function() {
        writeStream.destroyed = true;
    };
    return writeStream;
};
$db8caba3e2b324f4$var$BufferSlicer.prototype.ref = function() {
    this.refCount += 1;
};
$db8caba3e2b324f4$var$BufferSlicer.prototype.unref = function() {
    this.refCount -= 1;
    if (this.refCount < 0) throw new Error("invalid unref");
};
function $db8caba3e2b324f4$var$createFromBuffer(buffer, options) {
    return new $db8caba3e2b324f4$var$BufferSlicer(buffer, options);
}
function $db8caba3e2b324f4$var$createFromFd(fd, options) {
    return new $db8caba3e2b324f4$var$FdSlicer(fd, options);
}


var $d404c79038731994$exports = {};

var $d404c79038731994$require$Buffer = $dAk3n$buffer.Buffer;
var $d404c79038731994$var$CRC_TABLE = [
    0x00000000,
    0x77073096,
    0xee0e612c,
    0x990951ba,
    0x076dc419,
    0x706af48f,
    0xe963a535,
    0x9e6495a3,
    0x0edb8832,
    0x79dcb8a4,
    0xe0d5e91e,
    0x97d2d988,
    0x09b64c2b,
    0x7eb17cbd,
    0xe7b82d07,
    0x90bf1d91,
    0x1db71064,
    0x6ab020f2,
    0xf3b97148,
    0x84be41de,
    0x1adad47d,
    0x6ddde4eb,
    0xf4d4b551,
    0x83d385c7,
    0x136c9856,
    0x646ba8c0,
    0xfd62f97a,
    0x8a65c9ec,
    0x14015c4f,
    0x63066cd9,
    0xfa0f3d63,
    0x8d080df5,
    0x3b6e20c8,
    0x4c69105e,
    0xd56041e4,
    0xa2677172,
    0x3c03e4d1,
    0x4b04d447,
    0xd20d85fd,
    0xa50ab56b,
    0x35b5a8fa,
    0x42b2986c,
    0xdbbbc9d6,
    0xacbcf940,
    0x32d86ce3,
    0x45df5c75,
    0xdcd60dcf,
    0xabd13d59,
    0x26d930ac,
    0x51de003a,
    0xc8d75180,
    0xbfd06116,
    0x21b4f4b5,
    0x56b3c423,
    0xcfba9599,
    0xb8bda50f,
    0x2802b89e,
    0x5f058808,
    0xc60cd9b2,
    0xb10be924,
    0x2f6f7c87,
    0x58684c11,
    0xc1611dab,
    0xb6662d3d,
    0x76dc4190,
    0x01db7106,
    0x98d220bc,
    0xefd5102a,
    0x71b18589,
    0x06b6b51f,
    0x9fbfe4a5,
    0xe8b8d433,
    0x7807c9a2,
    0x0f00f934,
    0x9609a88e,
    0xe10e9818,
    0x7f6a0dbb,
    0x086d3d2d,
    0x91646c97,
    0xe6635c01,
    0x6b6b51f4,
    0x1c6c6162,
    0x856530d8,
    0xf262004e,
    0x6c0695ed,
    0x1b01a57b,
    0x8208f4c1,
    0xf50fc457,
    0x65b0d9c6,
    0x12b7e950,
    0x8bbeb8ea,
    0xfcb9887c,
    0x62dd1ddf,
    0x15da2d49,
    0x8cd37cf3,
    0xfbd44c65,
    0x4db26158,
    0x3ab551ce,
    0xa3bc0074,
    0xd4bb30e2,
    0x4adfa541,
    0x3dd895d7,
    0xa4d1c46d,
    0xd3d6f4fb,
    0x4369e96a,
    0x346ed9fc,
    0xad678846,
    0xda60b8d0,
    0x44042d73,
    0x33031de5,
    0xaa0a4c5f,
    0xdd0d7cc9,
    0x5005713c,
    0x270241aa,
    0xbe0b1010,
    0xc90c2086,
    0x5768b525,
    0x206f85b3,
    0xb966d409,
    0xce61e49f,
    0x5edef90e,
    0x29d9c998,
    0xb0d09822,
    0xc7d7a8b4,
    0x59b33d17,
    0x2eb40d81,
    0xb7bd5c3b,
    0xc0ba6cad,
    0xedb88320,
    0x9abfb3b6,
    0x03b6e20c,
    0x74b1d29a,
    0xead54739,
    0x9dd277af,
    0x04db2615,
    0x73dc1683,
    0xe3630b12,
    0x94643b84,
    0x0d6d6a3e,
    0x7a6a5aa8,
    0xe40ecf0b,
    0x9309ff9d,
    0x0a00ae27,
    0x7d079eb1,
    0xf00f9344,
    0x8708a3d2,
    0x1e01f268,
    0x6906c2fe,
    0xf762575d,
    0x806567cb,
    0x196c3671,
    0x6e6b06e7,
    0xfed41b76,
    0x89d32be0,
    0x10da7a5a,
    0x67dd4acc,
    0xf9b9df6f,
    0x8ebeeff9,
    0x17b7be43,
    0x60b08ed5,
    0xd6d6a3e8,
    0xa1d1937e,
    0x38d8c2c4,
    0x4fdff252,
    0xd1bb67f1,
    0xa6bc5767,
    0x3fb506dd,
    0x48b2364b,
    0xd80d2bda,
    0xaf0a1b4c,
    0x36034af6,
    0x41047a60,
    0xdf60efc3,
    0xa867df55,
    0x316e8eef,
    0x4669be79,
    0xcb61b38c,
    0xbc66831a,
    0x256fd2a0,
    0x5268e236,
    0xcc0c7795,
    0xbb0b4703,
    0x220216b9,
    0x5505262f,
    0xc5ba3bbe,
    0xb2bd0b28,
    0x2bb45a92,
    0x5cb36a04,
    0xc2d7ffa7,
    0xb5d0cf31,
    0x2cd99e8b,
    0x5bdeae1d,
    0x9b64c2b0,
    0xec63f226,
    0x756aa39c,
    0x026d930a,
    0x9c0906a9,
    0xeb0e363f,
    0x72076785,
    0x05005713,
    0x95bf4a82,
    0xe2b87a14,
    0x7bb12bae,
    0x0cb61b38,
    0x92d28e9b,
    0xe5d5be0d,
    0x7cdcefb7,
    0x0bdbdf21,
    0x86d3d2d4,
    0xf1d4e242,
    0x68ddb3f8,
    0x1fda836e,
    0x81be16cd,
    0xf6b9265b,
    0x6fb077e1,
    0x18b74777,
    0x88085ae6,
    0xff0f6a70,
    0x66063bca,
    0x11010b5c,
    0x8f659eff,
    0xf862ae69,
    0x616bffd3,
    0x166ccf45,
    0xa00ae278,
    0xd70dd2ee,
    0x4e048354,
    0x3903b3c2,
    0xa7672661,
    0xd06016f7,
    0x4969474d,
    0x3e6e77db,
    0xaed16a4a,
    0xd9d65adc,
    0x40df0b66,
    0x37d83bf0,
    0xa9bcae53,
    0xdebb9ec5,
    0x47b2cf7f,
    0x30b5ffe9,
    0xbdbdf21c,
    0xcabac28a,
    0x53b39330,
    0x24b4a3a6,
    0xbad03605,
    0xcdd70693,
    0x54de5729,
    0x23d967bf,
    0xb3667a2e,
    0xc4614ab8,
    0x5d681b02,
    0x2a6f2b94,
    0xb40bbe37,
    0xc30c8ea1,
    0x5a05df1b,
    0x2d02ef8d
];
if (typeof Int32Array !== "undefined") $d404c79038731994$var$CRC_TABLE = new Int32Array($d404c79038731994$var$CRC_TABLE);
function $d404c79038731994$var$ensureBuffer(input) {
    if ($d404c79038731994$require$Buffer.isBuffer(input)) return input;
    var hasNewBufferAPI = typeof $d404c79038731994$require$Buffer.alloc === "function" && typeof $d404c79038731994$require$Buffer.from === "function";
    if (typeof input === "number") return hasNewBufferAPI ? $d404c79038731994$require$Buffer.alloc(input) : new $d404c79038731994$require$Buffer(input);
    else if (typeof input === "string") return hasNewBufferAPI ? $d404c79038731994$require$Buffer.from(input) : new $d404c79038731994$require$Buffer(input);
    else throw new Error("input must be buffer, number, or string, received " + typeof input);
}
function $d404c79038731994$var$bufferizeInt(num) {
    var tmp = $d404c79038731994$var$ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
}
function $d404c79038731994$var$_crc32(buf, previous) {
    buf = $d404c79038731994$var$ensureBuffer(buf);
    if ($d404c79038731994$require$Buffer.isBuffer(previous)) previous = previous.readUInt32BE(0);
    var crc = ~~previous ^ -1;
    for(var n = 0; n < buf.length; n++)crc = $d404c79038731994$var$CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ crc >>> 8;
    return crc ^ -1;
}
function $d404c79038731994$var$crc32() {
    return $d404c79038731994$var$bufferizeInt($d404c79038731994$var$_crc32.apply(null, arguments));
}
$d404c79038731994$var$crc32.signed = function() {
    return $d404c79038731994$var$_crc32.apply(null, arguments);
};
$d404c79038731994$var$crc32.unsigned = function() {
    return $d404c79038731994$var$_crc32.apply(null, arguments) >>> 0;
};
$d404c79038731994$exports = $d404c79038731994$var$crc32;




var $9327dbea45d806c8$require$EventEmitter = $dAk3n$events.EventEmitter;

var $9327dbea45d806c8$require$Transform = $dAk3n$stream.Transform;

var $9327dbea45d806c8$require$PassThrough = $dAk3n$stream.PassThrough;

var $9327dbea45d806c8$require$Writable = $dAk3n$stream.Writable;
$9327dbea45d806c8$export$3ce6949f20cea765 = $9327dbea45d806c8$var$open;
$9327dbea45d806c8$export$e74adcc69ca6d332 = $9327dbea45d806c8$var$fromFd;
$9327dbea45d806c8$export$d573cdcf1a515b2 = $9327dbea45d806c8$var$fromBuffer;
$9327dbea45d806c8$export$2743bcf0109a5529 = $9327dbea45d806c8$var$fromRandomAccessReader;
$9327dbea45d806c8$export$9f59f5eb9355b723 = $9327dbea45d806c8$var$dosDateTimeToDate;
$9327dbea45d806c8$export$74cd253e69ae5d6 = $9327dbea45d806c8$var$validateFileName;
$9327dbea45d806c8$export$361a87d8d0c7288a = $9327dbea45d806c8$var$ZipFile;
$9327dbea45d806c8$export$3bb977b3ba9d3b59 = $9327dbea45d806c8$var$Entry;
$9327dbea45d806c8$export$20e0d31d48ad8a6 = $9327dbea45d806c8$var$RandomAccessReader;
function $9327dbea45d806c8$var$open(path, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    if (options.autoClose == null) options.autoClose = true;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    if (callback == null) callback = $9327dbea45d806c8$var$defaultCallback;
    $dAk3n$fs.open(path, "r", function(err, fd) {
        if (err) return callback(err);
        $9327dbea45d806c8$var$fromFd(fd, options, function(err, zipfile) {
            if (err) $dAk3n$fs.close(fd, $9327dbea45d806c8$var$defaultCallback);
            callback(err, zipfile);
        });
    });
}
function $9327dbea45d806c8$var$fromFd(fd, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    if (options.autoClose == null) options.autoClose = false;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    if (callback == null) callback = $9327dbea45d806c8$var$defaultCallback;
    $dAk3n$fs.fstat(fd, function(err, stats) {
        if (err) return callback(err);
        var reader = $db8caba3e2b324f4$export$c1424497e0182b46(fd, {
            autoClose: true
        });
        $9327dbea45d806c8$var$fromRandomAccessReader(reader, stats.size, options, callback);
    });
}
function $9327dbea45d806c8$var$fromBuffer(buffer, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    options.autoClose = false;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
    var reader = $db8caba3e2b324f4$export$2f2091512d4ea5d1(buffer, {
        maxChunkSize: 0x10000
    });
    $9327dbea45d806c8$var$fromRandomAccessReader(reader, buffer.length, options, callback);
}
function $9327dbea45d806c8$var$fromRandomAccessReader(reader, totalSize, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (options == null) options = {};
    if (options.autoClose == null) options.autoClose = true;
    if (options.lazyEntries == null) options.lazyEntries = false;
    if (options.decodeStrings == null) options.decodeStrings = true;
    var decodeStrings = !!options.decodeStrings;
    if (options.validateEntrySizes == null) options.validateEntrySizes = true;
    if (options.strictFileNames == null) options.strictFileNames = false;
    if (callback == null) callback = $9327dbea45d806c8$var$defaultCallback;
    if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
    if (totalSize > Number.MAX_SAFE_INTEGER) throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
    // the matching unref() call is in zipfile.close()
    reader.ref();
    // eocdr means End of Central Directory Record.
    // search backwards for the eocdr signature.
    // the last field of the eocdr is a variable-length comment.
    // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
    // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
    // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
    var eocdrWithoutCommentSize = 22;
    var maxCommentSize = 0xffff; // 2-byte size
    var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
    var buffer = $9327dbea45d806c8$var$newBuffer(bufferSize);
    var bufferReadStart = totalSize - buffer.length;
    $9327dbea45d806c8$var$readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err) return callback(err);
        for(var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1){
            if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
            // found eocdr
            var eocdrBuffer = buffer.slice(i);
            // 0 - End of central directory signature = 0x06054b50
            // 4 - Number of this disk
            var diskNumber = eocdrBuffer.readUInt16LE(4);
            if (diskNumber !== 0) return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
            // 6 - Disk where central directory starts
            // 8 - Number of central directory records on this disk
            // 10 - Total number of central directory records
            var entryCount = eocdrBuffer.readUInt16LE(10);
            // 12 - Size of central directory (bytes)
            // 16 - Offset of start of central directory, relative to start of archive
            var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
            // 20 - Comment length
            var commentLength = eocdrBuffer.readUInt16LE(20);
            var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
            if (commentLength !== expectedCommentLength) return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
            // 22 - Comment
            // the encoding is always cp437.
            var comment = decodeStrings ? $9327dbea45d806c8$var$decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
            if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) return callback(null, new $9327dbea45d806c8$var$ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            // ZIP64 format
            // ZIP64 Zip64 end of central directory locator
            var zip64EocdlBuffer = $9327dbea45d806c8$var$newBuffer(20);
            var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
            $9327dbea45d806c8$var$readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
                if (err) return callback(err);
                // 0 - zip64 end of central dir locator signature = 0x07064b50
                if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) return callback(new Error("invalid zip64 end of central directory locator signature"));
                // 4 - number of the disk with the start of the zip64 end of central directory
                // 8 - relative offset of the zip64 end of central directory record
                var zip64EocdrOffset = $9327dbea45d806c8$var$readUInt64LE(zip64EocdlBuffer, 8);
                // 16 - total number of disks
                // ZIP64 end of central directory record
                var zip64EocdrBuffer = $9327dbea45d806c8$var$newBuffer(56);
                $9327dbea45d806c8$var$readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
                    if (err) return callback(err);
                    // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
                    if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) return callback(new Error("invalid zip64 end of central directory record signature"));
                    // 4 - size of zip64 end of central directory record                8 bytes
                    // 12 - version made by                                             2 bytes
                    // 14 - version needed to extract                                   2 bytes
                    // 16 - number of this disk                                         4 bytes
                    // 20 - number of the disk with the start of the central directory  4 bytes
                    // 24 - total number of entries in the central directory on this disk         8 bytes
                    // 32 - total number of entries in the central directory            8 bytes
                    entryCount = $9327dbea45d806c8$var$readUInt64LE(zip64EocdrBuffer, 32);
                    // 40 - size of the central directory                               8 bytes
                    // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
                    centralDirectoryOffset = $9327dbea45d806c8$var$readUInt64LE(zip64EocdrBuffer, 48);
                    // 56 - zip64 extensible data sector                                (variable size)
                    return callback(null, new $9327dbea45d806c8$var$ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
                });
            });
            return;
        }
        callback(new Error("end of central directory record signature not found"));
    });
}
$dAk3n$util.inherits($9327dbea45d806c8$var$ZipFile, $9327dbea45d806c8$require$EventEmitter);
function $9327dbea45d806c8$var$ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
    var self = this;
    $9327dbea45d806c8$require$EventEmitter.call(self);
    self.reader = reader;
    // forward close events
    self.reader.on("error", function(err) {
        // error closing the fd
        $9327dbea45d806c8$var$emitError(self, err);
    });
    self.reader.once("close", function() {
        self.emit("close");
    });
    self.readEntryCursor = centralDirectoryOffset;
    self.fileSize = fileSize;
    self.entryCount = entryCount;
    self.comment = comment;
    self.entriesRead = 0;
    self.autoClose = !!autoClose;
    self.lazyEntries = !!lazyEntries;
    self.decodeStrings = !!decodeStrings;
    self.validateEntrySizes = !!validateEntrySizes;
    self.strictFileNames = !!strictFileNames;
    self.isOpen = true;
    self.emittedError = false;
    if (!self.lazyEntries) self._readEntry();
}
$9327dbea45d806c8$var$ZipFile.prototype.close = function() {
    if (!this.isOpen) return;
    this.isOpen = false;
    this.reader.unref();
};
function $9327dbea45d806c8$var$emitErrorAndAutoClose(self, err) {
    if (self.autoClose) self.close();
    $9327dbea45d806c8$var$emitError(self, err);
}
function $9327dbea45d806c8$var$emitError(self, err) {
    if (self.emittedError) return;
    self.emittedError = true;
    self.emit("error", err);
}
$9327dbea45d806c8$var$ZipFile.prototype.readEntry = function() {
    if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
    this._readEntry();
};
$9327dbea45d806c8$var$ZipFile.prototype._readEntry = function() {
    var self = this;
    if (self.entryCount === self.entriesRead) {
        // done with metadata
        setImmediate(function() {
            if (self.autoClose) self.close();
            if (self.emittedError) return;
            self.emit("end");
        });
        return;
    }
    if (self.emittedError) return;
    var buffer = $9327dbea45d806c8$var$newBuffer(46);
    $9327dbea45d806c8$var$readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
        if (err) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, err);
        if (self.emittedError) return;
        var entry = new $9327dbea45d806c8$var$Entry();
        // 0 - Central directory file header signature
        var signature = buffer.readUInt32LE(0);
        if (signature !== 0x02014b50) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        // 4 - Version made by
        entry.versionMadeBy = buffer.readUInt16LE(4);
        // 6 - Version needed to extract (minimum)
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        // 8 - General purpose bit flag
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        // 10 - Compression method
        entry.compressionMethod = buffer.readUInt16LE(10);
        // 12 - File last modification time
        entry.lastModFileTime = buffer.readUInt16LE(12);
        // 14 - File last modification date
        entry.lastModFileDate = buffer.readUInt16LE(14);
        // 16 - CRC-32
        entry.crc32 = buffer.readUInt32LE(16);
        // 20 - Compressed size
        entry.compressedSize = buffer.readUInt32LE(20);
        // 24 - Uncompressed size
        entry.uncompressedSize = buffer.readUInt32LE(24);
        // 28 - File name length (n)
        entry.fileNameLength = buffer.readUInt16LE(28);
        // 30 - Extra field length (m)
        entry.extraFieldLength = buffer.readUInt16LE(30);
        // 32 - File comment length (k)
        entry.fileCommentLength = buffer.readUInt16LE(32);
        // 34 - Disk number where file starts
        // 36 - Internal file attributes
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        // 38 - External file attributes
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        // 42 - Relative offset of local file header
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 0x40) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));
        self.readEntryCursor += 46;
        buffer = $9327dbea45d806c8$var$newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        $9327dbea45d806c8$var$readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
            if (err) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, err);
            if (self.emittedError) return;
            // 46 - File name
            var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
            entry.fileName = self.decodeStrings ? $9327dbea45d806c8$var$decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
            // 46+n - Extra field
            var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
            var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
            entry.extraFields = [];
            var i = 0;
            while(i < extraFieldBuffer.length - 3){
                var headerId = extraFieldBuffer.readUInt16LE(i + 0);
                var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
                var dataStart = i + 4;
                var dataEnd = dataStart + dataSize;
                if (dataEnd > extraFieldBuffer.length) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
                var dataBuffer = $9327dbea45d806c8$var$newBuffer(dataSize);
                extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
                entry.extraFields.push({
                    id: headerId,
                    data: dataBuffer
                });
                i = dataEnd;
            }
            // 46+n+m - File comment
            entry.fileComment = self.decodeStrings ? $9327dbea45d806c8$var$decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
            // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
            entry.comment = entry.fileComment;
            self.readEntryCursor += buffer.length;
            self.entriesRead += 1;
            if (entry.uncompressedSize === 0xffffffff || entry.compressedSize === 0xffffffff || entry.relativeOffsetOfLocalHeader === 0xffffffff) {
                // ZIP64 format
                // find the Zip64 Extended Information Extra Field
                var zip64EiefBuffer = null;
                for(var i = 0; i < entry.extraFields.length; i++){
                    var extraField = entry.extraFields[i];
                    if (extraField.id === 0x0001) {
                        zip64EiefBuffer = extraField.data;
                        break;
                    }
                }
                if (zip64EiefBuffer == null) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
                var index = 0;
                // 0 - Original Size          8 bytes
                if (entry.uncompressedSize === 0xffffffff) {
                    if (index + 8 > zip64EiefBuffer.length) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
                    entry.uncompressedSize = $9327dbea45d806c8$var$readUInt64LE(zip64EiefBuffer, index);
                    index += 8;
                }
                // 8 - Compressed Size        8 bytes
                if (entry.compressedSize === 0xffffffff) {
                    if (index + 8 > zip64EiefBuffer.length) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
                    entry.compressedSize = $9327dbea45d806c8$var$readUInt64LE(zip64EiefBuffer, index);
                    index += 8;
                }
                // 16 - Relative Header Offset 8 bytes
                if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
                    if (index + 8 > zip64EiefBuffer.length) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
                    entry.relativeOffsetOfLocalHeader = $9327dbea45d806c8$var$readUInt64LE(zip64EiefBuffer, index);
                    index += 8;
                }
            // 24 - Disk Start Number      4 bytes
            }
            // check for Info-ZIP Unicode Path Extra Field (0x7075)
            // see https://github.com/thejoshwolfe/yauzl/issues/33
            if (self.decodeStrings) for(var i = 0; i < entry.extraFields.length; i++){
                var extraField = entry.extraFields[i];
                if (extraField.id === 0x7075) {
                    if (extraField.data.length < 6) continue;
                    // Version       1 byte      version of this extra field, currently 1
                    if (extraField.data.readUInt8(0) !== 1) continue;
                    // NameCRC32     4 bytes     File Name Field CRC32 Checksum
                    var oldNameCrc32 = extraField.data.readUInt32LE(1);
                    if ($d404c79038731994$exports.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) continue;
                    // UnicodeName   Variable    UTF-8 version of the entry File Name
                    entry.fileName = $9327dbea45d806c8$var$decodeBuffer(extraField.data, 5, extraField.data.length, true);
                    break;
                }
            }
            // validate file size
            if (self.validateEntrySizes && entry.compressionMethod === 0) {
                var expectedCompressedSize = entry.uncompressedSize;
                if (entry.isEncrypted()) // traditional encryption prefixes the file data with a header
                expectedCompressedSize += 12;
                if (entry.compressedSize !== expectedCompressedSize) {
                    var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
                    return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error(msg));
                }
            }
            if (self.decodeStrings) {
                if (!self.strictFileNames) // allow backslash
                entry.fileName = entry.fileName.replace(/\\/g, "/");
                var errorMessage = $9327dbea45d806c8$var$validateFileName(entry.fileName, self.validateFileNameOptions);
                if (errorMessage != null) return $9327dbea45d806c8$var$emitErrorAndAutoClose(self, new Error(errorMessage));
            }
            self.emit("entry", entry);
            if (!self.lazyEntries) self._readEntry();
        });
    });
};
$9327dbea45d806c8$var$ZipFile.prototype.openReadStream = function(entry, options, callback) {
    var self = this;
    // parameter validation
    var relativeStart = 0;
    var relativeEnd = entry.compressedSize;
    if (callback == null) {
        callback = options;
        options = {};
    } else {
        // validate options that the caller has no excuse to get wrong
        if (options.decrypt != null) {
            if (!entry.isEncrypted()) throw new Error("options.decrypt can only be specified for encrypted entries");
            if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
            if (entry.isCompressed()) {
                if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
            }
        }
        if (options.decompress != null) {
            if (!entry.isCompressed()) throw new Error("options.decompress can only be specified for compressed entries");
            if (!(options.decompress === false || options.decompress === true)) throw new Error("invalid options.decompress value: " + options.decompress);
        }
        if (options.start != null || options.end != null) {
            if (entry.isCompressed() && options.decompress !== false) throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
            if (entry.isEncrypted() && options.decrypt !== false) throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
        }
        if (options.start != null) {
            relativeStart = options.start;
            if (relativeStart < 0) throw new Error("options.start < 0");
            if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
            relativeEnd = options.end;
            if (relativeEnd < 0) throw new Error("options.end < 0");
            if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
            if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
        }
    }
    // any further errors can either be caused by the zipfile,
    // or were introduced in a minor version of yauzl,
    // so should be passed to the client rather than thrown.
    if (!self.isOpen) return callback(new Error("closed"));
    if (entry.isEncrypted()) {
        if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
    }
    // make sure we don't lose the fd before we open the actual read stream
    self.reader.ref();
    var buffer = $9327dbea45d806c8$var$newBuffer(30);
    $9327dbea45d806c8$var$readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
            if (err) return callback(err);
            // 0 - Local file header signature = 0x04034b50
            var signature = buffer.readUInt32LE(0);
            if (signature !== 0x04034b50) return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
            // all this should be redundant
            // 4 - Version needed to extract (minimum)
            // 6 - General purpose bit flag
            // 8 - Compression method
            // 10 - File last modification time
            // 12 - File last modification date
            // 14 - CRC-32
            // 18 - Compressed size
            // 22 - Uncompressed size
            // 26 - File name length (n)
            var fileNameLength = buffer.readUInt16LE(26);
            // 28 - Extra field length (m)
            var extraFieldLength = buffer.readUInt16LE(28);
            // 30 - File name
            // 30+n - Extra field
            var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
            var decompress;
            if (entry.compressionMethod === 0) // 0 - The file is stored (no compression)
            decompress = false;
            else if (entry.compressionMethod === 8) // 8 - The file is Deflated
            decompress = options.decompress != null ? options.decompress : true;
            else return callback(new Error("unsupported compression method: " + entry.compressionMethod));
            var fileDataStart = localFileHeaderEnd;
            var fileDataEnd = fileDataStart + entry.compressedSize;
            if (entry.compressedSize !== 0) {
                // bounds check now, because the read streams will probably not complain loud enough.
                // since we're dealing with an unsigned offset plus an unsigned size,
                // we only have 1 thing to check for.
                if (fileDataEnd > self.fileSize) return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
            }
            var readStream = self.reader.createReadStream({
                start: fileDataStart + relativeStart,
                end: fileDataStart + relativeEnd
            });
            var endpointStream = readStream;
            if (decompress) {
                var destroyed = false;
                var inflateFilter = $dAk3n$zlib.createInflateRaw();
                readStream.on("error", function(err) {
                    // setImmediate here because errors can be emitted during the first call to pipe()
                    setImmediate(function() {
                        if (!destroyed) inflateFilter.emit("error", err);
                    });
                });
                readStream.pipe(inflateFilter);
                if (self.validateEntrySizes) {
                    endpointStream = new $9327dbea45d806c8$var$AssertByteCountStream(entry.uncompressedSize);
                    inflateFilter.on("error", function(err) {
                        // forward zlib errors to the client-visible stream
                        setImmediate(function() {
                            if (!destroyed) endpointStream.emit("error", err);
                        });
                    });
                    inflateFilter.pipe(endpointStream);
                } else // the zlib filter is the client-visible stream
                endpointStream = inflateFilter;
                // this is part of yauzl's API, so implement this function on the client-visible stream
                endpointStream.destroy = function() {
                    destroyed = true;
                    if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
                    readStream.unpipe(inflateFilter);
                    // TODO: the inflateFilter may cause a memory leak. see Issue #27.
                    readStream.destroy();
                };
            }
            callback(null, endpointStream);
        } finally{
            self.reader.unref();
        }
    });
};
function $9327dbea45d806c8$var$Entry() {}
$9327dbea45d806c8$var$Entry.prototype.getLastModDate = function() {
    return $9327dbea45d806c8$var$dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
$9327dbea45d806c8$var$Entry.prototype.isEncrypted = function() {
    return (this.generalPurposeBitFlag & 0x1) !== 0;
};
$9327dbea45d806c8$var$Entry.prototype.isCompressed = function() {
    return this.compressionMethod === 8;
};
function $9327dbea45d806c8$var$dosDateTimeToDate(date, time) {
    var day = date & 0x1f; // 1-31
    var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
    var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108
    var millisecond = 0;
    var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
    var minute = time >> 5 & 0x3f; // 0-59
    var hour = time >> 11 & 0x1f; // 0-23
    return new Date(year, month, day, hour, minute, second, millisecond);
}
function $9327dbea45d806c8$var$validateFileName(fileName) {
    if (fileName.indexOf("\\") !== -1) return "invalid characters in fileName: " + fileName;
    if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) return "absolute path: " + fileName;
    if (fileName.split("/").indexOf("..") !== -1) return "invalid relative path: " + fileName;
    // all good
    return null;
}
function $9327dbea45d806c8$var$readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
    if (length === 0) // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
    return setImmediate(function() {
        callback(null, $9327dbea45d806c8$var$newBuffer(0));
    });
    reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err) return callback(err);
        if (bytesRead < length) return callback(new Error("unexpected EOF"));
        callback();
    });
}
$dAk3n$util.inherits($9327dbea45d806c8$var$AssertByteCountStream, $9327dbea45d806c8$require$Transform);
function $9327dbea45d806c8$var$AssertByteCountStream(byteCount) {
    $9327dbea45d806c8$require$Transform.call(this);
    this.actualByteCount = 0;
    this.expectedByteCount = byteCount;
}
$9327dbea45d806c8$var$AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
    this.actualByteCount += chunk.length;
    if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
    }
    cb(null, chunk);
};
$9327dbea45d806c8$var$AssertByteCountStream.prototype._flush = function(cb) {
    if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
    }
    cb();
};
$dAk3n$util.inherits($9327dbea45d806c8$var$RandomAccessReader, $9327dbea45d806c8$require$EventEmitter);
function $9327dbea45d806c8$var$RandomAccessReader() {
    $9327dbea45d806c8$require$EventEmitter.call(this);
    this.refCount = 0;
}
$9327dbea45d806c8$var$RandomAccessReader.prototype.ref = function() {
    this.refCount += 1;
};
$9327dbea45d806c8$var$RandomAccessReader.prototype.unref = function() {
    var self = this;
    self.refCount -= 1;
    if (self.refCount > 0) return;
    if (self.refCount < 0) throw new Error("invalid unref");
    self.close(onCloseDone);
    function onCloseDone(err) {
        if (err) return self.emit("error", err);
        self.emit("close");
    }
};
$9327dbea45d806c8$var$RandomAccessReader.prototype.createReadStream = function(options) {
    var start = options.start;
    var end = options.end;
    if (start === end) {
        var emptyStream = new $9327dbea45d806c8$require$PassThrough();
        setImmediate(function() {
            emptyStream.end();
        });
        return emptyStream;
    }
    var stream = this._readStreamForRange(start, end);
    var destroyed = false;
    var refUnrefFilter = new $9327dbea45d806c8$var$RefUnrefFilter(this);
    stream.on("error", function(err) {
        setImmediate(function() {
            if (!destroyed) refUnrefFilter.emit("error", err);
        });
    });
    refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
    };
    var byteCounter = new $9327dbea45d806c8$var$AssertByteCountStream(end - start);
    refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
            if (!destroyed) byteCounter.emit("error", err);
        });
    });
    byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
    };
    return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
$9327dbea45d806c8$var$RandomAccessReader.prototype._readStreamForRange = function(start, end) {
    throw new Error("not implemented");
};
$9327dbea45d806c8$var$RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
    var readStream = this.createReadStream({
        start: position,
        end: position + length
    });
    var writeStream = new $9327dbea45d806c8$require$Writable();
    var written = 0;
    writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
    };
    writeStream.on("finish", callback);
    readStream.on("error", function(error) {
        callback(error);
    });
    readStream.pipe(writeStream);
};
$9327dbea45d806c8$var$RandomAccessReader.prototype.close = function(callback) {
    setImmediate(callback);
};
$dAk3n$util.inherits($9327dbea45d806c8$var$RefUnrefFilter, $9327dbea45d806c8$require$PassThrough);
function $9327dbea45d806c8$var$RefUnrefFilter(context) {
    $9327dbea45d806c8$require$PassThrough.call(this);
    this.context = context;
    this.context.ref();
    this.unreffedYet = false;
}
$9327dbea45d806c8$var$RefUnrefFilter.prototype._flush = function(cb) {
    this.unref();
    cb();
};
$9327dbea45d806c8$var$RefUnrefFilter.prototype.unref = function(cb) {
    if (this.unreffedYet) return;
    this.unreffedYet = true;
    this.context.unref();
};
var $9327dbea45d806c8$var$cp437 = "\x00☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼\xb6\xa7▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xef\xee\xec\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xf2\xfb\xf9\xff\xd6\xdc\xa2\xa3\xa5₧ƒ\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf⌐\xac\xbd\xbc\xa1\xab\xbb░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀α\xdfΓπΣσ\xb5τΦΘΩδ∞φε∩≡\xb1≥≤⌠⌡\xf7≈\xb0∙\xb7√ⁿ\xb2■\xa0";
function $9327dbea45d806c8$var$decodeBuffer(buffer, start, end, isUtf8) {
    if (isUtf8) return buffer.toString("utf8", start, end);
    else {
        var result = "";
        for(var i = start; i < end; i++)result += $9327dbea45d806c8$var$cp437[buffer[i]];
        return result;
    }
}
function $9327dbea45d806c8$var$readUInt64LE(buffer, offset) {
    // there is no native function for this, because we can't actually store 64-bit integers precisely.
    // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
    // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
    var lower32 = buffer.readUInt32LE(offset);
    var upper32 = buffer.readUInt32LE(offset + 4);
    // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
    return upper32 * 0x100000000 + lower32;
// as long as we're bounds checking the result of this function against the total file size,
// we'll catch any overflow errors, because we already made sure the total file size was within reason.
}
// Node 10 deprecated new Buffer().
var $9327dbea45d806c8$var$newBuffer;
if (typeof Buffer.allocUnsafe === "function") $9327dbea45d806c8$var$newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
};
else $9327dbea45d806c8$var$newBuffer = function(len) {
    return new Buffer(len);
};
function $9327dbea45d806c8$var$defaultCallback(err) {
    if (err) throw err;
}


const $2cde43dad30286f7$var$getType = (entry, mode)=>{
    const IFMT = 61440;
    const IFDIR = 16384;
    const IFLNK = 40960;
    const madeBy = entry.versionMadeBy >> 8;
    if ((mode & IFMT) === IFLNK) return "symlink";
    if ((mode & IFMT) === IFDIR || madeBy === 0 && entry.externalFileAttributes === 16) return "directory";
    return "file";
};
const $2cde43dad30286f7$var$extractEntry = (entry, zip)=>{
    const file = {
        mode: entry.externalFileAttributes >> 16 & 0xFFFF,
        mtime: entry.getLastModDate(),
        path: entry.fileName
    };
    file.type = $2cde43dad30286f7$var$getType(entry, file.mode);
    if (file.mode === 0 && file.type === "directory") file.mode = 493;
    if (file.mode === 0) file.mode = 420;
    return $1d7c960cf32ac643$exports(zip.openReadStream.bind(zip))(entry).then($cad08794b0acdd42$exports.buffer).then((buf)=>{
        file.data = buf;
        if (file.type === "symlink") file.linkname = buf.toString();
        return file;
    }).catch((err)=>{
        zip.close();
        throw err;
    });
};
const $2cde43dad30286f7$var$extractFile = (zip)=>new Promise((resolve, reject)=>{
        const files = [];
        zip.readEntry();
        zip.on("entry", (entry)=>{
            $2cde43dad30286f7$var$extractEntry(entry, zip).catch(reject).then((file)=>{
                files.push(file);
                zip.readEntry();
            });
        });
        zip.on("error", reject);
        zip.on("end", ()=>resolve(files));
    });
$2cde43dad30286f7$exports = ()=>(buf)=>{
        if (!Buffer.isBuffer(buf)) return Promise.reject(new TypeError(`Expected a Buffer, got ${typeof buf}`));
        if (!$819bbe6523f48390$exports(buf) || $819bbe6523f48390$exports(buf).ext !== "zip") return Promise.resolve([]);
        return $1d7c960cf32ac643$exports($9327dbea45d806c8$export$d573cdcf1a515b2)(buf, {
            lazyEntries: true
        }).then($2cde43dad30286f7$var$extractFile);
    };


var $efab8ab1a2100452$exports = {};
"use strict";


var $929c56e8db8c2877$exports = {};
"use strict";
const $929c56e8db8c2877$var$processFn = (fn, opts)=>function() {
        const P = opts.promiseModule;
        const args = new Array(arguments.length);
        for(let i = 0; i < arguments.length; i++)args[i] = arguments[i];
        return new P((resolve, reject)=>{
            if (opts.errorFirst) args.push(function(err, result) {
                if (opts.multiArgs) {
                    const results = new Array(arguments.length - 1);
                    for(let i = 1; i < arguments.length; i++)results[i - 1] = arguments[i];
                    if (err) {
                        results.unshift(err);
                        reject(results);
                    } else resolve(results);
                } else if (err) reject(err);
                else resolve(result);
            });
            else args.push(function(result) {
                if (opts.multiArgs) {
                    const results = new Array(arguments.length - 1);
                    for(let i = 0; i < arguments.length; i++)results[i] = arguments[i];
                    resolve(results);
                } else resolve(result);
            });
            fn.apply(this, args);
        });
    };
$929c56e8db8c2877$exports = (obj, opts)=>{
    opts = Object.assign({
        exclude: [
            /.+(Sync|Stream)$/
        ],
        errorFirst: true,
        promiseModule: Promise
    }, opts);
    const filter = (key)=>{
        const match = (pattern)=>typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    };
    let ret;
    if (typeof obj === "function") ret = function() {
        if (opts.excludeMain) return obj.apply(this, arguments);
        return $929c56e8db8c2877$var$processFn(obj, opts).apply(this, arguments);
    };
    else ret = Object.create(Object.getPrototypeOf(obj));
    for(const key in obj){
        const x = obj[key];
        ret[key] = typeof x === "function" && filter(key) ? $929c56e8db8c2877$var$processFn(x, opts) : x;
    }
    return ret;
};


const $efab8ab1a2100452$var$defaults = {
    mode: 511 & ~process.umask(),
    fs: $dAk3n$fs
};
// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const $efab8ab1a2100452$var$checkPath = (pth)=>{
    if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace($dAk3n$path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
            const err = new Error(`Path contains invalid characters: ${pth}`);
            err.code = "EINVAL";
            throw err;
        }
    }
};
$efab8ab1a2100452$exports = (input, opts)=>Promise.resolve().then(()=>{
        $efab8ab1a2100452$var$checkPath(input);
        opts = Object.assign({}, $efab8ab1a2100452$var$defaults, opts);
        const mkdir = $929c56e8db8c2877$exports(opts.fs.mkdir);
        const stat = $929c56e8db8c2877$exports(opts.fs.stat);
        const make = (pth)=>{
            return mkdir(pth, opts.mode).then(()=>pth).catch((err)=>{
                if (err.code === "ENOENT") {
                    if (err.message.includes("null bytes") || $dAk3n$path.dirname(pth) === pth) throw err;
                    return make($dAk3n$path.dirname(pth)).then(()=>make(pth));
                }
                return stat(pth).then((stats)=>stats.isDirectory() ? pth : Promise.reject()).catch(()=>{
                    throw err;
                });
            });
        };
        return make($dAk3n$path.resolve(input));
    });
$efab8ab1a2100452$exports.sync = (input, opts)=>{
    $efab8ab1a2100452$var$checkPath(input);
    opts = Object.assign({}, $efab8ab1a2100452$var$defaults, opts);
    const make = (pth)=>{
        try {
            opts.fs.mkdirSync(pth, opts.mode);
        } catch (err) {
            if (err.code === "ENOENT") {
                if (err.message.includes("null bytes") || $dAk3n$path.dirname(pth) === pth) throw err;
                make($dAk3n$path.dirname(pth));
                return make(pth);
            }
            try {
                if (!opts.fs.statSync(pth).isDirectory()) throw new Error("The path is not a directory");
            } catch (_) {
                throw err;
            }
        }
        return pth;
    };
    return make($dAk3n$path.resolve(input));
};



var $7c1fa217b3cf3727$exports = {};
/*!
 * strip-dirs | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/node-strip-dirs
*/ "use strict";


var $bac092103a64be70$exports = {};
/*!
 * is-natural-number.js | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/is-natural-number.js
*/ "use strict";
$bac092103a64be70$exports = function isNaturalNumber(val, option) {
    if (option) {
        if (typeof option !== "object") throw new TypeError(String(option) + " is not an object. Expected an object that has boolean `includeZero` property.");
        if ("includeZero" in option) {
            if (typeof option.includeZero !== "boolean") throw new TypeError(String(option.includeZero) + " is neither true nor false. `includeZero` option must be a Boolean value.");
            if (option.includeZero && val === 0) return true;
        }
    }
    return Number.isSafeInteger(val) && val >= 1;
};


$7c1fa217b3cf3727$exports = function stripDirs(pathStr, count, option) {
    if (typeof pathStr !== "string") throw new TypeError($dAk3n$util.inspect(pathStr) + " is not a string. First argument to strip-dirs must be a path string.");
    if ($dAk3n$path.posix.isAbsolute(pathStr) || $dAk3n$path.win32.isAbsolute(pathStr)) throw new Error(`${pathStr} is an absolute path. strip-dirs requires a relative path.`);
    if (!$bac092103a64be70$exports(count, {
        includeZero: true
    })) throw new Error("The Second argument of strip-dirs must be a natural number or 0, but received " + $dAk3n$util.inspect(count) + ".");
    if (option) {
        if (typeof option !== "object") throw new TypeError($dAk3n$util.inspect(option) + " is not an object. Expected an object with a boolean `disallowOverflow` property.");
        if (Array.isArray(option)) throw new TypeError($dAk3n$util.inspect(option) + " is an array. Expected an object with a boolean `disallowOverflow` property.");
        if ("disallowOverflow" in option && typeof option.disallowOverflow !== "boolean") throw new TypeError($dAk3n$util.inspect(option.disallowOverflow) + " is neither true nor false. `disallowOverflow` option must be a Boolean value.");
    } else option = {
        disallowOverflow: false
    };
    const pathComponents = $dAk3n$path.normalize(pathStr).split($dAk3n$path.sep);
    if (pathComponents.length > 1 && pathComponents[0] === ".") pathComponents.shift();
    if (count > pathComponents.length - 1) {
        if (option.disallowOverflow) throw new RangeError("Cannot strip more directories than there are.");
        count = pathComponents.length - 1;
    }
    return $dAk3n$path.join.apply(null, pathComponents.slice(count));
};


const $f51ecae46f19a31a$var$fsP = $1d7c960cf32ac643$exports($09851ef183fe50e4$exports);
const $f51ecae46f19a31a$var$runPlugins = (input, opts)=>{
    if (opts.plugins.length === 0) return Promise.resolve([]);
    return Promise.all(opts.plugins.map((x)=>x(input, opts))).then((files)=>files.reduce((a, b)=>a.concat(b)));
};
const $f51ecae46f19a31a$var$safeMakeDir = (dir, realOutputPath)=>{
    return $f51ecae46f19a31a$var$fsP.realpath(dir).catch((_)=>{
        const parent = $dAk3n$path.dirname(dir);
        return $f51ecae46f19a31a$var$safeMakeDir(parent, realOutputPath);
    }).then((realParentPath)=>{
        if (realParentPath.indexOf(realOutputPath) !== 0) throw new Error("Refusing to create a directory outside the output path.");
        return $efab8ab1a2100452$exports(dir).then($f51ecae46f19a31a$var$fsP.realpath);
    });
};
const $f51ecae46f19a31a$var$preventWritingThroughSymlink = (destination, realOutputPath)=>{
    return $f51ecae46f19a31a$var$fsP.readlink(destination).catch((_)=>{
        // Either no file exists, or it's not a symlink. In either case, this is
        // not an escape we need to worry about in this phase.
        return null;
    }).then((symlinkPointsTo)=>{
        if (symlinkPointsTo) throw new Error("Refusing to write into a symlink");
        // No symlink exists at `destination`, so we can continue
        return realOutputPath;
    });
};
const $f51ecae46f19a31a$var$extractFile = (input, output, opts)=>$f51ecae46f19a31a$var$runPlugins(input, opts).then((files)=>{
        if (opts.strip > 0) files = files.map((x)=>{
            x.path = $7c1fa217b3cf3727$exports(x.path, opts.strip);
            return x;
        }).filter((x)=>x.path !== ".");
        if (typeof opts.filter === "function") files = files.filter(opts.filter);
        if (typeof opts.map === "function") files = files.map(opts.map);
        if (!output) return files;
        return Promise.all(files.map((x)=>{
            const dest = $dAk3n$path.join(output, x.path);
            const mode = x.mode & ~process.umask();
            const now = new Date();
            if (x.type === "directory") return $efab8ab1a2100452$exports(output).then((outputPath)=>$f51ecae46f19a31a$var$fsP.realpath(outputPath)).then((realOutputPath)=>$f51ecae46f19a31a$var$safeMakeDir(dest, realOutputPath)).then(()=>$f51ecae46f19a31a$var$fsP.utimes(dest, now, x.mtime)).then(()=>x);
            return $efab8ab1a2100452$exports(output).then((outputPath)=>$f51ecae46f19a31a$var$fsP.realpath(outputPath)).then((realOutputPath)=>{
                // Attempt to ensure parent directory exists (failing if it's outside the output dir)
                return $f51ecae46f19a31a$var$safeMakeDir($dAk3n$path.dirname(dest), realOutputPath).then(()=>realOutputPath);
            }).then((realOutputPath)=>{
                if (x.type === "file") return $f51ecae46f19a31a$var$preventWritingThroughSymlink(dest, realOutputPath);
                return realOutputPath;
            }).then((realOutputPath)=>{
                return $f51ecae46f19a31a$var$fsP.realpath($dAk3n$path.dirname(dest)).then((realDestinationDir)=>{
                    if (realDestinationDir.indexOf(realOutputPath) !== 0) throw new Error("Refusing to write outside output directory: " + realDestinationDir);
                });
            }).then(()=>{
                if (x.type === "link") return $f51ecae46f19a31a$var$fsP.link(x.linkname, dest);
                if (x.type === "symlink" && process.platform === "win32") return $f51ecae46f19a31a$var$fsP.link(x.linkname, dest);
                if (x.type === "symlink") return $f51ecae46f19a31a$var$fsP.symlink(x.linkname, dest);
                return $f51ecae46f19a31a$var$fsP.writeFile(dest, x.data, {
                    mode: mode
                });
            }).then(()=>x.type === "file" && $f51ecae46f19a31a$var$fsP.utimes(dest, now, x.mtime)).then(()=>x);
        }));
    });
$f51ecae46f19a31a$exports = (input, output, opts)=>{
    if (typeof input !== "string" && !Buffer.isBuffer(input)) return Promise.reject(new TypeError("Input file required"));
    if (typeof output === "object") {
        opts = output;
        output = null;
    }
    opts = Object.assign({
        plugins: [
            $9d614d74911e0026$exports(),
            $b05f17374a7517a3$exports(),
            $a9641a5c75629d2a$exports(),
            $2cde43dad30286f7$exports()
        ]
    }, opts);
    const read = typeof input === "string" ? $f51ecae46f19a31a$var$fsP.readFile(input) : Promise.resolve(input);
    return read.then((buf)=>$f51ecae46f19a31a$var$extractFile(buf, output, opts));
};


var $40583aba8cfcb18f$exports = {};
"use strict";
var $b17a8ce29fcdf13a$exports = {};
"use strict";
var $4595ca4e56fa3be9$exports = {};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module exports.
 */ 
$4595ca4e56fa3be9$exports = (parcelRequire("kQK5c"));


$b17a8ce29fcdf13a$exports = function() {
    var ret = {};
    Object.keys($4595ca4e56fa3be9$exports).forEach(function(x) {
        var val = $4595ca4e56fa3be9$exports[x];
        if (val.extensions && val.extensions.length > 0) val.extensions.forEach(function(y) {
            ret[y] = x;
        });
    });
    return ret;
};


/**
 * Sort object keys by length
 *
 * @param obj
 * @api public
 */ var $8b1472b1aa523128$export$51987bb50e1f6752;
var $8b1472b1aa523128$export$debe6e778e0a6d32;
"use strict";
var $91b0c4b73f4f4dfd$exports = {};
"use strict";
var $e692bfe7403d4ba6$exports = {};
"use strict";
var $e692bfe7403d4ba6$var$toString = Object.prototype.toString;
$e692bfe7403d4ba6$exports = function(x) {
    var prototype;
    return $e692bfe7403d4ba6$var$toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};


$91b0c4b73f4f4dfd$exports = function(obj, opts) {
    if (!$e692bfe7403d4ba6$exports(obj)) throw new TypeError("Expected a plain object");
    opts = opts || {};
    // DEPRECATED
    if (typeof opts === "function") opts = {
        compare: opts
    };
    var deep = opts.deep;
    var seenInput = [];
    var seenOutput = [];
    var sortKeys = function(x) {
        var seenIndex = seenInput.indexOf(x);
        if (seenIndex !== -1) return seenOutput[seenIndex];
        var ret = {};
        var keys = Object.keys(x).sort(opts.compare);
        seenInput.push(x);
        seenOutput.push(ret);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var val = x[key];
            ret[key] = deep && $e692bfe7403d4ba6$exports(val) ? sortKeys(val) : val;
        }
        return ret;
    };
    return sortKeys(obj);
};


$8b1472b1aa523128$export$51987bb50e1f6752 = function(obj) {
    return $91b0c4b73f4f4dfd$exports(obj, function(a, b) {
        return b.length - a.length;
    });
};
$8b1472b1aa523128$export$debe6e778e0a6d32 = function(obj) {
    return $91b0c4b73f4f4dfd$exports(obj, function(a, b) {
        return a.length - b.length;
    });
};


$40583aba8cfcb18f$exports = (str)=>{
    const obj = $8b1472b1aa523128$export$51987bb50e1f6752($b17a8ce29fcdf13a$exports());
    const exts = Object.keys(obj).filter((x)=>str.endsWith(x));
    if (exts.length === 0) return [];
    return exts.map((x)=>({
            ext: x,
            mime: obj[x]
        }));
};
$40583aba8cfcb18f$exports.mime = (str)=>{
    const obj = $8b1472b1aa523128$export$51987bb50e1f6752($b17a8ce29fcdf13a$exports());
    const exts = Object.keys(obj).filter((x)=>obj[x] === str);
    if (exts.length === 0) return [];
    return exts.map((x)=>({
            ext: x,
            mime: obj[x]
        }));
};


/**
 * Module convert fs functions to promise based functions
 */ 
const $af7298a9fe1ea9d7$export$f8b9fb4db095815b = (0, ($parcel$interopDefault($dAk3n$nodefs))).existsSync;
const $af7298a9fe1ea9d7$export$e4f39cc0c572a82b = (0, ($parcel$interopDefault($dAk3n$nodefs))).createReadStream;
async function $af7298a9fe1ea9d7$export$f82f04a91eb6144a(path) {
    return new Promise((resolve, reject)=>{
        (0, ($parcel$interopDefault($dAk3n$nodefs))).stat(path, (err, stats)=>{
            if (err) reject(err);
            else resolve(stats);
        });
    });
}
async function $af7298a9fe1ea9d7$export$8360e631d277ea4d(fd) {
    return new Promise((resolve, reject)=>{
        (0, ($parcel$interopDefault($dAk3n$nodefs))).close(fd, (err)=>{
            if (err) reject(err);
            else resolve();
        });
    });
}
async function $af7298a9fe1ea9d7$export$3ce6949f20cea765(path, mode) {
    return new Promise((resolve, reject)=>{
        (0, ($parcel$interopDefault($dAk3n$nodefs))).open(path, mode, (err, fd)=>{
            if (err) reject(err);
            else resolve(fd);
        });
    });
}
async function $af7298a9fe1ea9d7$export$aafa59e2e03f2942(fd, buffer, offset, length, position) {
    return new Promise((resolve, reject)=>{
        (0, ($parcel$interopDefault($dAk3n$nodefs))).read(fd, buffer, offset, length, position, (err, bytesRead, _buffer)=>{
            if (err) reject(err);
            else resolve({
                bytesRead: bytesRead,
                buffer: _buffer
            });
        });
    });
}
async function $af7298a9fe1ea9d7$export$552bfb764b5cd2b4(path, data) {
    return new Promise((resolve, reject)=>{
        (0, ($parcel$interopDefault($dAk3n$nodefs))).writeFile(path, data, (err)=>{
            if (err) reject(err);
            else resolve();
        });
    });
}
function $af7298a9fe1ea9d7$export$4aafa08d67400a6f(path, data) {
    (0, ($parcel$interopDefault($dAk3n$nodefs))).writeFileSync(path, data);
}
async function $af7298a9fe1ea9d7$export$72c04af63de9061a(path) {
    return new Promise((resolve, reject)=>{
        (0, ($parcel$interopDefault($dAk3n$nodefs))).readFile(path, (err, buffer)=>{
            if (err) reject(err);
            else resolve(buffer);
        });
    });
}


const $416665911114e22e$export$628f6f7219a6b8b6 = "End-Of-Stream";
class $416665911114e22e$export$f021502591f89f5f extends Error {
    constructor(){
        super($416665911114e22e$export$628f6f7219a6b8b6);
    }
}



class $9c2ee5d755b0e3dd$export$85f6557964517f1a {
    constructor(){
        this.resolve = ()=>null;
        this.reject = ()=>null;
        this.promise = new Promise((resolve, reject)=>{
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}


const $166d3f9cbd6bc0f5$var$maxStreamReadSize = 1048576; // Maximum request length on read-stream operation
class $166d3f9cbd6bc0f5$export$6d34e0e37d38354f {
    constructor(s){
        this.s = s;
        /**
         * Deferred used for postponed read request (as not data is yet available to read)
         */ this.deferred = null;
        this.endOfStream = false;
        /**
         * Store peeked data
         * @type {Array}
         */ this.peekQueue = [];
        if (!s.read || !s.once) throw new Error("Expected an instance of stream.Readable");
        this.s.once("end", ()=>this.reject(new (0, $416665911114e22e$export$f021502591f89f5f)()));
        this.s.once("error", (err)=>this.reject(err));
        this.s.once("close", ()=>this.reject(new Error("Stream closed")));
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes peeked
     */ async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
        return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */ async read(buffer, offset, length) {
        if (length === 0) return 0;
        if (this.peekQueue.length === 0 && this.endOfStream) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        let remaining = length;
        let bytesRead = 0;
        // consume peeked data first
        while(this.peekQueue.length > 0 && remaining > 0){
            const peekData = this.peekQueue.pop(); // Front of queue
            if (!peekData) throw new Error("peekData should be defined");
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) // remainder back to queue
            this.peekQueue.push(peekData.subarray(lenCopy));
        }
        // continue reading from stream if required
        while(remaining > 0 && !this.endOfStream){
            const reqLen = Math.min(remaining, $166d3f9cbd6bc0f5$var$maxStreamReadSize);
            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
            bytesRead += chunkLen;
            if (chunkLen < reqLen) break;
            remaining -= chunkLen;
        }
        return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */ async readFromStream(buffer, offset, length) {
        const readBuffer = this.s.read(length);
        if (readBuffer) {
            buffer.set(readBuffer, offset);
            return readBuffer.length;
        } else {
            const request = {
                buffer: buffer,
                offset: offset,
                length: length,
                deferred: new (0, $9c2ee5d755b0e3dd$export$85f6557964517f1a)()
            };
            this.deferred = request.deferred;
            this.s.once("readable", ()=>{
                this.readDeferred(request);
            });
            return request.deferred.promise;
        }
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */ readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
            request.buffer.set(readBuffer, request.offset);
            request.deferred.resolve(readBuffer.length);
            this.deferred = null;
        } else this.s.once("readable", ()=>{
            this.readDeferred(request);
        });
    }
    reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
            this.deferred.reject(err);
            this.deferred = null;
        }
    }
}





class $7ab899e58d35026a$export$3dcfec4cbd3b739b {
    constructor(fileInfo){
        /**
         * Tokenizer-stream position
         */ this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */ async readToken(token, position = this.position) {
        const uint8Array = (0, $dAk3n$nodebuffer.Buffer).alloc(token.len);
        const len = await this.readBuffer(uint8Array, {
            position: position
        });
        if (len < token.len) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */ async peekToken(token, position = this.position) {
        const uint8Array = (0, $dAk3n$nodebuffer.Buffer).alloc(token.len);
        const len = await this.peekBuffer(uint8Array, {
            position: position
        });
        if (len < token.len) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */ async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, {
            length: token.len
        });
        if (len < token.len) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */ async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, {
            length: token.len
        });
        if (len < token.len) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */ async ignore(length) {
        if (this.fileInfo.size !== undefined) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
                this.position += bytesLeft;
                return bytesLeft;
            }
        }
        this.position += length;
        return length;
    }
    async close() {
    // empty
    }
    normalizeOptions(uint8Array, options) {
        if (options && options.position !== undefined && options.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        if (options) return {
            mayBeLess: options.mayBeLess === true,
            offset: options.offset ? options.offset : 0,
            length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
            position: options.position ? options.position : this.position
        };
        return {
            mayBeLess: false,
            offset: 0,
            length: uint8Array.length,
            position: this.position
        };
    }
}



const $4183ebb55d613fcb$var$maxBufferSize = 256000;
class $4183ebb55d613fcb$export$5c1d2bb79e2a213d extends (0, $7ab899e58d35026a$export$3dcfec4cbd3b739b) {
    constructor(stream, fileInfo){
        super(fileInfo);
        this.streamReader = new (0, $166d3f9cbd6bc0f5$export$6d34e0e37d38354f)(stream);
    }
    /**
     * Get file information, an HTTP-client may implement this doing a HEAD request
     * @return Promise with file information
     */ async getFileInfo() {
        return this.fileInfo;
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */ async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
        } else if (skipBytes < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        if (normOptions.length === 0) return 0;
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
                bytesRead = await this.peekBuffer(skipBuffer, {
                    mayBeLess: normOptions.mayBeLess
                });
                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
                return bytesRead - skipBytes;
            } else if (skipBytes < 0) throw new Error("Cannot peek from a negative offset in a stream");
        }
        if (normOptions.length > 0) {
            try {
                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
            } catch (err) {
                if (options && options.mayBeLess && err instanceof (0, $416665911114e22e$export$f021502591f89f5f)) return 0;
                throw err;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        }
        return bytesRead;
    }
    async ignore(length) {
        // debug(`ignore ${this.position}...${this.position + length - 1}`);
        const bufSize = Math.min($4183ebb55d613fcb$var$maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while(totBytesRead < length){
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, {
                length: Math.min(bufSize, remaining)
            });
            if (bytesRead < 0) return bytesRead;
            totBytesRead += bytesRead;
        }
        return totBytesRead;
    }
}




class $0793b6757487f27d$export$174c2bc747bfb414 extends (0, $7ab899e58d35026a$export$3dcfec4cbd3b739b) {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param fileInfo - Pass additional file information to the tokenizer
     */ constructor(uint8Array, fileInfo){
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async readBuffer(uint8Array, options) {
        if (options && options.position) {
            if (options.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
            this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        else {
            uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
            return bytes2read;
        }
    }
    async close() {
    // empty
    }
}



function $b61f99f9d4e2b08c$export$2c6bc52bcd2a369b(stream, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new (0, $4183ebb55d613fcb$export$5c1d2bb79e2a213d)(stream, fileInfo);
}
function $b61f99f9d4e2b08c$export$d573cdcf1a515b2(uint8Array, fileInfo) {
    return new (0, $0793b6757487f27d$export$174c2bc747bfb414)(uint8Array, fileInfo);
}





class $b1d1fcc9f4e40f5e$export$34f7411499e592ce extends (0, $7ab899e58d35026a$export$3dcfec4cbd3b739b) {
    constructor(fd, fileInfo){
        super(fileInfo);
        this.fd = fd;
    }
    /**
     * Read buffer from file
     * @param uint8Array - Uint8Array to write result to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */ async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        const res = await $af7298a9fe1ea9d7$export$aafa59e2e03f2942(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return res.bytesRead;
    }
    /**
     * Peek buffer from file
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await $af7298a9fe1ea9d7$export$aafa59e2e03f2942(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) throw new (0, $416665911114e22e$export$f021502591f89f5f)();
        return res.bytesRead;
    }
    async close() {
        return $af7298a9fe1ea9d7$export$8360e631d277ea4d(this.fd);
    }
}
async function $b1d1fcc9f4e40f5e$export$90aa898098c12e80(sourceFilePath) {
    const stat = await $af7298a9fe1ea9d7$export$f82f04a91eb6144a(sourceFilePath);
    if (!stat.isFile) throw new Error(`File not a file: ${sourceFilePath}`);
    const fd = await $af7298a9fe1ea9d7$export$3ce6949f20cea765(sourceFilePath, "r");
    return new $b1d1fcc9f4e40f5e$export$34f7411499e592ce(fd, {
        path: sourceFilePath,
        size: stat.size
    });
}


async function $91d44a1ebe209ae5$export$2c6bc52bcd2a369b(stream, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    if (stream.path) {
        const stat = await $af7298a9fe1ea9d7$export$f82f04a91eb6144a(stream.path);
        fileInfo.path = stream.path;
        fileInfo.size = stat.size;
    }
    return $b61f99f9d4e2b08c$export$2c6bc52bcd2a369b(stream, fileInfo);
}



/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $5697f40cc952a472$export$aafa59e2e03f2942;
var $5697f40cc952a472$export$68d8715fc104d294;
$5697f40cc952a472$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
$5697f40cc952a472$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};



// Primitive types
function $28c1768f3e98c2f4$var$dv(array) {
    return new DataView(array.buffer, array.byteOffset);
}
const $28c1768f3e98c2f4$export$212e71dfd61c79fa = {
    len: 1,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getUint8(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setUint8(offset, value);
        return offset + 1;
    }
};
const $28c1768f3e98c2f4$export$f4321bfdc0492771 = {
    len: 2,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getUint16(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setUint16(offset, value, true);
        return offset + 2;
    }
};
const $28c1768f3e98c2f4$export$42c08c44e3e6155 = {
    len: 2,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getUint16(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setUint16(offset, value);
        return offset + 2;
    }
};
const $28c1768f3e98c2f4$export$1c06b736afa06b = {
    len: 3,
    get (array, offset) {
        const dataView = $28c1768f3e98c2f4$var$dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put (array, offset, value) {
        const dataView = $28c1768f3e98c2f4$var$dv(array);
        dataView.setUint8(offset, value & 0xff);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
    }
};
const $28c1768f3e98c2f4$export$850a148612a179ce = {
    len: 3,
    get (array, offset) {
        const dataView = $28c1768f3e98c2f4$var$dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put (array, offset, value) {
        const dataView = $28c1768f3e98c2f4$var$dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 0xff);
        return offset + 3;
    }
};
const $28c1768f3e98c2f4$export$2e83bc8b95c0add0 = {
    len: 4,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getUint32(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setUint32(offset, value, true);
        return offset + 4;
    }
};
const $28c1768f3e98c2f4$export$19165e57e2764f4d = {
    len: 4,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getUint32(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setUint32(offset, value);
        return offset + 4;
    }
};
const $28c1768f3e98c2f4$export$9922471c07c2891d = {
    len: 1,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getInt8(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setInt8(offset, value);
        return offset + 1;
    }
};
const $28c1768f3e98c2f4$export$ae57c43b0f2e0bae = {
    len: 2,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getInt16(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setInt16(offset, value);
        return offset + 2;
    }
};
const $28c1768f3e98c2f4$export$621f7ed1a7e0038b = {
    len: 2,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getInt16(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setInt16(offset, value, true);
        return offset + 2;
    }
};
const $28c1768f3e98c2f4$export$d230bc6a9e2f5967 = {
    len: 3,
    get (array, offset) {
        const unsigned = $28c1768f3e98c2f4$export$1c06b736afa06b.get(array, offset);
        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put (array, offset, value) {
        const dataView = $28c1768f3e98c2f4$var$dv(array);
        dataView.setUint8(offset, value & 0xff);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
    }
};
const $28c1768f3e98c2f4$export$ea54913e0c4d7e49 = {
    len: 3,
    get (array, offset) {
        const unsigned = $28c1768f3e98c2f4$export$850a148612a179ce.get(array, offset);
        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put (array, offset, value) {
        const dataView = $28c1768f3e98c2f4$var$dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 0xff);
        return offset + 3;
    }
};
const $28c1768f3e98c2f4$export$8e6095fee2ed4324 = {
    len: 4,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getInt32(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setInt32(offset, value);
        return offset + 4;
    }
};
const $28c1768f3e98c2f4$export$1b8cc1acb7548b9c = {
    len: 4,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getInt32(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setInt32(offset, value, true);
        return offset + 4;
    }
};
const $28c1768f3e98c2f4$export$2a144484d4216c32 = {
    len: 8,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getBigUint64(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setBigUint64(offset, value, true);
        return offset + 8;
    }
};
const $28c1768f3e98c2f4$export$98590657e36306ba = {
    len: 8,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getBigInt64(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setBigInt64(offset, value, true);
        return offset + 8;
    }
};
const $28c1768f3e98c2f4$export$6b4fd634f2c12378 = {
    len: 8,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getBigUint64(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setBigUint64(offset, value);
        return offset + 8;
    }
};
const $28c1768f3e98c2f4$export$2a5280ede044ed7f = {
    len: 8,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getBigInt64(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setBigInt64(offset, value);
        return offset + 8;
    }
};
const $28c1768f3e98c2f4$export$22132d4ede474afe = {
    len: 2,
    get (dataView, offset) {
        return $5697f40cc952a472$export$aafa59e2e03f2942(dataView, offset, false, 10, this.len);
    },
    put (dataView, offset, value) {
        $5697f40cc952a472$export$68d8715fc104d294(dataView, value, offset, false, 10, this.len);
        return offset + this.len;
    }
};
const $28c1768f3e98c2f4$export$cc04e722d5a79186 = {
    len: 2,
    get (array, offset) {
        return $5697f40cc952a472$export$aafa59e2e03f2942(array, offset, true, 10, this.len);
    },
    put (array, offset, value) {
        $5697f40cc952a472$export$68d8715fc104d294(array, value, offset, true, 10, this.len);
        return offset + this.len;
    }
};
const $28c1768f3e98c2f4$export$c9612cdfcd75cd31 = {
    len: 4,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getFloat32(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setFloat32(offset, value);
        return offset + 4;
    }
};
const $28c1768f3e98c2f4$export$503a7498ada9e881 = {
    len: 4,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getFloat32(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setFloat32(offset, value, true);
        return offset + 4;
    }
};
const $28c1768f3e98c2f4$export$e03cb3d3e12b39e0 = {
    len: 8,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getFloat64(offset);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setFloat64(offset, value);
        return offset + 8;
    }
};
const $28c1768f3e98c2f4$export$57daca39900f82a5 = {
    len: 8,
    get (array, offset) {
        return $28c1768f3e98c2f4$var$dv(array).getFloat64(offset, true);
    },
    put (array, offset, value) {
        $28c1768f3e98c2f4$var$dv(array).setFloat64(offset, value, true);
        return offset + 8;
    }
};
const $28c1768f3e98c2f4$export$576a1b1cf45db16d = {
    len: 10,
    get (array, offset) {
        return $5697f40cc952a472$export$aafa59e2e03f2942(array, offset, false, 63, this.len);
    },
    put (array, offset, value) {
        $5697f40cc952a472$export$68d8715fc104d294(array, value, offset, false, 63, this.len);
        return offset + this.len;
    }
};
const $28c1768f3e98c2f4$export$de21ee76fe1fdb2b = {
    len: 10,
    get (array, offset) {
        return $5697f40cc952a472$export$aafa59e2e03f2942(array, offset, true, 63, this.len);
    },
    put (array, offset, value) {
        $5697f40cc952a472$export$68d8715fc104d294(array, value, offset, true, 63, this.len);
        return offset + this.len;
    }
};
class $28c1768f3e98c2f4$export$6943619661db1194 {
    /**
     * @param len number of bytes to ignore
     */ constructor(len){
        this.len = len;
    }
    // ToDo: don't read, but skip data
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    get(array, off) {}
}
class $28c1768f3e98c2f4$export$d1452966f7cf0ad2 {
    constructor(len){
        this.len = len;
    }
    get(array, offset) {
        return array.subarray(offset, offset + this.len);
    }
}
class $28c1768f3e98c2f4$export$a9b603917c4d9863 {
    constructor(len){
        this.len = len;
    }
    get(uint8Array, off) {
        return (0, $dAk3n$nodebuffer.Buffer).from(uint8Array.subarray(off, off + this.len));
    }
}
class $28c1768f3e98c2f4$export$2b93044cbf134323 {
    constructor(len, encoding){
        this.len = len;
        this.encoding = encoding;
    }
    get(uint8Array, offset) {
        return (0, $dAk3n$nodebuffer.Buffer).from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
}
class $28c1768f3e98c2f4$export$763777b3a3c2268d {
    constructor(len){
        this.len = len;
    }
    static decode(buffer, offset, until) {
        let str = "";
        for(let i = offset; i < until; ++i)str += $28c1768f3e98c2f4$export$763777b3a3c2268d.codePointToString($28c1768f3e98c2f4$export$763777b3a3c2268d.singleByteDecoder(buffer[i]));
        return str;
    }
    static inRange(a, min, max) {
        return min <= a && a <= max;
    }
    static codePointToString(cp) {
        if (cp <= 0xFFFF) return String.fromCharCode(cp);
        else {
            cp -= 0x10000;
            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
        }
    }
    static singleByteDecoder(bite) {
        if ($28c1768f3e98c2f4$export$763777b3a3c2268d.inRange(bite, 0x00, 0x7F)) return bite;
        const codePoint = $28c1768f3e98c2f4$export$763777b3a3c2268d.windows1252[bite - 0x80];
        if (codePoint === null) throw Error("invaliding encoding");
        return codePoint;
    }
    get(buffer, offset = 0) {
        return $28c1768f3e98c2f4$export$763777b3a3c2268d.decode(buffer, offset, offset + this.len);
    }
}
$28c1768f3e98c2f4$export$763777b3a3c2268d.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
];



function $5ffd4575deb4f646$export$c8dd6bc66a63753c(string) {
    return [
        ...string
    ].map((character)=>character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point
}
function $5ffd4575deb4f646$export$4db760af30f3bad5(buffer, offset = 0) {
    const readSum = Number.parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8); // Read sum in header
    if (Number.isNaN(readSum)) return false;
    let sum = 256; // Initialize signed bit sum
    for(let index = offset; index < offset + 148; index++)sum += buffer[index];
    for(let index = offset + 156; index < offset + 512; index++)sum += buffer[index];
    return readSum === sum;
}
const $5ffd4575deb4f646$export$5b7739e7429d73a4 = {
    get: (buffer, offset)=>buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
};


const $8ad62da59814daff$export$cc3e2d3244e01b7f = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "ai",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc"
];
const $8ad62da59814daff$export$53cb456310d1907e = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/x-apache-arrow",
    "video/mp4",
    "audio/midi",
    "video/x-matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/vnd.wave",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "audio/opus",
    "video/ogg",
    "audio/ogg",
    "application/ogg",
    "audio/x-flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/x-parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile"
];


const $599ba2eea70127a0$var$minimumBytes = 4100; // A fair amount of file-types are detectable within this range.
async function $599ba2eea70127a0$export$95a3a484cc0ae7c3(stream) {
    const tokenizer = await $b61f99f9d4e2b08c$export$2c6bc52bcd2a369b(stream);
    try {
        return await $599ba2eea70127a0$export$59af0df03c3cfde6(tokenizer);
    } finally{
        await tokenizer.close();
    }
}
async function $599ba2eea70127a0$export$79017d38a9b78817(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) return;
    return $599ba2eea70127a0$export$59af0df03c3cfde6($b61f99f9d4e2b08c$export$d573cdcf1a515b2(buffer));
}
async function $599ba2eea70127a0$export$ffbd9020839ccf86(blob) {
    const buffer = await blob.arrayBuffer();
    return $599ba2eea70127a0$export$79017d38a9b78817(new Uint8Array(buffer));
}
function $599ba2eea70127a0$var$_check(buffer, headers, options) {
    options = {
        offset: 0,
        ...options
    };
    for (const [index, header] of headers.entries()){
        // If a bitmask is set
        if (options.mask) {
            // If header doesn't equal `buf` with bits masked off
            if (header !== (options.mask[index] & buffer[index + options.offset])) return false;
        } else if (header !== buffer[index + options.offset]) return false;
    }
    return true;
}
async function $599ba2eea70127a0$export$59af0df03c3cfde6(tokenizer) {
    try {
        return new $599ba2eea70127a0$var$FileTypeParser().parse(tokenizer);
    } catch (error) {
        if (!(error instanceof $416665911114e22e$export$f021502591f89f5f)) throw error;
    }
}
class $599ba2eea70127a0$var$FileTypeParser {
    check(header, options) {
        return $599ba2eea70127a0$var$_check(this.buffer, header, options);
    }
    checkString(header, options) {
        return this.check((0, $5ffd4575deb4f646$export$c8dd6bc66a63753c)(header), options);
    }
    async parse(tokenizer) {
        this.buffer = (0, $dAk3n$nodebuffer.Buffer).alloc($599ba2eea70127a0$var$minimumBytes);
        // Keep reading until EOF if the file size is unknown.
        if (tokenizer.fileInfo.size === undefined) tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
        this.tokenizer = tokenizer;
        await tokenizer.peekBuffer(this.buffer, {
            length: 12,
            mayBeLess: true
        });
        // -- 2-byte signatures --
        if (this.check([
            0x42,
            0x4D
        ])) return {
            ext: "bmp",
            mime: "image/bmp"
        };
        if (this.check([
            0x0B,
            0x77
        ])) return {
            ext: "ac3",
            mime: "audio/vnd.dolby.dd-raw"
        };
        if (this.check([
            0x78,
            0x01
        ])) return {
            ext: "dmg",
            mime: "application/x-apple-diskimage"
        };
        if (this.check([
            0x4D,
            0x5A
        ])) return {
            ext: "exe",
            mime: "application/x-msdownload"
        };
        if (this.check([
            0x25,
            0x21
        ])) {
            await tokenizer.peekBuffer(this.buffer, {
                length: 24,
                mayBeLess: true
            });
            if (this.checkString("PS-Adobe-", {
                offset: 2
            }) && this.checkString(" EPSF-", {
                offset: 14
            })) return {
                ext: "eps",
                mime: "application/eps"
            };
            return {
                ext: "ps",
                mime: "application/postscript"
            };
        }
        if (this.check([
            0x1F,
            0xA0
        ]) || this.check([
            0x1F,
            0x9D
        ])) return {
            ext: "Z",
            mime: "application/x-compress"
        };
        if (this.check([
            0xC7,
            0x71
        ])) return {
            ext: "cpio",
            mime: "application/x-cpio"
        };
        if (this.check([
            0x60,
            0xEA
        ])) return {
            ext: "arj",
            mime: "application/x-arj"
        };
        // -- 3-byte signatures --
        if (this.check([
            0xEF,
            0xBB,
            0xBF
        ])) {
            // Strip off UTF-8-BOM
            this.tokenizer.ignore(3);
            return this.parse(tokenizer);
        }
        if (this.check([
            0x47,
            0x49,
            0x46
        ])) return {
            ext: "gif",
            mime: "image/gif"
        };
        if (this.check([
            0x49,
            0x49,
            0xBC
        ])) return {
            ext: "jxr",
            mime: "image/vnd.ms-photo"
        };
        if (this.check([
            0x1F,
            0x8B,
            0x8
        ])) return {
            ext: "gz",
            mime: "application/gzip"
        };
        if (this.check([
            0x42,
            0x5A,
            0x68
        ])) return {
            ext: "bz2",
            mime: "application/x-bzip2"
        };
        if (this.checkString("ID3")) {
            await tokenizer.ignore(6); // Skip ID3 header until the header size
            const id3HeaderLength = await tokenizer.readToken((0, $5ffd4575deb4f646$export$5b7739e7429d73a4));
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) // Guess file type based on ID3 header for backward compatibility
            return {
                ext: "mp3",
                mime: "audio/mpeg"
            };
            await tokenizer.ignore(id3HeaderLength);
            return $599ba2eea70127a0$export$59af0df03c3cfde6(tokenizer); // Skip ID3 header, recursion
        }
        // Musepack, SV7
        if (this.checkString("MP+")) return {
            ext: "mpc",
            mime: "audio/x-musepack"
        };
        if ((this.buffer[0] === 0x43 || this.buffer[0] === 0x46) && this.check([
            0x57,
            0x53
        ], {
            offset: 1
        })) return {
            ext: "swf",
            mime: "application/x-shockwave-flash"
        };
        // -- 4-byte signatures --
        // Requires a sample size of 4 bytes
        if (this.check([
            0xFF,
            0xD8,
            0xFF
        ])) {
            if (this.check([
                0xF7
            ], {
                offset: 3
            })) return {
                ext: "jls",
                mime: "image/jls"
            };
            return {
                ext: "jpg",
                mime: "image/jpeg"
            };
        }
        if (this.check([
            0x4F,
            0x62,
            0x6A,
            0x01
        ])) return {
            ext: "avro",
            mime: "application/avro"
        };
        if (this.checkString("FLIF")) return {
            ext: "flif",
            mime: "image/flif"
        };
        if (this.checkString("8BPS")) return {
            ext: "psd",
            mime: "image/vnd.adobe.photoshop"
        };
        if (this.checkString("WEBP", {
            offset: 8
        })) return {
            ext: "webp",
            mime: "image/webp"
        };
        // Musepack, SV8
        if (this.checkString("MPCK")) return {
            ext: "mpc",
            mime: "audio/x-musepack"
        };
        if (this.checkString("FORM")) return {
            ext: "aif",
            mime: "audio/aiff"
        };
        if (this.checkString("icns", {
            offset: 0
        })) return {
            ext: "icns",
            mime: "image/icns"
        };
        // Zip-based file formats
        // Need to be before the `zip` check
        if (this.check([
            0x50,
            0x4B,
            0x3,
            0x4
        ])) {
            try {
                while(tokenizer.position + 30 < tokenizer.fileInfo.size){
                    await tokenizer.readBuffer(this.buffer, {
                        length: 30
                    });
                    // https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
                    const zipHeader = {
                        compressedSize: this.buffer.readUInt32LE(18),
                        uncompressedSize: this.buffer.readUInt32LE(22),
                        filenameLength: this.buffer.readUInt16LE(26),
                        extraFieldLength: this.buffer.readUInt16LE(28)
                    };
                    zipHeader.filename = await tokenizer.readToken(new $28c1768f3e98c2f4$export$2b93044cbf134323(zipHeader.filenameLength, "utf-8"));
                    await tokenizer.ignore(zipHeader.extraFieldLength);
                    // Assumes signed `.xpi` from addons.mozilla.org
                    if (zipHeader.filename === "META-INF/mozilla.rsa") return {
                        ext: "xpi",
                        mime: "application/x-xpinstall"
                    };
                    if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
                        const type = zipHeader.filename.split("/")[0];
                        switch(type){
                            case "_rels":
                                break;
                            case "word":
                                return {
                                    ext: "docx",
                                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                                };
                            case "ppt":
                                return {
                                    ext: "pptx",
                                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                                };
                            case "xl":
                                return {
                                    ext: "xlsx",
                                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                };
                            default:
                                break;
                        }
                    }
                    if (zipHeader.filename.startsWith("xl/")) return {
                        ext: "xlsx",
                        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    };
                    if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) return {
                        ext: "3mf",
                        mime: "model/3mf"
                    };
                    // The docx, xlsx and pptx file types extend the Office Open XML file format:
                    // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
                    // We look for:
                    // - one entry named '[Content_Types].xml' or '_rels/.rels',
                    // - one entry indicating specific type of file.
                    // MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
                    if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
                        let mimeType = await tokenizer.readToken(new $28c1768f3e98c2f4$export$2b93044cbf134323(zipHeader.compressedSize, "utf-8"));
                        mimeType = mimeType.trim();
                        switch(mimeType){
                            case "application/epub+zip":
                                return {
                                    ext: "epub",
                                    mime: "application/epub+zip"
                                };
                            case "application/vnd.oasis.opendocument.text":
                                return {
                                    ext: "odt",
                                    mime: "application/vnd.oasis.opendocument.text"
                                };
                            case "application/vnd.oasis.opendocument.spreadsheet":
                                return {
                                    ext: "ods",
                                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                                };
                            case "application/vnd.oasis.opendocument.presentation":
                                return {
                                    ext: "odp",
                                    mime: "application/vnd.oasis.opendocument.presentation"
                                };
                            default:
                        }
                    }
                    // Try to find next header manually when current one is corrupted
                    if (zipHeader.compressedSize === 0) {
                        let nextHeaderIndex = -1;
                        while(nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size){
                            await tokenizer.peekBuffer(this.buffer, {
                                mayBeLess: true
                            });
                            nextHeaderIndex = this.buffer.indexOf("504B0304", 0, "hex");
                            // Move position to the next header if found, skip the whole buffer otherwise
                            await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
                        }
                    } else await tokenizer.ignore(zipHeader.compressedSize);
                }
            } catch (error) {
                if (!(error instanceof $416665911114e22e$export$f021502591f89f5f)) throw error;
            }
            return {
                ext: "zip",
                mime: "application/zip"
            };
        }
        if (this.checkString("OggS")) {
            // This is an OGG container
            await tokenizer.ignore(28);
            const type = (0, $dAk3n$nodebuffer.Buffer).alloc(8);
            await tokenizer.readBuffer(type);
            // Needs to be before `ogg` check
            if ($599ba2eea70127a0$var$_check(type, [
                0x4F,
                0x70,
                0x75,
                0x73,
                0x48,
                0x65,
                0x61,
                0x64
            ])) return {
                ext: "opus",
                mime: "audio/opus"
            };
            // If ' theora' in header.
            if ($599ba2eea70127a0$var$_check(type, [
                0x80,
                0x74,
                0x68,
                0x65,
                0x6F,
                0x72,
                0x61
            ])) return {
                ext: "ogv",
                mime: "video/ogg"
            };
            // If '\x01video' in header.
            if ($599ba2eea70127a0$var$_check(type, [
                0x01,
                0x76,
                0x69,
                0x64,
                0x65,
                0x6F,
                0x00
            ])) return {
                ext: "ogm",
                mime: "video/ogg"
            };
            // If ' FLAC' in header  https://xiph.org/flac/faq.html
            if ($599ba2eea70127a0$var$_check(type, [
                0x7F,
                0x46,
                0x4C,
                0x41,
                0x43
            ])) return {
                ext: "oga",
                mime: "audio/ogg"
            };
            // 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
            if ($599ba2eea70127a0$var$_check(type, [
                0x53,
                0x70,
                0x65,
                0x65,
                0x78,
                0x20,
                0x20
            ])) return {
                ext: "spx",
                mime: "audio/ogg"
            };
            // If '\x01vorbis' in header
            if ($599ba2eea70127a0$var$_check(type, [
                0x01,
                0x76,
                0x6F,
                0x72,
                0x62,
                0x69,
                0x73
            ])) return {
                ext: "ogg",
                mime: "audio/ogg"
            };
            // Default OGG container https://www.iana.org/assignments/media-types/application/ogg
            return {
                ext: "ogx",
                mime: "application/ogg"
            };
        }
        if (this.check([
            0x50,
            0x4B
        ]) && (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7) && (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)) return {
            ext: "zip",
            mime: "application/zip"
        };
        //
        // File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
        // It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
        // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
        // Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
        if (this.checkString("ftyp", {
            offset: 4
        }) && (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
        ) {
            // They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
            // For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
            const brandMajor = this.buffer.toString("binary", 8, 12).replace("\x00", " ").trim();
            switch(brandMajor){
                case "avif":
                case "avis":
                    return {
                        ext: "avif",
                        mime: "image/avif"
                    };
                case "mif1":
                    return {
                        ext: "heic",
                        mime: "image/heif"
                    };
                case "msf1":
                    return {
                        ext: "heic",
                        mime: "image/heif-sequence"
                    };
                case "heic":
                case "heix":
                    return {
                        ext: "heic",
                        mime: "image/heic"
                    };
                case "hevc":
                case "hevx":
                    return {
                        ext: "heic",
                        mime: "image/heic-sequence"
                    };
                case "qt":
                    return {
                        ext: "mov",
                        mime: "video/quicktime"
                    };
                case "M4V":
                case "M4VH":
                case "M4VP":
                    return {
                        ext: "m4v",
                        mime: "video/x-m4v"
                    };
                case "M4P":
                    return {
                        ext: "m4p",
                        mime: "video/mp4"
                    };
                case "M4B":
                    return {
                        ext: "m4b",
                        mime: "audio/mp4"
                    };
                case "M4A":
                    return {
                        ext: "m4a",
                        mime: "audio/x-m4a"
                    };
                case "F4V":
                    return {
                        ext: "f4v",
                        mime: "video/mp4"
                    };
                case "F4P":
                    return {
                        ext: "f4p",
                        mime: "video/mp4"
                    };
                case "F4A":
                    return {
                        ext: "f4a",
                        mime: "audio/mp4"
                    };
                case "F4B":
                    return {
                        ext: "f4b",
                        mime: "audio/mp4"
                    };
                case "crx":
                    return {
                        ext: "cr3",
                        mime: "image/x-canon-cr3"
                    };
                default:
                    if (brandMajor.startsWith("3g")) {
                        if (brandMajor.startsWith("3g2")) return {
                            ext: "3g2",
                            mime: "video/3gpp2"
                        };
                        return {
                            ext: "3gp",
                            mime: "video/3gpp"
                        };
                    }
                    return {
                        ext: "mp4",
                        mime: "video/mp4"
                    };
            }
        }
        if (this.checkString("MThd")) return {
            ext: "mid",
            mime: "audio/midi"
        };
        if (this.checkString("wOFF") && (this.check([
            0x00,
            0x01,
            0x00,
            0x00
        ], {
            offset: 4
        }) || this.checkString("OTTO", {
            offset: 4
        }))) return {
            ext: "woff",
            mime: "font/woff"
        };
        if (this.checkString("wOF2") && (this.check([
            0x00,
            0x01,
            0x00,
            0x00
        ], {
            offset: 4
        }) || this.checkString("OTTO", {
            offset: 4
        }))) return {
            ext: "woff2",
            mime: "font/woff2"
        };
        if (this.check([
            0xD4,
            0xC3,
            0xB2,
            0xA1
        ]) || this.check([
            0xA1,
            0xB2,
            0xC3,
            0xD4
        ])) return {
            ext: "pcap",
            mime: "application/vnd.tcpdump.pcap"
        };
        // Sony DSD Stream File (DSF)
        if (this.checkString("DSD ")) return {
            ext: "dsf",
            mime: "audio/x-dsf"
        };
        if (this.checkString("LZIP")) return {
            ext: "lz",
            mime: "application/x-lzip"
        };
        if (this.checkString("fLaC")) return {
            ext: "flac",
            mime: "audio/x-flac"
        };
        if (this.check([
            0x42,
            0x50,
            0x47,
            0xFB
        ])) return {
            ext: "bpg",
            mime: "image/bpg"
        };
        if (this.checkString("wvpk")) return {
            ext: "wv",
            mime: "audio/wavpack"
        };
        if (this.checkString("%PDF")) {
            try {
                await tokenizer.ignore(1350);
                const maxBufferSize = 10485760;
                const buffer = (0, $dAk3n$nodebuffer.Buffer).alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
                await tokenizer.readBuffer(buffer, {
                    mayBeLess: true
                });
                // Check if this is an Adobe Illustrator file
                if (buffer.includes((0, $dAk3n$nodebuffer.Buffer).from("AIPrivateData"))) return {
                    ext: "ai",
                    mime: "application/postscript"
                };
            } catch (error) {
                // Swallow end of stream error if file is too small for the Adobe AI check
                if (!(error instanceof $416665911114e22e$export$f021502591f89f5f)) throw error;
            }
            // Assume this is just a normal PDF
            return {
                ext: "pdf",
                mime: "application/pdf"
            };
        }
        if (this.check([
            0x00,
            0x61,
            0x73,
            0x6D
        ])) return {
            ext: "wasm",
            mime: "application/wasm"
        };
        // TIFF, little-endian type
        if (this.check([
            0x49,
            0x49
        ])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) return fileType;
        }
        // TIFF, big-endian type
        if (this.check([
            0x4D,
            0x4D
        ])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) return fileType;
        }
        if (this.checkString("MAC ")) return {
            ext: "ape",
            mime: "audio/ape"
        };
        // https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
        if (this.check([
            0x1A,
            0x45,
            0xDF,
            0xA3
        ])) {
            async function readField() {
                const msb = await tokenizer.peekNumber($28c1768f3e98c2f4$export$212e71dfd61c79fa);
                let mask = 0x80;
                let ic = 0; // 0 = A, 1 = B, 2 = C, 3
                // = D
                while((msb & mask) === 0 && mask !== 0){
                    ++ic;
                    mask >>= 1;
                }
                const id = (0, $dAk3n$nodebuffer.Buffer).alloc(ic + 1);
                await tokenizer.readBuffer(id);
                return id;
            }
            async function readElement() {
                const id = await readField();
                const lengthField = await readField();
                lengthField[0] ^= 0x80 >> lengthField.length - 1;
                const nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer
                return {
                    id: id.readUIntBE(0, id.length),
                    len: lengthField.readUIntBE(lengthField.length - nrLength, nrLength)
                };
            }
            async function readChildren(children) {
                while(children > 0){
                    const element = await readElement();
                    if (element.id === 0x4282) {
                        const rawValue = await tokenizer.readToken(new $28c1768f3e98c2f4$export$2b93044cbf134323(element.len, "utf-8"));
                        return rawValue.replace(/\00.*$/g, ""); // Return DocType
                    }
                    await tokenizer.ignore(element.len); // ignore payload
                    --children;
                }
            }
            const re = await readElement();
            const docType = await readChildren(re.len);
            switch(docType){
                case "webm":
                    return {
                        ext: "webm",
                        mime: "video/webm"
                    };
                case "matroska":
                    return {
                        ext: "mkv",
                        mime: "video/x-matroska"
                    };
                default:
                    return;
            }
        }
        // RIFF file format which might be AVI, WAV, QCP, etc
        if (this.check([
            0x52,
            0x49,
            0x46,
            0x46
        ])) {
            if (this.check([
                0x41,
                0x56,
                0x49
            ], {
                offset: 8
            })) return {
                ext: "avi",
                mime: "video/vnd.avi"
            };
            if (this.check([
                0x57,
                0x41,
                0x56,
                0x45
            ], {
                offset: 8
            })) return {
                ext: "wav",
                mime: "audio/vnd.wave"
            };
            // QLCM, QCP file
            if (this.check([
                0x51,
                0x4C,
                0x43,
                0x4D
            ], {
                offset: 8
            })) return {
                ext: "qcp",
                mime: "audio/qcelp"
            };
        }
        if (this.checkString("SQLi")) return {
            ext: "sqlite",
            mime: "application/x-sqlite3"
        };
        if (this.check([
            0x4E,
            0x45,
            0x53,
            0x1A
        ])) return {
            ext: "nes",
            mime: "application/x-nintendo-nes-rom"
        };
        if (this.checkString("Cr24")) return {
            ext: "crx",
            mime: "application/x-google-chrome-extension"
        };
        if (this.checkString("MSCF") || this.checkString("ISc(")) return {
            ext: "cab",
            mime: "application/vnd.ms-cab-compressed"
        };
        if (this.check([
            0xED,
            0xAB,
            0xEE,
            0xDB
        ])) return {
            ext: "rpm",
            mime: "application/x-rpm"
        };
        if (this.check([
            0xC5,
            0xD0,
            0xD3,
            0xC6
        ])) return {
            ext: "eps",
            mime: "application/eps"
        };
        if (this.check([
            0x28,
            0xB5,
            0x2F,
            0xFD
        ])) return {
            ext: "zst",
            mime: "application/zstd"
        };
        if (this.check([
            0x7F,
            0x45,
            0x4C,
            0x46
        ])) return {
            ext: "elf",
            mime: "application/x-elf"
        };
        if (this.check([
            0x21,
            0x42,
            0x44,
            0x4E
        ])) return {
            ext: "pst",
            mime: "application/vnd.ms-outlook"
        };
        if (this.checkString("PAR1")) return {
            ext: "parquet",
            mime: "application/x-parquet"
        };
        // -- 5-byte signatures --
        if (this.check([
            0x4F,
            0x54,
            0x54,
            0x4F,
            0x00
        ])) return {
            ext: "otf",
            mime: "font/otf"
        };
        if (this.checkString("#!AMR")) return {
            ext: "amr",
            mime: "audio/amr"
        };
        if (this.checkString("{\\rtf")) return {
            ext: "rtf",
            mime: "application/rtf"
        };
        if (this.check([
            0x46,
            0x4C,
            0x56,
            0x01
        ])) return {
            ext: "flv",
            mime: "video/x-flv"
        };
        if (this.checkString("IMPM")) return {
            ext: "it",
            mime: "audio/x-it"
        };
        if (this.checkString("-lh0-", {
            offset: 2
        }) || this.checkString("-lh1-", {
            offset: 2
        }) || this.checkString("-lh2-", {
            offset: 2
        }) || this.checkString("-lh3-", {
            offset: 2
        }) || this.checkString("-lh4-", {
            offset: 2
        }) || this.checkString("-lh5-", {
            offset: 2
        }) || this.checkString("-lh6-", {
            offset: 2
        }) || this.checkString("-lh7-", {
            offset: 2
        }) || this.checkString("-lzs-", {
            offset: 2
        }) || this.checkString("-lz4-", {
            offset: 2
        }) || this.checkString("-lz5-", {
            offset: 2
        }) || this.checkString("-lhd-", {
            offset: 2
        })) return {
            ext: "lzh",
            mime: "application/x-lzh-compressed"
        };
        // MPEG program stream (PS or MPEG-PS)
        if (this.check([
            0x00,
            0x00,
            0x01,
            0xBA
        ])) {
            //  MPEG-PS, MPEG-1 Part 1
            if (this.check([
                0x21
            ], {
                offset: 4,
                mask: [
                    0xF1
                ]
            })) return {
                ext: "mpg",
                mime: "video/MP1S"
            };
            // MPEG-PS, MPEG-2 Part 1
            if (this.check([
                0x44
            ], {
                offset: 4,
                mask: [
                    0xC4
                ]
            })) return {
                ext: "mpg",
                mime: "video/MP2P"
            };
        }
        if (this.checkString("ITSF")) return {
            ext: "chm",
            mime: "application/vnd.ms-htmlhelp"
        };
        if (this.check([
            0xCA,
            0xFE,
            0xBA,
            0xBE
        ])) return {
            ext: "class",
            mime: "application/java-vm"
        };
        // -- 6-byte signatures --
        if (this.check([
            0xFD,
            0x37,
            0x7A,
            0x58,
            0x5A,
            0x00
        ])) return {
            ext: "xz",
            mime: "application/x-xz"
        };
        if (this.checkString("<?xml ")) return {
            ext: "xml",
            mime: "application/xml"
        };
        if (this.check([
            0x37,
            0x7A,
            0xBC,
            0xAF,
            0x27,
            0x1C
        ])) return {
            ext: "7z",
            mime: "application/x-7z-compressed"
        };
        if (this.check([
            0x52,
            0x61,
            0x72,
            0x21,
            0x1A,
            0x7
        ]) && (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)) return {
            ext: "rar",
            mime: "application/x-rar-compressed"
        };
        if (this.checkString("solid ")) return {
            ext: "stl",
            mime: "model/stl"
        };
        if (this.checkString("AC")) {
            const version = this.buffer.toString("binary", 2, 6);
            if (version.match("^d*") && version >= 1000 && version <= 1050) return {
                ext: "dwg",
                mime: "image/vnd.dwg"
            };
        }
        if (this.checkString("070707")) return {
            ext: "cpio",
            mime: "application/x-cpio"
        };
        // -- 7-byte signatures --
        if (this.checkString("BLENDER")) return {
            ext: "blend",
            mime: "application/x-blender"
        };
        if (this.checkString("!<arch>")) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new $28c1768f3e98c2f4$export$2b93044cbf134323(13, "ascii"));
            if (string === "debian-binary") return {
                ext: "deb",
                mime: "application/x-deb"
            };
            return {
                ext: "ar",
                mime: "application/x-unix-archive"
            };
        }
        if (this.checkString("**ACE", {
            offset: 7
        })) {
            await tokenizer.peekBuffer(this.buffer, {
                length: 14,
                mayBeLess: true
            });
            if (this.checkString("**", {
                offset: 12
            })) return {
                ext: "ace",
                mime: "application/x-ace-compressed"
            };
        }
        // -- 8-byte signatures --
        if (this.check([
            0x89,
            0x50,
            0x4E,
            0x47,
            0x0D,
            0x0A,
            0x1A,
            0x0A
        ])) {
            // APNG format (https://wiki.mozilla.org/APNG_Specification)
            // 1. Find the first IDAT (image data) chunk (49 44 41 54)
            // 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)
            // Offset calculated as follows:
            // - 8 bytes: PNG signature
            // - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk
            await tokenizer.ignore(8); // ignore PNG signature
            async function readChunkHeader() {
                return {
                    length: await tokenizer.readToken($28c1768f3e98c2f4$export$8e6095fee2ed4324),
                    type: await tokenizer.readToken(new $28c1768f3e98c2f4$export$2b93044cbf134323(4, "binary"))
                };
            }
            do {
                const chunk = await readChunkHeader();
                if (chunk.length < 0) return; // Invalid chunk length
                switch(chunk.type){
                    case "IDAT":
                        return {
                            ext: "png",
                            mime: "image/png"
                        };
                    case "acTL":
                        return {
                            ext: "apng",
                            mime: "image/apng"
                        };
                    default:
                        await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
                }
            }while (tokenizer.position + 8 < tokenizer.fileInfo.size);
            return {
                ext: "png",
                mime: "image/png"
            };
        }
        if (this.check([
            0x41,
            0x52,
            0x52,
            0x4F,
            0x57,
            0x31,
            0x00,
            0x00
        ])) return {
            ext: "arrow",
            mime: "application/x-apache-arrow"
        };
        if (this.check([
            0x67,
            0x6C,
            0x54,
            0x46,
            0x02,
            0x00,
            0x00,
            0x00
        ])) return {
            ext: "glb",
            mime: "model/gltf-binary"
        };
        // `mov` format variants
        if (this.check([
            0x66,
            0x72,
            0x65,
            0x65
        ], {
            offset: 4
        }) // `free`
         || this.check([
            0x6D,
            0x64,
            0x61,
            0x74
        ], {
            offset: 4
        }) // `mdat` MJPEG
         || this.check([
            0x6D,
            0x6F,
            0x6F,
            0x76
        ], {
            offset: 4
        }) // `moov`
         || this.check([
            0x77,
            0x69,
            0x64,
            0x65
        ], {
            offset: 4
        }) // `wide`
        ) return {
            ext: "mov",
            mime: "video/quicktime"
        };
        // -- 9-byte signatures --
        if (this.check([
            0x49,
            0x49,
            0x52,
            0x4F,
            0x08,
            0x00,
            0x00,
            0x00,
            0x18
        ])) return {
            ext: "orf",
            mime: "image/x-olympus-orf"
        };
        if (this.checkString("gimp xcf ")) return {
            ext: "xcf",
            mime: "image/x-xcf"
        };
        // -- 12-byte signatures --
        if (this.check([
            0x49,
            0x49,
            0x55,
            0x00,
            0x18,
            0x00,
            0x00,
            0x00,
            0x88,
            0xE7,
            0x74,
            0xD8
        ])) return {
            ext: "rw2",
            mime: "image/x-panasonic-rw2"
        };
        // ASF_Header_Object first 80 bytes
        if (this.check([
            0x30,
            0x26,
            0xB2,
            0x75,
            0x8E,
            0x66,
            0xCF,
            0x11,
            0xA6,
            0xD9
        ])) {
            async function readHeader() {
                const guid = (0, $dAk3n$nodebuffer.Buffer).alloc(16);
                await tokenizer.readBuffer(guid);
                return {
                    id: guid,
                    size: Number(await tokenizer.readToken($28c1768f3e98c2f4$export$2a144484d4216c32))
                };
            }
            await tokenizer.ignore(30);
            // Search for header should be in first 1KB of file.
            while(tokenizer.position + 24 < tokenizer.fileInfo.size){
                const header = await readHeader();
                let payload = header.size - 24;
                if ($599ba2eea70127a0$var$_check(header.id, [
                    0x91,
                    0x07,
                    0xDC,
                    0xB7,
                    0xB7,
                    0xA9,
                    0xCF,
                    0x11,
                    0x8E,
                    0xE6,
                    0x00,
                    0xC0,
                    0x0C,
                    0x20,
                    0x53,
                    0x65
                ])) {
                    // Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
                    const typeId = (0, $dAk3n$nodebuffer.Buffer).alloc(16);
                    payload -= await tokenizer.readBuffer(typeId);
                    if ($599ba2eea70127a0$var$_check(typeId, [
                        0x40,
                        0x9E,
                        0x69,
                        0xF8,
                        0x4D,
                        0x5B,
                        0xCF,
                        0x11,
                        0xA8,
                        0xFD,
                        0x00,
                        0x80,
                        0x5F,
                        0x5C,
                        0x44,
                        0x2B
                    ])) // Found audio:
                    return {
                        ext: "asf",
                        mime: "audio/x-ms-asf"
                    };
                    if ($599ba2eea70127a0$var$_check(typeId, [
                        0xC0,
                        0xEF,
                        0x19,
                        0xBC,
                        0x4D,
                        0x5B,
                        0xCF,
                        0x11,
                        0xA8,
                        0xFD,
                        0x00,
                        0x80,
                        0x5F,
                        0x5C,
                        0x44,
                        0x2B
                    ])) // Found video:
                    return {
                        ext: "asf",
                        mime: "video/x-ms-asf"
                    };
                    break;
                }
                await tokenizer.ignore(payload);
            }
            // Default to ASF generic extension
            return {
                ext: "asf",
                mime: "application/vnd.ms-asf"
            };
        }
        if (this.check([
            0xAB,
            0x4B,
            0x54,
            0x58,
            0x20,
            0x31,
            0x31,
            0xBB,
            0x0D,
            0x0A,
            0x1A,
            0x0A
        ])) return {
            ext: "ktx",
            mime: "image/ktx"
        };
        if ((this.check([
            0x7E,
            0x10,
            0x04
        ]) || this.check([
            0x7E,
            0x18,
            0x04
        ])) && this.check([
            0x30,
            0x4D,
            0x49,
            0x45
        ], {
            offset: 4
        })) return {
            ext: "mie",
            mime: "application/x-mie"
        };
        if (this.check([
            0x27,
            0x0A,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00
        ], {
            offset: 2
        })) return {
            ext: "shp",
            mime: "application/x-esri-shape"
        };
        if (this.check([
            0xFF,
            0x4F,
            0xFF,
            0x51
        ])) return {
            ext: "j2c",
            mime: "image/j2c"
        };
        if (this.check([
            0x00,
            0x00,
            0x00,
            0x0C,
            0x6A,
            0x50,
            0x20,
            0x20,
            0x0D,
            0x0A,
            0x87,
            0x0A
        ])) {
            // JPEG-2000 family
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new $28c1768f3e98c2f4$export$2b93044cbf134323(4, "ascii"));
            switch(type){
                case "jp2 ":
                    return {
                        ext: "jp2",
                        mime: "image/jp2"
                    };
                case "jpx ":
                    return {
                        ext: "jpx",
                        mime: "image/jpx"
                    };
                case "jpm ":
                    return {
                        ext: "jpm",
                        mime: "image/jpm"
                    };
                case "mjp2":
                    return {
                        ext: "mj2",
                        mime: "image/mj2"
                    };
                default:
                    return;
            }
        }
        if (this.check([
            0xFF,
            0x0A
        ]) || this.check([
            0x00,
            0x00,
            0x00,
            0x0C,
            0x4A,
            0x58,
            0x4C,
            0x20,
            0x0D,
            0x0A,
            0x87,
            0x0A
        ])) return {
            ext: "jxl",
            mime: "image/jxl"
        };
        if (this.check([
            0xFE,
            0xFF
        ])) {
            if (this.check([
                0,
                60,
                0,
                63,
                0,
                120,
                0,
                109,
                0,
                108
            ], {
                offset: 2
            })) return {
                ext: "xml",
                mime: "application/xml"
            };
            return undefined; // Some unknown text based format
        }
        // -- Unsafe signatures --
        if (this.check([
            0x0,
            0x0,
            0x1,
            0xBA
        ]) || this.check([
            0x0,
            0x0,
            0x1,
            0xB3
        ])) return {
            ext: "mpg",
            mime: "video/mpeg"
        };
        if (this.check([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00
        ])) return {
            ext: "ttf",
            mime: "font/ttf"
        };
        if (this.check([
            0x00,
            0x00,
            0x01,
            0x00
        ])) return {
            ext: "ico",
            mime: "image/x-icon"
        };
        if (this.check([
            0x00,
            0x00,
            0x02,
            0x00
        ])) return {
            ext: "cur",
            mime: "image/x-icon"
        };
        if (this.check([
            0xD0,
            0xCF,
            0x11,
            0xE0,
            0xA1,
            0xB1,
            0x1A,
            0xE1
        ])) // Detected Microsoft Compound File Binary File (MS-CFB) Format.
        return {
            ext: "cfb",
            mime: "application/x-cfb"
        };
        // Increase sample size from 12 to 256.
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(256, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        if (this.check([
            0x61,
            0x63,
            0x73,
            0x70
        ], {
            offset: 36
        })) return {
            ext: "icc",
            mime: "application/vnd.iccprofile"
        };
        // -- 15-byte signatures --
        if (this.checkString("BEGIN:")) {
            if (this.checkString("VCARD", {
                offset: 6
            })) return {
                ext: "vcf",
                mime: "text/vcard"
            };
            if (this.checkString("VCALENDAR", {
                offset: 6
            })) return {
                ext: "ics",
                mime: "text/calendar"
            };
        }
        // `raf` is here just to keep all the raw image detectors together.
        if (this.checkString("FUJIFILMCCD-RAW")) return {
            ext: "raf",
            mime: "image/x-fujifilm-raf"
        };
        if (this.checkString("Extended Module:")) return {
            ext: "xm",
            mime: "audio/x-xm"
        };
        if (this.checkString("Creative Voice File")) return {
            ext: "voc",
            mime: "audio/x-voc"
        };
        if (this.check([
            0x04,
            0x00,
            0x00,
            0x00
        ]) && this.buffer.length >= 16) {
            const jsonSize = this.buffer.readUInt32LE(12);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) try {
                const header = this.buffer.slice(16, jsonSize + 16).toString();
                const json = JSON.parse(header);
                // Check if Pickle is ASAR
                if (json.files) return {
                    ext: "asar",
                    mime: "application/x-asar"
                };
            } catch  {}
        }
        if (this.check([
            0x06,
            0x0E,
            0x2B,
            0x34,
            0x02,
            0x05,
            0x01,
            0x01,
            0x0D,
            0x01,
            0x02,
            0x01,
            0x01,
            0x02
        ])) return {
            ext: "mxf",
            mime: "application/mxf"
        };
        if (this.checkString("SCRM", {
            offset: 44
        })) return {
            ext: "s3m",
            mime: "audio/x-s3m"
        };
        // Raw MPEG-2 transport stream (188-byte packets)
        if (this.check([
            0x47
        ]) && this.check([
            0x47
        ], {
            offset: 188
        })) return {
            ext: "mts",
            mime: "video/mp2t"
        };
        // Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet
        if (this.check([
            0x47
        ], {
            offset: 4
        }) && this.check([
            0x47
        ], {
            offset: 196
        })) return {
            ext: "mts",
            mime: "video/mp2t"
        };
        if (this.check([
            0x42,
            0x4F,
            0x4F,
            0x4B,
            0x4D,
            0x4F,
            0x42,
            0x49
        ], {
            offset: 60
        })) return {
            ext: "mobi",
            mime: "application/x-mobipocket-ebook"
        };
        if (this.check([
            0x44,
            0x49,
            0x43,
            0x4D
        ], {
            offset: 128
        })) return {
            ext: "dcm",
            mime: "application/dicom"
        };
        if (this.check([
            0x4C,
            0x00,
            0x00,
            0x00,
            0x01,
            0x14,
            0x02,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xC0,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x46
        ])) return {
            ext: "lnk",
            mime: "application/x.ms.shortcut"
        };
        if (this.check([
            0x62,
            0x6F,
            0x6F,
            0x6B,
            0x00,
            0x00,
            0x00,
            0x00,
            0x6D,
            0x61,
            0x72,
            0x6B,
            0x00,
            0x00,
            0x00,
            0x00
        ])) return {
            ext: "alias",
            mime: "application/x.apple.alias"
        };
        if (this.check([
            0x4C,
            0x50
        ], {
            offset: 34
        }) && (this.check([
            0x00,
            0x00,
            0x01
        ], {
            offset: 8
        }) || this.check([
            0x01,
            0x00,
            0x02
        ], {
            offset: 8
        }) || this.check([
            0x02,
            0x00,
            0x02
        ], {
            offset: 8
        }))) return {
            ext: "eot",
            mime: "application/vnd.ms-fontobject"
        };
        if (this.check([
            0x06,
            0x06,
            0xED,
            0xF5,
            0xD8,
            0x1D,
            0x46,
            0xE5,
            0xBD,
            0x31,
            0xEF,
            0xE7,
            0xFE,
            0x74,
            0xB7,
            0x1D
        ])) return {
            ext: "indd",
            mime: "application/x-indesign"
        };
        // Increase sample size from 256 to 512
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(512, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        // Requires a buffer size of 512 bytes
        if ((0, $5ffd4575deb4f646$export$4db760af30f3bad5)(this.buffer)) return {
            ext: "tar",
            mime: "application/x-tar"
        };
        if (this.check([
            0xFF,
            0xFE
        ])) {
            if (this.check([
                60,
                0,
                63,
                0,
                120,
                0,
                109,
                0,
                108,
                0
            ], {
                offset: 2
            })) return {
                ext: "xml",
                mime: "application/xml"
            };
            if (this.check([
                0xFF,
                0x0E,
                0x53,
                0x00,
                0x6B,
                0x00,
                0x65,
                0x00,
                0x74,
                0x00,
                0x63,
                0x00,
                0x68,
                0x00,
                0x55,
                0x00,
                0x70,
                0x00,
                0x20,
                0x00,
                0x4D,
                0x00,
                0x6F,
                0x00,
                0x64,
                0x00,
                0x65,
                0x00,
                0x6C,
                0x00
            ], {
                offset: 2
            })) return {
                ext: "skp",
                mime: "application/vnd.sketchup.skp"
            };
            return undefined; // Some text based format
        }
        if (this.checkString("-----BEGIN PGP MESSAGE-----")) return {
            ext: "pgp",
            mime: "application/pgp-encrypted"
        };
        // Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
        if (this.buffer.length >= 2 && this.check([
            0xFF,
            0xE0
        ], {
            offset: 0,
            mask: [
                0xFF,
                0xE0
            ]
        })) {
            if (this.check([
                0x10
            ], {
                offset: 1,
                mask: [
                    0x16
                ]
            })) {
                // Check for (ADTS) MPEG-2
                if (this.check([
                    0x08
                ], {
                    offset: 1,
                    mask: [
                        0x08
                    ]
                })) return {
                    ext: "aac",
                    mime: "audio/aac"
                };
                // Must be (ADTS) MPEG-4
                return {
                    ext: "aac",
                    mime: "audio/aac"
                };
            }
            // MPEG 1 or 2 Layer 3 header
            // Check for MPEG layer 3
            if (this.check([
                0x02
            ], {
                offset: 1,
                mask: [
                    0x06
                ]
            })) return {
                ext: "mp3",
                mime: "audio/mpeg"
            };
            // Check for MPEG layer 2
            if (this.check([
                0x04
            ], {
                offset: 1,
                mask: [
                    0x06
                ]
            })) return {
                ext: "mp2",
                mime: "audio/mpeg"
            };
            // Check for MPEG layer 1
            if (this.check([
                0x06
            ], {
                offset: 1,
                mask: [
                    0x06
                ]
            })) return {
                ext: "mp1",
                mime: "audio/mpeg"
            };
        }
    }
    async readTiffTag(bigEndian) {
        const tagId = await this.tokenizer.readToken(bigEndian ? $28c1768f3e98c2f4$export$42c08c44e3e6155 : $28c1768f3e98c2f4$export$f4321bfdc0492771);
        this.tokenizer.ignore(10);
        switch(tagId){
            case 50341:
                return {
                    ext: "arw",
                    mime: "image/x-sony-arw"
                };
            case 50706:
                return {
                    ext: "dng",
                    mime: "image/x-adobe-dng"
                };
            default:
        }
    }
    async readTiffIFD(bigEndian) {
        const numberOfTags = await this.tokenizer.readToken(bigEndian ? $28c1768f3e98c2f4$export$42c08c44e3e6155 : $28c1768f3e98c2f4$export$f4321bfdc0492771);
        for(let n = 0; n < numberOfTags; ++n){
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) return fileType;
        }
    }
    async readTiffHeader(bigEndian) {
        const version = (bigEndian ? $28c1768f3e98c2f4$export$42c08c44e3e6155 : $28c1768f3e98c2f4$export$f4321bfdc0492771).get(this.buffer, 2);
        const ifdOffset = (bigEndian ? $28c1768f3e98c2f4$export$19165e57e2764f4d : $28c1768f3e98c2f4$export$2e83bc8b95c0add0).get(this.buffer, 4);
        if (version === 42) {
            // TIFF file header
            if (ifdOffset >= 6) {
                if (this.checkString("CR", {
                    offset: 8
                })) return {
                    ext: "cr2",
                    mime: "image/x-canon-cr2"
                };
                if (ifdOffset >= 8 && (this.check([
                    0x1C,
                    0x00,
                    0xFE,
                    0x00
                ], {
                    offset: 8
                }) || this.check([
                    0x1F,
                    0x00,
                    0x0B,
                    0x00
                ], {
                    offset: 8
                }))) return {
                    ext: "nef",
                    mime: "image/x-nikon-nef"
                };
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
                ext: "tif",
                mime: "image/tiff"
            };
        }
        if (version === 43) return {
            ext: "tif",
            mime: "image/tiff"
        };
    }
}

async function $599ba2eea70127a0$export$73037786700eb9a2(readableStream, { sampleSize: sampleSize = $599ba2eea70127a0$var$minimumBytes } = {}) {
    const { default: stream } = await $599ba2eea70127a0$importAsync$7d380268b90fe844;
    return new Promise((resolve, reject)=>{
        readableStream.on("error", reject);
        readableStream.once("readable", ()=>{
            (async ()=>{
                try {
                    // Set up output stream
                    const pass = new stream.PassThrough();
                    const outputStream = stream.pipeline ? stream.pipeline(readableStream, pass, ()=>{}) : readableStream.pipe(pass);
                    // Read the input stream and detect the filetype
                    const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? (0, $dAk3n$nodebuffer.Buffer).alloc(0);
                    try {
                        const fileType = await $599ba2eea70127a0$export$79017d38a9b78817(chunk);
                        pass.fileType = fileType;
                    } catch (error) {
                        if (error instanceof $416665911114e22e$export$f021502591f89f5f) pass.fileType = undefined;
                        else reject(error);
                    }
                    resolve(outputStream);
                } catch (error) {
                    reject(error);
                }
            })();
        });
    });
}
const $599ba2eea70127a0$export$77fa9372f916e938 = new Set((0, $8ad62da59814daff$export$cc3e2d3244e01b7f));
const $599ba2eea70127a0$export$801ca377c02b6fe7 = new Set((0, $8ad62da59814daff$export$53cb456310d1907e));


async function $a47e038a8ae24d95$export$8fe26e8e824489bd(path) {
    const tokenizer = await $b1d1fcc9f4e40f5e$export$90aa898098c12e80(path);
    try {
        return await (0, $599ba2eea70127a0$export$59af0df03c3cfde6)(tokenizer);
    } finally{
        await tokenizer.close();
    }
}


/* eslint-disable no-control-regex */ function $4218705105bc77e3$export$2e2bcd8739ae039() {
    return /[<>:"/\\|?*\u0000-\u001F]/g;
}
function $4218705105bc77e3$export$a0701abe10a1ba48() {
    return /^(con|prn|aux|nul|com\d|lpt\d)$/i;
}


// Doesn't make sense to have longer filenames
const $07f9ea496e66e115$var$MAX_FILENAME_LENGTH = 100;
const $07f9ea496e66e115$var$reRelativePath = /^\.+(\\|\/)|^\.+$/;
const $07f9ea496e66e115$var$reTrailingPeriods = /\.+$/;
function $07f9ea496e66e115$export$2e2bcd8739ae039(string, options = {}) {
    const reControlChars = /[\u0000-\u001F\u0080-\u009F]/g; // eslint-disable-line no-control-regex
    const reRepeatedReservedCharacters = /([<>:"/\\|?*\u0000-\u001F]){2,}/g; // eslint-disable-line no-control-regex
    if (typeof string !== "string") throw new TypeError("Expected a string");
    const replacement = options.replacement === undefined ? "!" : options.replacement;
    if ((0, $4218705105bc77e3$export$2e2bcd8739ae039)().test(replacement) && reControlChars.test(replacement)) throw new Error("Replacement string cannot contain reserved filename characters");
    if (replacement.length > 0) string = string.replace(reRepeatedReservedCharacters, "$1");
    string = string.normalize("NFD");
    string = string.replace($07f9ea496e66e115$var$reRelativePath, replacement);
    string = string.replace((0, $4218705105bc77e3$export$2e2bcd8739ae039)(), replacement);
    string = string.replace(reControlChars, replacement);
    string = string.replace($07f9ea496e66e115$var$reTrailingPeriods, "");
    if (replacement.length > 0) {
        const startedWithDot = string[0] === ".";
        // We removed the whole filename
        if (!startedWithDot && string[0] === ".") string = replacement + string;
        // We removed the whole extension
        if (string[string.length - 1] === ".") string += replacement;
    }
    string = (0, $4218705105bc77e3$export$a0701abe10a1ba48)().test(string) ? string + replacement : string;
    const allowedLength = typeof options.maxLength === "number" ? options.maxLength : $07f9ea496e66e115$var$MAX_FILENAME_LENGTH;
    if (string.length > allowedLength) {
        const extensionIndex = string.lastIndexOf(".");
        if (extensionIndex === -1) string = string.slice(0, allowedLength);
        else {
            const filename = string.slice(0, extensionIndex);
            const extension = string.slice(extensionIndex);
            string = filename.slice(0, Math.max(1, allowedLength - extension.length)) + extension;
        }
    }
    return string;
}




function $a83ee8a5592209a2$export$2e2bcd8739ae039(filePath, options) {
    filePath = (0, ($parcel$interopDefault($dAk3n$nodepath))).resolve(filePath);
    return (0, ($parcel$interopDefault($dAk3n$nodepath))).join((0, ($parcel$interopDefault($dAk3n$nodepath))).dirname(filePath), (0, $07f9ea496e66e115$export$2e2bcd8739ae039)((0, ($parcel$interopDefault($dAk3n$nodepath))).basename(filePath), options));
}










// A hacky check to prevent circular references.
function $eb7b72ed36f102cf$var$isRequest(x) {
    return (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(x) && "_onResponse" in x;
}
class $eb7b72ed36f102cf$export$43ee7d0e4f429743 extends Error {
    constructor(message, error, self){
        super(message);
        Object.defineProperty(this, "input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.code = error.code ?? "ERR_GOT_REQUEST_ERROR";
        this.input = error.input;
        if ($eb7b72ed36f102cf$var$isRequest(self)) {
            Object.defineProperty(this, "request", {
                enumerable: false,
                value: self
            });
            Object.defineProperty(this, "response", {
                enumerable: false,
                value: self.response
            });
            this.options = self.options;
        } else this.options = self;
        this.timings = this.request?.timings;
        // Recover the original stacktrace
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(error.stack) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(this.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
            // Remove duplicated traces
            while(errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0])thisStackTrace.shift();
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
        }
    }
}
class $eb7b72ed36f102cf$export$a34d7acee3cbcf76 extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(request){
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = "MaxRedirectsError";
        this.code = "ERR_TOO_MANY_REDIRECTS";
    }
}
class $eb7b72ed36f102cf$export$aa9d629c530f62a7 extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(response){
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = "HTTPError";
        this.code = "ERR_NON_2XX_3XX_RESPONSE";
    }
}
class $eb7b72ed36f102cf$export$78ff06e91c3de382 extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(error, request){
        super(error.message, error, request);
        this.name = "CacheError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
    }
}
class $eb7b72ed36f102cf$export$137ec66182ed30ea extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(error, request){
        super(error.message, error, request);
        this.name = "UploadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
    }
}
class $eb7b72ed36f102cf$export$66d311bf29d5c89c extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(error, timings, request){
        super(error.message, error, request);
        Object.defineProperty(this, "timings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = "TimeoutError";
        this.event = error.event;
        this.timings = timings;
    }
}
class $eb7b72ed36f102cf$export$e5f2fbba71434b55 extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(error, request){
        super(error.message, error, request);
        this.name = "ReadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
    }
}
class $eb7b72ed36f102cf$export$aa6cf8a4f695f0ee extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(request){
        super("Retrying", {}, request);
        this.name = "RetryError";
        this.code = "ERR_RETRYING";
    }
}
class $eb7b72ed36f102cf$export$18b052ffd8c84d7 extends $eb7b72ed36f102cf$export$43ee7d0e4f429743 {
    constructor(request){
        super("This operation was aborted.", {}, request);
        this.code = "ERR_ABORTED";
        this.name = "AbortError";
    }
}
















function $5c9b7d7cc0740e83$export$2e2bcd8739ae039(body) {
    return (0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_(body.getBoundary);
}


async function $01b960affdc7607c$export$2e2bcd8739ae039(body, headers) {
    if (headers && "content-length" in headers) return Number(headers["content-length"]);
    if (!body) return 0;
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(body)) return (0, $dAk3n$nodebuffer.Buffer).byteLength(body);
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer(body)) return body.length;
    if ((0, $5c9b7d7cc0740e83$export$2e2bcd8739ae039)(body)) return (0, $dAk3n$nodeutil.promisify)(body.getLength.bind(body))();
    return undefined;
}



function $5544ec9d50c16cf0$export$2e2bcd8739ae039(from, to, events) {
    const eventFunctions = {};
    for (const event of events){
        const eventFunction = (...args)=>{
            to.emit(event, ...args);
        };
        eventFunctions[event] = eventFunction;
        from.on(event, eventFunction);
    }
    return ()=>{
        for (const [event, eventFunction] of Object.entries(eventFunctions))from.off(event, eventFunction);
    };
}



// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
function $7d47fab402b20193$export$2e2bcd8739ae039() {
    const handlers = [];
    return {
        once (origin, event, fn) {
            origin.once(event, fn);
            handlers.push({
                origin: origin,
                event: event,
                fn: fn
            });
        },
        unhandleAll () {
            for (const handler of handlers){
                const { origin: origin, event: event, fn: fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
}


const $0360f33952b6355d$var$reentry = Symbol("reentry");
const $0360f33952b6355d$var$noop = ()=>{};
class $0360f33952b6355d$export$66d311bf29d5c89c extends Error {
    constructor(threshold, event){
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: event
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
    }
}
function $0360f33952b6355d$export$2e2bcd8739ae039(request, delays, options) {
    if ($0360f33952b6355d$var$reentry in request) return $0360f33952b6355d$var$noop;
    request[$0360f33952b6355d$var$reentry] = true;
    const cancelers = [];
    const { once: once, unhandleAll: unhandleAll } = (0, $7d47fab402b20193$export$2e2bcd8739ae039)();
    const addTimeout = (delay, callback, event)=>{
        const timeout = setTimeout(callback, delay, delay, event);
        timeout.unref?.();
        const cancel = ()=>{
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host: host, hostname: hostname } = options;
    const timeoutHandler = (delay, event)=>{
        request.destroy(new $0360f33952b6355d$export$66d311bf29d5c89c(delay, event));
    };
    const cancelTimeouts = ()=>{
        for (const cancel of cancelers)cancel();
        unhandleAll();
    };
    request.once("error", (error)=>{
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */ if (request.listenerCount("error") === 0) throw error;
    });
    if (delays.request !== undefined) {
        const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
        once(request, "response", (response)=>{
            once(response, "end", cancelTimeout);
        });
    }
    if (delays.socket !== undefined) {
        const { socket: socket } = delays;
        const socketTimeoutHandler = ()=>{
            timeoutHandler(socket, "socket");
        };
        request.setTimeout(socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(()=>{
            request.removeListener("timeout", socketTimeoutHandler);
        });
    }
    const hasLookup = delays.lookup !== undefined;
    const hasConnect = delays.connect !== undefined;
    const hasSecureConnect = delays.secureConnect !== undefined;
    const hasSend = delays.send !== undefined;
    if (hasLookup || hasConnect || hasSecureConnect || hasSend) once(request, "socket", (socket)=>{
        const { socketPath: socketPath } = request;
        /* istanbul ignore next: hard to test */ if (socket.connecting) {
            const hasPath = Boolean(socketPath ?? (0, ($parcel$interopDefault($dAk3n$nodenet))).isIP(hostname ?? host ?? "") !== 0);
            if (hasLookup && !hasPath && socket.address().address === undefined) {
                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
                once(socket, "lookup", cancelTimeout);
            }
            if (hasConnect) {
                const timeConnect = ()=>addTimeout(delays.connect, timeoutHandler, "connect");
                if (hasPath) once(socket, "connect", timeConnect());
                else once(socket, "lookup", (error)=>{
                    if (error === null) once(socket, "connect", timeConnect());
                });
            }
            if (hasSecureConnect && options.protocol === "https:") once(socket, "connect", ()=>{
                const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
                once(socket, "secureConnect", cancelTimeout);
            });
        }
        if (hasSend) {
            const timeRequest = ()=>addTimeout(delays.send, timeoutHandler, "send");
            /* istanbul ignore next: hard to test */ if (socket.connecting) once(socket, "connect", ()=>{
                once(request, "upload-complete", timeRequest());
            });
            else once(request, "upload-complete", timeRequest());
        }
    });
    if (delays.response !== undefined) once(request, "upload-complete", ()=>{
        const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
        once(request, "response", cancelTimeout);
    });
    if (delays.read !== undefined) once(request, "response", (response)=>{
        const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
        once(response, "end", cancelTimeout);
    });
    return cancelTimeouts;
}



function $f8c7ea3bb4e89994$export$2e2bcd8739ae039(url) {
    url;
    const options = {
        protocol: url.protocol,
        hostname: (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(url.port) && url.port.length > 0) options.port = Number(url.port);
    if (url.username || url.password) options.auth = `${url.username || ""}:${url.password || ""}`;
    return options;
}


class $9da833297e37ffc5$export$2e2bcd8739ae039 {
    constructor(){
        Object.defineProperty(this, "weakMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "map", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === "object") this.weakMap.set(key, value);
        else this.map.set(key, value);
    }
    get(key) {
        if (typeof key === "object") return this.weakMap.get(key);
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === "object") return this.weakMap.has(key);
        return this.map.has(key);
    }
}


const $b082cfcb422c7190$var$calculateRetryDelay = ({ attemptCount: attemptCount, retryOptions: retryOptions, error: error, retryAfter: retryAfter, computedValue: computedValue })=>{
    if (error.name === "RetryError") return 1;
    if (attemptCount > retryOptions.limit) return 0;
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || !hasErrorCode && !hasStatusCode) return 0;
    if (error.response) {
        if (retryAfter) {
            // In this case `computedValue` is `options.request.timeout`
            if (retryAfter > computedValue) return 0;
            return retryAfter;
        }
        if (error.response.statusCode === 413) return 0;
    }
    const noise = Math.random() * retryOptions.noise;
    return Math.min(2 ** (attemptCount - 1) * 1000, retryOptions.backoffLimit) + noise;
};
var $b082cfcb422c7190$export$2e2bcd8739ae039 = $b082cfcb422c7190$var$calculateRetryDelay;












function $d9861b895e6c8d59$export$2e2bcd8739ae039(link) {
    const parsed = [];
    const items = link.split(",");
    for (const item of items){
        // https://tools.ietf.org/html/rfc5988#section-5
        const [rawUriReference, ...rawLinkParameters] = item.split(";");
        const trimmedUriReference = rawUriReference.trim();
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        if (trimmedUriReference[0] !== "<" || trimmedUriReference[trimmedUriReference.length - 1] !== ">") throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
        const reference = trimmedUriReference.slice(1, -1);
        const parameters = {};
        if (rawLinkParameters.length === 0) throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
        for (const rawParameter of rawLinkParameters){
            const trimmedRawParameter = rawParameter.trim();
            const center = trimmedRawParameter.indexOf("=");
            if (center === -1) throw new Error(`Failed to parse Link header: ${link}`);
            const name = trimmedRawParameter.slice(0, center).trim();
            const value = trimmedRawParameter.slice(center + 1).trim();
            parameters[name] = value;
        }
        parsed.push({
            reference: reference,
            parameters: parameters
        });
    }
    return parsed;
}


const [$87f98181f8a9fce4$var$major, $87f98181f8a9fce4$var$minor] = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).versions.node.split(".").map(Number);
function $87f98181f8a9fce4$var$validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for(const key in searchParameters){
        const value = searchParameters[key];
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).null_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
    }
}
const $87f98181f8a9fce4$var$globalCache = new Map();
let $87f98181f8a9fce4$var$globalDnsCache;
const $87f98181f8a9fce4$var$getGlobalDnsCache = ()=>{
    if ($87f98181f8a9fce4$var$globalDnsCache) return $87f98181f8a9fce4$var$globalDnsCache;
    $87f98181f8a9fce4$var$globalDnsCache = new (0, $c3c5a2a4f023bf43$export$2e2bcd8739ae039)();
    return $87f98181f8a9fce4$var$globalDnsCache;
};
const $87f98181f8a9fce4$var$defaultInternals = {
    request: undefined,
    agent: {
        http: undefined,
        https: undefined,
        http2: undefined
    },
    h2session: undefined,
    decompress: true,
    timeout: {
        connect: undefined,
        lookup: undefined,
        read: undefined,
        request: undefined,
        response: undefined,
        secureConnect: undefined,
        send: undefined,
        socket: undefined
    },
    prefixUrl: "",
    body: undefined,
    form: undefined,
    json: undefined,
    cookieJar: undefined,
    ignoreInvalidCookies: false,
    searchParams: undefined,
    dnsLookup: undefined,
    dnsCache: undefined,
    context: {},
    hooks: {
        init: [],
        beforeRequest: [],
        beforeError: [],
        beforeRedirect: [],
        beforeRetry: [],
        afterResponse: []
    },
    followRedirect: true,
    maxRedirects: 10,
    cache: undefined,
    throwHttpErrors: true,
    username: "",
    password: "",
    http2: false,
    allowGetBody: false,
    headers: {
        "user-agent": "got (https://github.com/sindresorhus/got)"
    },
    methodRewriting: false,
    dnsLookupIpVersion: undefined,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
        limit: 2,
        methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
        ],
        statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
        ],
        errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
        ],
        maxRetryAfter: undefined,
        calculateDelay: ({ computedValue: computedValue })=>computedValue,
        backoffLimit: Number.POSITIVE_INFINITY,
        noise: 100
    },
    localAddress: undefined,
    method: "GET",
    createConnection: undefined,
    cacheOptions: {
        shared: undefined,
        cacheHeuristic: undefined,
        immutableMinTimeToLive: undefined,
        ignoreCargoCult: undefined
    },
    https: {
        alpnProtocols: undefined,
        rejectUnauthorized: undefined,
        checkServerIdentity: undefined,
        certificateAuthority: undefined,
        key: undefined,
        certificate: undefined,
        passphrase: undefined,
        pfx: undefined,
        ciphers: undefined,
        honorCipherOrder: undefined,
        minVersion: undefined,
        maxVersion: undefined,
        signatureAlgorithms: undefined,
        tlsSessionLifetime: undefined,
        dhparam: undefined,
        ecdhCurve: undefined,
        certificateRevocationLists: undefined
    },
    encoding: undefined,
    resolveBodyOnly: false,
    isStream: false,
    responseType: "text",
    url: undefined,
    pagination: {
        transform (response) {
            if (response.request.options.responseType === "json") return response.body;
            return JSON.parse(response.body);
        },
        paginate ({ response: response }) {
            const rawLinkHeader = response.headers.link;
            if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") return false;
            const parsed = (0, $d9861b895e6c8d59$export$2e2bcd8739ae039)(rawLinkHeader);
            const next = parsed.find((entry)=>entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
            if (next) return {
                url: new URL(next.reference, response.url)
            };
            return false;
        },
        filter: ()=>true,
        shouldContinue: ()=>true,
        countLimit: Number.POSITIVE_INFINITY,
        backoff: 0,
        requestLimit: 10000,
        stackAllItems: false
    },
    setHost: true,
    maxHeaderSize: undefined,
    signal: undefined,
    enableUnixSockets: false
};
const $87f98181f8a9fce4$var$cloneInternals = (internals)=>{
    const { hooks: hooks, retry: retry } = internals;
    const result = {
        ...internals,
        context: {
            ...internals.context
        },
        cacheOptions: {
            ...internals.cacheOptions
        },
        https: {
            ...internals.https
        },
        agent: {
            ...internals.agent
        },
        headers: {
            ...internals.headers
        },
        retry: {
            ...retry,
            errorCodes: [
                ...retry.errorCodes
            ],
            methods: [
                ...retry.methods
            ],
            statusCodes: [
                ...retry.statusCodes
            ]
        },
        timeout: {
            ...internals.timeout
        },
        hooks: {
            init: [
                ...hooks.init
            ],
            beforeRequest: [
                ...hooks.beforeRequest
            ],
            beforeError: [
                ...hooks.beforeError
            ],
            beforeRedirect: [
                ...hooks.beforeRedirect
            ],
            beforeRetry: [
                ...hooks.beforeRetry
            ],
            afterResponse: [
                ...hooks.afterResponse
            ]
        },
        searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : undefined,
        pagination: {
            ...internals.pagination
        }
    };
    if (result.url !== undefined) result.prefixUrl = "";
    return result;
};
const $87f98181f8a9fce4$var$cloneRaw = (raw)=>{
    const { hooks: hooks, retry: retry } = raw;
    const result = {
        ...raw
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.context)) result.context = {
        ...raw.context
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.cacheOptions)) result.cacheOptions = {
        ...raw.cacheOptions
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.https)) result.https = {
        ...raw.https
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.cacheOptions)) result.cacheOptions = {
        ...result.cacheOptions
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.agent)) result.agent = {
        ...raw.agent
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.headers)) result.headers = {
        ...raw.headers
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(retry)) {
        result.retry = {
            ...retry
        };
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(retry.errorCodes)) result.retry.errorCodes = [
            ...retry.errorCodes
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(retry.methods)) result.retry.methods = [
            ...retry.methods
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(retry.statusCodes)) result.retry.statusCodes = [
            ...retry.statusCodes
        ];
    }
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.timeout)) result.timeout = {
        ...raw.timeout
    };
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(hooks)) {
        result.hooks = {
            ...hooks
        };
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.init)) result.hooks.init = [
            ...hooks.init
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeRequest)) result.hooks.beforeRequest = [
            ...hooks.beforeRequest
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeError)) result.hooks.beforeError = [
            ...hooks.beforeError
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeRedirect)) result.hooks.beforeRedirect = [
            ...hooks.beforeRedirect
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.beforeRetry)) result.hooks.beforeRetry = [
            ...hooks.beforeRetry
        ];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(hooks.afterResponse)) result.hooks.afterResponse = [
            ...hooks.afterResponse
        ];
    }
    // TODO: raw.searchParams
    if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(raw.pagination)) result.pagination = {
        ...raw.pagination
    };
    return result;
};
const $87f98181f8a9fce4$var$getHttp2TimeoutOption = (internals)=>{
    const delays = [
        internals.timeout.socket,
        internals.timeout.connect,
        internals.timeout.lookup,
        internals.timeout.request,
        internals.timeout.secureConnect
    ].filter((delay)=>typeof delay === "number");
    if (delays.length > 0) return Math.min(...delays);
    return undefined;
};
const $87f98181f8a9fce4$var$init = (options, withOptions, self)=>{
    const initHooks = options.hooks?.init;
    if (initHooks) for (const hook of initHooks)hook(withOptions, self);
};
class $87f98181f8a9fce4$export$2e2bcd8739ae039 {
    constructor(input, options, defaults){
        Object.defineProperty(this, "_unixOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_internals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_merging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_init", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], input);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], options);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], defaults);
        if (input instanceof $87f98181f8a9fce4$export$2e2bcd8739ae039 || options instanceof $87f98181f8a9fce4$export$2e2bcd8739ae039) throw new TypeError("The defaults must be passed as the third argument");
        this._internals = $87f98181f8a9fce4$var$cloneInternals(defaults?._internals ?? defaults ?? $87f98181f8a9fce4$var$defaultInternals);
        this._init = [
            ...defaults?._init ?? []
        ];
        this._merging = false;
        this._unixOptions = undefined;
        // This rule allows `finally` to be considered more important.
        // Meaning no matter the error thrown in the `try` block,
        // if `finally` throws then the `finally` error will be thrown.
        //
        // Yes, we want this. If we set `url` first, then the `url.searchParams`
        // would get merged. Instead we set the `searchParams` first, then
        // `url.searchParams` is overwritten as expected.
        //
        /* eslint-disable no-unsafe-finally */ try {
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).plainObject(input)) try {
                this.merge(input);
                this.merge(options);
            } finally{
                this.url = input.url;
            }
            else try {
                this.merge(options);
            } finally{
                if (options?.url !== undefined) {
                    if (input === undefined) this.url = options.url;
                    else throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
                } else if (input !== undefined) this.url = input;
            }
        } catch (error) {
            error.options = this;
            throw error;
        }
    /* eslint-enable no-unsafe-finally */ }
    merge(options) {
        if (!options) return;
        if (options instanceof $87f98181f8a9fce4$export$2e2bcd8739ae039) {
            for (const init of options._init)this.merge(init);
            return;
        }
        options = $87f98181f8a9fce4$var$cloneRaw(options);
        $87f98181f8a9fce4$var$init(this, options, this);
        $87f98181f8a9fce4$var$init(options, options, this);
        this._merging = true;
        // Always merge `isStream` first
        if ("isStream" in options) this.isStream = options.isStream;
        try {
            let push = false;
            for(const key in options){
                // `got.extend()` options
                if (key === "mutableDefaults" || key === "handlers") continue;
                // Never merge `url`
                if (key === "url") continue;
                if (!(key in this)) throw new Error(`Unexpected option: ${key}`);
                // @ts-expect-error Type 'unknown' is not assignable to type 'never'.
                const value = options[key];
                if (value === undefined) continue;
                // @ts-expect-error Type 'unknown' is not assignable to type 'never'.
                this[key] = value;
                push = true;
            }
            if (push) this._init.push(options);
        } finally{
            this._merging = false;
        }
    }
    /**
    Custom request function.
    The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).

    @default http.request | https.request
    */ get request() {
        return this._internals.request;
    }
    set request(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.request = value;
    }
    /**
    An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
    This is necessary because a request to one protocol might redirect to another.
    In such a scenario, Got will switch over to the right protocol agent for you.

    If a key is not present, it will default to a global agent.

    @example
    ```
    import got from 'got';
    import HttpAgent from 'agentkeepalive';

    const {HttpsAgent} = HttpAgent;

    await got('https://sindresorhus.com', {
        agent: {
            http: new HttpAgent(),
            https: new HttpsAgent()
        }
    });
    ```
    */ get agent() {
        return this._internals.agent;
    }
    set agent(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        // eslint-disable-next-line guard-for-in
        for(const key in value){
            if (!(key in this._internals.agent)) throw new TypeError(`Unexpected agent option: ${key}`);
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
            ], value[key]);
        }
        if (this._merging) Object.assign(this._internals.agent, value);
        else this._internals.agent = {
            ...value
        };
    }
    get h2session() {
        return this._internals.h2session;
    }
    set h2session(value) {
        this._internals.h2session = value;
    }
    /**
    Decompress the response automatically.

    This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.

    If this is disabled, a compressed response is returned as a `Buffer`.
    This may be useful if you want to handle decompression yourself or stream the raw compressed data.

    @default true
    */ get decompress() {
        return this._internals.decompress;
    }
    set decompress(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.decompress = value;
    }
    /**
    Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
    By default, there's no timeout.

    This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:

    - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
        Does not apply when using a Unix domain socket.
    - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
    - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
    - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
    - `response` starts when the request has been written to the socket and ends when the response headers are received.
    - `send` starts when the socket is connected and ends with the request has been written to the socket.
    - `request` starts when the request is initiated and ends when the response's end event fires.
    */ get timeout() {
        // We always return `Delays` here.
        // It has to be `Delays | number`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.timeout;
    }
    set timeout(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        // eslint-disable-next-line guard-for-in
        for(const key in value){
            if (!(key in this._internals.timeout)) throw new Error(`Unexpected timeout option: ${key}`);
            // @ts-expect-error - No idea why `value[key]` doesn't work here.
            (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
            ], value[key]);
        }
        if (this._merging) Object.assign(this._internals.timeout, value);
        else this._internals.timeout = {
            ...value
        };
    }
    /**
    When specified, `prefixUrl` will be prepended to `url`.
    The prefix can be any valid URL, either relative or absolute.
    A trailing slash `/` is optional - one will be added automatically.

    __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.

    __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
    For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
    The latter is used by browsers.

    __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.

    __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
    If the URL doesn't include it anymore, it will throw.

    @example
    ```
    import got from 'got';

    await got('unicorn', {prefixUrl: 'https://cats.com'});
    //=> 'https://cats.com/unicorn'

    const instance = got.extend({
        prefixUrl: 'https://google.com'
    });

    await instance('unicorn', {
        hooks: {
            beforeRequest: [
                options => {
                    options.prefixUrl = 'https://cats.com';
                }
            ]
        }
    });
    //=> 'https://cats.com/unicorn'
    ```
    */ get prefixUrl() {
        // We always return `string` here.
        // It has to be `string | URL`, otherwise TypeScript will error because the getter and the setter have incompatible types.
        return this._internals.prefixUrl;
    }
    set prefixUrl(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance
        ], value);
        if (value === "") {
            this._internals.prefixUrl = "";
            return;
        }
        value = value.toString();
        if (!value.endsWith("/")) value += "/";
        if (this._internals.prefixUrl && this._internals.url) {
            const { href: href } = this._internals.url;
            this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
        }
        this._internals.prefixUrl = value;
    }
    /**
    __Note #1__: The `body` option cannot be used with the `json` or `form` option.

    __Note #2__: If you provide this option, `got.stream()` will be read-only.

    __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.

    __Note #4__: This option is not enumerable and will not be merged with the instance defaults.

    The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.

    Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
    */ get body() {
        return this._internals.body;
    }
    set body(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).generator,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).asyncGenerator,
            (0, $3217e51b94272cab$export$67a42df2b7ab73bc),
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(value)) (0, $23048e7f833b5d93$export$a7a9523472993e97).truthy(value.readable);
        if (value !== undefined) {
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.form);
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.json);
        }
        this._internals.body = value;
    }
    /**
    The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).

    If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */ get form() {
        return this._internals.form;
    }
    set form(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).plainObject,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value !== undefined) {
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.body);
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.json);
        }
        this._internals.form = value;
    }
    /**
    JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.

    __Note #1__: If you provide this option, `got.stream()` will be read-only.

    __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
    */ get json() {
        return this._internals.json;
    }
    set json(value) {
        if (value !== undefined) {
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.body);
            (0, $23048e7f833b5d93$export$a7a9523472993e97).undefined(this._internals.form);
        }
        this._internals.json = value;
    }
    /**
    The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).

    Properties from `options` will override properties in the parsed `url`.

    If no protocol is specified, it will throw a `TypeError`.

    __Note__: The query string is **not** parsed as search params.

    @example
    ```
    await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
    await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b

    // The query string is overridden by `searchParams`
    await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
    ```
    */ get url() {
        return this._internals.url;
    }
    set url(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === undefined) {
            this._internals.url = undefined;
            return;
        }
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(value) && value.startsWith("/")) throw new Error("`url` must not start with a slash");
        const urlString = `${this.prefixUrl}${value.toString()}`;
        const url = new URL(urlString);
        this._internals.url = url;
        if (url.protocol === "unix:") url.href = `http://unix${url.pathname}${url.search}`;
        if (url.protocol !== "http:" && url.protocol !== "https:") {
            const error = new Error(`Unsupported protocol: ${url.protocol}`);
            error.code = "ERR_UNSUPPORTED_PROTOCOL";
            throw error;
        }
        if (this._internals.username) {
            url.username = this._internals.username;
            this._internals.username = "";
        }
        if (this._internals.password) {
            url.password = this._internals.password;
            this._internals.password = "";
        }
        if (this._internals.searchParams) {
            url.search = this._internals.searchParams.toString();
            this._internals.searchParams = undefined;
        }
        if (url.hostname === "unix") {
            if (!this._internals.enableUnixSockets) throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches?.groups) {
                const { socketPath: socketPath, path: path } = matches.groups;
                this._unixOptions = {
                    socketPath: socketPath,
                    path: path,
                    host: ""
                };
            } else this._unixOptions = undefined;
            return;
        }
        this._unixOptions = undefined;
    }
    /**
    Cookie support. You don't have to care about parsing or how to store them.

    __Note__: If you provide this option, `options.headers.cookie` will be overridden.
    */ get cookieJar() {
        return this._internals.cookieJar;
    }
    set cookieJar(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === undefined) {
            this._internals.cookieJar = undefined;
            return;
        }
        let { setCookie: setCookie, getCookieString: getCookieString } = value;
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(setCookie);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(getCookieString);
        /* istanbul ignore next: Horrible `tough-cookie` v3 check */ if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = (0, $dAk3n$nodeutil.promisify)(setCookie.bind(value));
            getCookieString = (0, $dAk3n$nodeutil.promisify)(getCookieString.bind(value));
            this._internals.cookieJar = {
                setCookie: setCookie,
                getCookieString: getCookieString
            };
        } else this._internals.cookieJar = value;
    }
    /**
    You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).

    @example
    ```
    import got from 'got';

    const abortController = new AbortController();

    const request = got('https://httpbin.org/anything', {
        signal: abortController.signal
    });

    setTimeout(() => {
        abortController.abort();
    }, 100);
    ```
    */ get signal() {
        return this._internals.signal;
    }
    set signal(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        this._internals.signal = value;
    }
    /**
    Ignore invalid cookies instead of throwing an error.
    Only useful when the `cookieJar` option has been set. Not recommended.

    @default false
    */ get ignoreInvalidCookies() {
        return this._internals.ignoreInvalidCookies;
    }
    set ignoreInvalidCookies(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.ignoreInvalidCookies = value;
    }
    /**
    Query string that will be added to the request URL.
    This will override the query string in `url`.

    If you need to pass in an array, you can do it using a `URLSearchParams` instance.

    @example
    ```
    import got from 'got';

    const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);

    await got('https://example.com', {searchParams});

    console.log(searchParams.toString());
    //=> 'key=a&key=b'
    ```
    */ get searchParams() {
        if (this._internals.url) return this._internals.url.searchParams;
        if (this._internals.searchParams === undefined) this._internals.searchParams = new URLSearchParams();
        return this._internals.searchParams;
    }
    set searchParams(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        const url = this._internals.url;
        if (value === undefined) {
            this._internals.searchParams = undefined;
            if (url) url.search = "";
            return;
        }
        const searchParameters = this.searchParams;
        let updated;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(value)) updated = new URLSearchParams(value);
        else if (value instanceof URLSearchParams) updated = value;
        else {
            $87f98181f8a9fce4$var$validateSearchParameters(value);
            updated = new URLSearchParams();
            // eslint-disable-next-line guard-for-in
            for(const key in value){
                const entry = value[key];
                if (entry === null) updated.append(key, "");
                else if (entry === undefined) searchParameters.delete(key);
                else updated.append(key, entry);
            }
        }
        if (this._merging) {
            // These keys will be replaced
            for (const key of updated.keys())searchParameters.delete(key);
            for (const [key, value] of updated)searchParameters.append(key, value);
        } else if (url) url.search = searchParameters.toString();
        else this._internals.searchParams = searchParameters;
    }
    get searchParameters() {
        throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    set searchParameters(_value) {
        throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    get dnsLookup() {
        return this._internals.dnsLookup;
    }
    set dnsLookup(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.dnsLookup = value;
    }
    /**
    An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
    Useful when making lots of requests to different *public* hostnames.

    `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.

    __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.

    @default false
    */ get dnsCache() {
        return this._internals.dnsCache;
    }
    set dnsCache(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === true) this._internals.dnsCache = $87f98181f8a9fce4$var$getGlobalDnsCache();
        else if (value === false) this._internals.dnsCache = undefined;
        else this._internals.dnsCache = value;
    }
    /**
    User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.

    @example
    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            beforeRequest: [
                options => {
                    if (!options.context || !options.context.token) {
                        throw new Error('Token required');
                    }

                    options.headers.token = options.context.token;
                }
            ]
        }
    });

    const context = {
        token: 'secret'
    };

    const response = await instance('https://httpbin.org/headers', {context});

    // Let's see the headers
    console.log(response.body);
    ```
    */ get context() {
        return this._internals.context;
    }
    set context(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        if (this._merging) Object.assign(this._internals.context, value);
        else this._internals.context = {
            ...value
        };
    }
    /**
    Hooks allow modifications during the request lifecycle.
    Hook functions may be async and are run serially.
    */ get hooks() {
        return this._internals.hooks;
    }
    set hooks(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        // eslint-disable-next-line guard-for-in
        for(const knownHookEvent in value){
            if (!(knownHookEvent in this._internals.hooks)) throw new Error(`Unexpected hook event: ${knownHookEvent}`);
            const typedKnownHookEvent = knownHookEvent;
            const hooks = value[typedKnownHookEvent];
            (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
                (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
            ], hooks);
            if (hooks) for (const hook of hooks)(0, $23048e7f833b5d93$export$a7a9523472993e97).function_(hook);
            if (this._merging) {
                if (hooks) // @ts-expect-error FIXME
                this._internals.hooks[typedKnownHookEvent].push(...hooks);
            } else {
                if (!hooks) throw new Error(`Missing hook event: ${knownHookEvent}`);
                // @ts-expect-error FIXME
                this._internals.hooks[knownHookEvent] = [
                    ...hooks
                ];
            }
        }
    }
    /**
    Defines if redirect responses should be followed automatically.

    Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
    This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.

    @default true
    */ get followRedirect() {
        return this._internals.followRedirect;
    }
    set followRedirect(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.followRedirect = value;
    }
    get followRedirects() {
        throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    set followRedirects(_value) {
        throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    /**
    If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.

    @default 10
    */ get maxRedirects() {
        return this._internals.maxRedirects;
    }
    set maxRedirects(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(value);
        this._internals.maxRedirects = value;
    }
    /**
    A cache adapter instance for storing cached response data.

    @default false
    */ get cache() {
        return this._internals.cache;
    }
    set cache(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        if (value === true) this._internals.cache = $87f98181f8a9fce4$var$globalCache;
        else if (value === false) this._internals.cache = undefined;
        else this._internals.cache = value;
    }
    /**
    Determines if a `got.HTTPError` is thrown for unsuccessful responses.

    If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
    This may be useful if you are checking for resource availability and are expecting error responses.

    @default true
    */ get throwHttpErrors() {
        return this._internals.throwHttpErrors;
    }
    set throwHttpErrors(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.throwHttpErrors = value;
    }
    get username() {
        const url = this._internals.url;
        const value = url ? url.username : this._internals.username;
        return decodeURIComponent(value);
    }
    set username(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) url.username = fixedValue;
        else this._internals.username = fixedValue;
    }
    get password() {
        const url = this._internals.url;
        const value = url ? url.password : this._internals.password;
        return decodeURIComponent(value);
    }
    set password(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).string(value);
        const url = this._internals.url;
        const fixedValue = encodeURIComponent(value);
        if (url) url.password = fixedValue;
        else this._internals.password = fixedValue;
    }
    /**
    If set to `true`, Got will additionally accept HTTP2 requests.

    It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.

    __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.

    __Note__: Overriding `options.request` will disable HTTP2 support.

    @default false

    @example
    ```
    import got from 'got';

    const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});

    console.log(headers.via);
    //=> '2 nghttpx'
    ```
    */ get http2() {
        return this._internals.http2;
    }
    set http2(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.http2 = value;
    }
    /**
    Set this to `true` to allow sending body for the `GET` method.
    However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
    This option is only meant to interact with non-compliant servers when you have no other choice.

    __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.

    @default false
    */ get allowGetBody() {
        return this._internals.allowGetBody;
    }
    set allowGetBody(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.allowGetBody = value;
    }
    /**
    Request headers.

    Existing headers will be overwritten. Headers set to `undefined` will be omitted.

    @default {}
    */ get headers() {
        return this._internals.headers;
    }
    set headers(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        if (this._merging) Object.assign(this._internals.headers, (0, $cc1220db54f967ea$export$2e2bcd8739ae039)(value));
        else this._internals.headers = (0, $cc1220db54f967ea$export$2e2bcd8739ae039)(value);
    }
    /**
    Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.

    As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
    Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.

    __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).

    @default false
    */ get methodRewriting() {
        return this._internals.methodRewriting;
    }
    set methodRewriting(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.methodRewriting = value;
    }
    /**
    Indicates which DNS record family to use.

    Values:
    - `undefined`: IPv4 (if present) or IPv6
    - `4`: Only IPv4
    - `6`: Only IPv6

    @default undefined
    */ get dnsLookupIpVersion() {
        return this._internals.dnsLookupIpVersion;
    }
    set dnsLookupIpVersion(value) {
        if (value !== undefined && value !== 4 && value !== 6) throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
        this._internals.dnsLookupIpVersion = value;
    }
    /**
    A function used to parse JSON responses.

    @example
    ```
    import got from 'got';
    import Bourne from '@hapi/bourne';

    const parsed = await got('https://example.com', {
        parseJson: text => Bourne.parse(text)
    }).json();

    console.log(parsed);
    ```
    */ get parseJson() {
        return this._internals.parseJson;
    }
    set parseJson(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(value);
        this._internals.parseJson = value;
    }
    /**
    A function used to stringify the body of JSON requests.

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (key.startsWith('_')) {
                return;
            }

            return value;
        }),
        json: {
            some: 'payload',
            _ignoreMe: 1234
        }
    });
    ```

    @example
    ```
    import got from 'got';

    await got.post('https://example.com', {
        stringifyJson: object => JSON.stringify(object, (key, value) => {
            if (typeof value === 'number') {
                return value.toString();
            }

            return value;
        }),
        json: {
            some: 'payload',
            number: 1
        }
    });
    ```
    */ get stringifyJson() {
        return this._internals.stringifyJson;
    }
    set stringifyJson(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(value);
        this._internals.stringifyJson = value;
    }
    /**
    An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.

    Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).

    The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
    The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).

    By default, it retries *only* on the specified methods, status codes, and on these network errors:

    - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
    - `ECONNRESET`: Connection was forcibly closed by a peer.
    - `EADDRINUSE`: Could not bind to any free port.
    - `ECONNREFUSED`: Connection was refused by the server.
    - `EPIPE`: The remote side of the stream being written has been closed.
    - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
    - `ENETUNREACH`: No internet connection.
    - `EAI_AGAIN`: DNS lookup timed out.

    __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
    __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
    */ get retry() {
        return this._internals.retry;
    }
    set retry(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.calculateDelay);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.maxRetryAfter);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.limit);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.methods);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.statusCodes);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.errorCodes);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.noise);
        if (value.noise && Math.abs(value.noise) > 100) throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
        for(const key in value){
            if (!(key in this._internals.retry)) throw new Error(`Unexpected retry option: ${key}`);
        }
        if (this._merging) Object.assign(this._internals.retry, value);
        else this._internals.retry = {
            ...value
        };
        const { retry: retry } = this._internals;
        retry.methods = [
            ...new Set(retry.methods.map((method)=>method.toUpperCase()))
        ];
        retry.statusCodes = [
            ...new Set(retry.statusCodes)
        ];
        retry.errorCodes = [
            ...new Set(retry.errorCodes)
        ];
    }
    /**
    From `http.RequestOptions`.

    The IP address used to send the request from.
    */ get localAddress() {
        return this._internals.localAddress;
    }
    set localAddress(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.localAddress = value;
    }
    /**
    The HTTP method used to make the request.

    @default 'GET'
    */ get method() {
        return this._internals.method;
    }
    set method(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).string(value);
        this._internals.method = value.toUpperCase();
    }
    get createConnection() {
        return this._internals.createConnection;
    }
    set createConnection(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.createConnection = value;
    }
    /**
    From `http-cache-semantics`

    @default {}
    */ get cacheOptions() {
        return this._internals.cacheOptions;
    }
    set cacheOptions(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.shared);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.cacheHeuristic);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.immutableMinTimeToLive);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.ignoreCargoCult);
        for(const key in value){
            if (!(key in this._internals.cacheOptions)) throw new Error(`Cache option \`${key}\` does not exist`);
        }
        if (this._merging) Object.assign(this._internals.cacheOptions, value);
        else this._internals.cacheOptions = {
            ...value
        };
    }
    /**
    Options for the advanced HTTPS API.
    */ get https() {
        return this._internals.https;
    }
    set https(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).plainObject(value);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.rejectUnauthorized);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.checkServerIdentity);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.certificateAuthority);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.key);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).object,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.certificate);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.passphrase);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.pfx);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.alpnProtocols);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.ciphers);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.dhparam);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.signatureAlgorithms);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.minVersion);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.maxVersion);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).boolean,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.honorCipherOrder);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.tlsSessionLifetime);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.ecdhCurve);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).buffer,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).array,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value.certificateRevocationLists);
        for(const key in value){
            if (!(key in this._internals.https)) throw new Error(`HTTPS option \`${key}\` does not exist`);
        }
        if (this._merging) Object.assign(this._internals.https, value);
        else this._internals.https = {
            ...value
        };
    }
    /**
    [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.

    To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
    Don't set this option to `null`.

    __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.

    @default 'utf-8'
    */ get encoding() {
        return this._internals.encoding;
    }
    set encoding(value) {
        if (value === null) throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.encoding = value;
    }
    /**
    When set to `true` the promise will return the Response body instead of the Response object.

    @default false
    */ get resolveBodyOnly() {
        return this._internals.resolveBodyOnly;
    }
    set resolveBodyOnly(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.resolveBodyOnly = value;
    }
    /**
    Returns a `Stream` instead of a `Promise`.
    This is equivalent to calling `got.stream(url, options?)`.

    @default false
    */ get isStream() {
        return this._internals.isStream;
    }
    set isStream(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.isStream = value;
    }
    /**
    The parsing method.

    The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.

    It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.

    __Note__: When using streams, this option is ignored.

    @example
    ```
    const responsePromise = got(url);
    const bufferPromise = responsePromise.buffer();
    const jsonPromise = responsePromise.json();

    const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
    // `response` is an instance of Got Response
    // `buffer` is an instance of Buffer
    // `json` is an object
    ```

    @example
    ```
    // This
    const body = await got(url).json();

    // is semantically the same as this
    const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
    ```
    */ get responseType() {
        return this._internals.responseType;
    }
    set responseType(value) {
        if (value === undefined) {
            this._internals.responseType = "text";
            return;
        }
        if (value !== "text" && value !== "buffer" && value !== "json") throw new Error(`Invalid \`responseType\` option: ${value}`);
        this._internals.responseType = value;
    }
    get pagination() {
        return this._internals.pagination;
    }
    set pagination(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).object(value);
        if (this._merging) Object.assign(this._internals.pagination, value);
        else this._internals.pagination = value;
    }
    get auth() {
        throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    set auth(_value) {
        throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    get setHost() {
        return this._internals.setHost;
    }
    set setHost(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.setHost = value;
    }
    get maxHeaderSize() {
        return this._internals.maxHeaderSize;
    }
    set maxHeaderSize(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number,
            (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
        ], value);
        this._internals.maxHeaderSize = value;
    }
    get enableUnixSockets() {
        return this._internals.enableUnixSockets;
    }
    set enableUnixSockets(value) {
        (0, $23048e7f833b5d93$export$a7a9523472993e97).boolean(value);
        this._internals.enableUnixSockets = value;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    toJSON() {
        return {
            ...this._internals
        };
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
        return (0, $dAk3n$nodeutil.inspect)(this._internals, options);
    }
    createNativeRequestOptions() {
        const internals = this._internals;
        const url = internals.url;
        let agent;
        if (url.protocol === "https:") agent = internals.http2 ? internals.agent : internals.agent.https;
        else agent = internals.agent.http;
        const { https: https } = internals;
        let { pfx: pfx } = https;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).array(pfx) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).plainObject(pfx[0])) pfx = pfx.map((object)=>({
                buf: object.buffer,
                passphrase: object.passphrase
            }));
        return {
            ...internals.cacheOptions,
            ...this._unixOptions,
            // HTTPS options
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ALPNProtocols: https.alpnProtocols,
            ca: https.certificateAuthority,
            cert: https.certificate,
            key: https.key,
            passphrase: https.passphrase,
            pfx: https.pfx,
            rejectUnauthorized: https.rejectUnauthorized,
            checkServerIdentity: https.checkServerIdentity ?? (0, $dAk3n$nodetls.checkServerIdentity),
            ciphers: https.ciphers,
            honorCipherOrder: https.honorCipherOrder,
            minVersion: https.minVersion,
            maxVersion: https.maxVersion,
            sigalgs: https.signatureAlgorithms,
            sessionTimeout: https.tlsSessionLifetime,
            dhparam: https.dhparam,
            ecdhCurve: https.ecdhCurve,
            crl: https.certificateRevocationLists,
            // HTTP options
            lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
            family: internals.dnsLookupIpVersion,
            agent: agent,
            setHost: internals.setHost,
            method: internals.method,
            maxHeaderSize: internals.maxHeaderSize,
            localAddress: internals.localAddress,
            headers: internals.headers,
            createConnection: internals.createConnection,
            timeout: internals.http2 ? $87f98181f8a9fce4$var$getHttp2TimeoutOption(internals) : undefined,
            // HTTP/2 options
            h2session: internals.h2session
        };
    }
    getRequestFunction() {
        const url = this._internals.url;
        const { request: request } = this._internals;
        if (!request && url) return this.getFallbackRequestFunction();
        return request;
    }
    getFallbackRequestFunction() {
        const url = this._internals.url;
        if (!url) return;
        if (url.protocol === "https:") {
            if (this._internals.http2) {
                if ($87f98181f8a9fce4$var$major < 15 || $87f98181f8a9fce4$var$major === 15 && $87f98181f8a9fce4$var$minor < 10) {
                    const error = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
                    error.code = "EUNSUPPORTED";
                    throw error;
                }
                return (0, (/*@__PURE__*/$parcel$interopDefault($2a024f368552c192$exports))).auto;
            }
            return (0, ($parcel$interopDefault($dAk3n$nodehttps))).request;
        }
        return (0, ($parcel$interopDefault($dAk3n$nodehttp))).request;
    }
    freeze() {
        const options = this._internals;
        Object.freeze(options);
        Object.freeze(options.hooks);
        Object.freeze(options.hooks.afterResponse);
        Object.freeze(options.hooks.beforeError);
        Object.freeze(options.hooks.beforeRedirect);
        Object.freeze(options.hooks.beforeRequest);
        Object.freeze(options.hooks.beforeRetry);
        Object.freeze(options.hooks.init);
        Object.freeze(options.https);
        Object.freeze(options.cacheOptions);
        Object.freeze(options.agent);
        Object.freeze(options.headers);
        Object.freeze(options.timeout);
        Object.freeze(options.retry);
        Object.freeze(options.retry.errorCodes);
        Object.freeze(options.retry.methods);
        Object.freeze(options.retry.statusCodes);
    }
}



const $9c1806459bf2f1b4$export$746ebf9e39b71511 = (response)=>{
    const { statusCode: statusCode } = response;
    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
    return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
class $9c1806459bf2f1b4$export$f9c837a54db411d extends (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743) {
    constructor(error, response){
        const { options: options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = "ParseError";
        this.code = "ERR_BODY_PARSE_FAILURE";
    }
}
const $9c1806459bf2f1b4$export$3b629cd0ff482602 = (response, responseType, parseJson, encoding)=>{
    const { rawBody: rawBody } = response;
    try {
        if (responseType === "text") return rawBody.toString(encoding);
        if (responseType === "json") return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
        if (responseType === "buffer") return rawBody;
    } catch (error) {
        throw new $9c1806459bf2f1b4$export$f9c837a54db411d(error, response);
    }
    throw new $9c1806459bf2f1b4$export$f9c837a54db411d({
        message: `Unknown body type '${responseType}'`,
        name: "Error"
    }, response);
};


function $42bcb359e6f4f240$var$isClientRequest(clientRequest) {
    return clientRequest.writable && !clientRequest.writableEnded;
}
var $42bcb359e6f4f240$export$2e2bcd8739ae039 = $42bcb359e6f4f240$var$isClientRequest;


// eslint-disable-next-line @typescript-eslint/naming-convention
function $8713e3a87bd3f359$export$2e2bcd8739ae039(url) {
    return url.protocol === "unix:" || url.hostname === "unix";
}



const { buffer: $168cbfb6b9f51694$var$getStreamAsBuffer } = (0, (/*@__PURE__*/$parcel$interopDefault($d62fd2c5965796dc$exports)));
const $168cbfb6b9f51694$var$supportsBrotli = (0, $23048e7f833b5d93$export$2e2bcd8739ae039).string((0, ($parcel$interopDefault($dAk3n$nodeprocess))).versions.brotli);
const $168cbfb6b9f51694$var$methodsWithoutBody = new Set([
    "GET",
    "HEAD"
]);
const $168cbfb6b9f51694$var$cacheableStore = new (0, $9da833297e37ffc5$export$2e2bcd8739ae039)();
const $168cbfb6b9f51694$var$redirectCodes = new Set([
    300,
    301,
    302,
    303,
    304,
    307,
    308
]);
const $168cbfb6b9f51694$var$proxiedRequestEvents = [
    "socket",
    "connect",
    "continue",
    "information",
    "upgrade"
];
const $168cbfb6b9f51694$var$noop = ()=>{};
class $168cbfb6b9f51694$export$2e2bcd8739ae039 extends (0, $dAk3n$nodestream.Duplex) {
    constructor(url, options, defaults){
        super({
            // Don't destroy immediately, as the error may be emitted on unsuccessful retry
            autoDestroy: false,
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0
        });
        // @ts-expect-error - Ignoring for now.
        Object.defineProperty(this, "constructor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_noPipe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "requestUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "redirectUrls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retryCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_stopRetry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downloadedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_uploadedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_stopReading", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pipedServerResponses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_responseSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bodySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_unproxyEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isFromCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cannotHaveBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_triggerRead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cancelTimeouts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_removeListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nativeResponse", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_flushed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_aborted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // We need this because `this._request` if `undefined` when using cache
        Object.defineProperty(this, "_requestInitialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._downloadedSize = 0;
        this._uploadedSize = 0;
        this._stopReading = false;
        this._pipedServerResponses = new Set();
        this._cannotHaveBody = false;
        this._unproxyEvents = $168cbfb6b9f51694$var$noop;
        this._triggerRead = false;
        this._cancelTimeouts = $168cbfb6b9f51694$var$noop;
        this._removeListeners = $168cbfb6b9f51694$var$noop;
        this._jobs = [];
        this._flushed = false;
        this._requestInitialized = false;
        this._aborted = false;
        this.redirectUrls = [];
        this.retryCount = 0;
        this._stopRetry = $168cbfb6b9f51694$var$noop;
        this.on("pipe", (source)=>{
            if (source?.headers) Object.assign(this.options.headers, source.headers);
        });
        this.on("newListener", (event)=>{
            if (event === "retry" && this.listenerCount("retry") > 0) throw new Error("A retry listener has been attached already.");
        });
        try {
            this.options = new (0, $87f98181f8a9fce4$export$2e2bcd8739ae039)(url, options, defaults);
            if (!this.options.url) {
                if (this.options.prefixUrl === "") throw new TypeError("Missing `url` property");
                this.options.url = "";
            }
            this.requestUrl = this.options.url;
        } catch (error) {
            const { options: options } = error;
            if (options) this.options = options;
            this.flush = async ()=>{
                this.flush = async ()=>{};
                this.destroy(error);
            };
            return;
        }
        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.
        // The below is run only once.
        const { body: body } = this.options;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body)) body.once("error", (error)=>{
            if (this._flushed) this._beforeError(new (0, $eb7b72ed36f102cf$export$137ec66182ed30ea)(error, this));
            else this.flush = async ()=>{
                this.flush = async ()=>{};
                this._beforeError(new (0, $eb7b72ed36f102cf$export$137ec66182ed30ea)(error, this));
            };
        });
        if (this.options.signal) {
            const abort = ()=>{
                this.destroy(new (0, $eb7b72ed36f102cf$export$18b052ffd8c84d7)(this));
            };
            if (this.options.signal.aborted) abort();
            else {
                this.options.signal.addEventListener("abort", abort);
                this._removeListeners = ()=>{
                    this.options.signal?.removeEventListener("abort", abort);
                };
            }
        }
    }
    async flush() {
        if (this._flushed) return;
        this._flushed = true;
        try {
            await this._finalizeBody();
            if (this.destroyed) return;
            await this._makeRequest();
            if (this.destroyed) {
                this._request?.destroy();
                return;
            }
            // Queued writes etc.
            for (const job of this._jobs)job();
            // Prevent memory leak
            this._jobs.length = 0;
            this._requestInitialized = true;
        } catch (error) {
            this._beforeError(error);
        }
    }
    _beforeError(error) {
        if (this._stopReading) return;
        const { response: response, options: options } = this;
        const attemptCount = this.retryCount + (error.name === "RetryError" ? 0 : 1);
        this._stopReading = true;
        if (!(error instanceof (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743))) error = new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)(error.message, error, this);
        const typedError = error;
        (async ()=>{
            // Node.js parser is really weird.
            // It emits post-request Parse Errors on the same instance as previous request. WTF.
            // Therefore we need to check if it has been destroyed as well.
            //
            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,
            // but makes the response unreadable. So we additionally need to check `response.readable`.
            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {
                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.
                response.setEncoding(this.readableEncoding);
                const success = await this._setRawBody(response);
                if (success) response.body = response.rawBody.toString();
            }
            if (this.listenerCount("retry") !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && "retry-after" in response.headers) {
                        retryAfter = Number(response.headers["retry-after"]);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
                            if (retryAfter <= 0) retryAfter = 1;
                        } else retryAfter *= 1000;
                    }
                    const retryOptions = options.retry;
                    backoff = await retryOptions.calculateDelay({
                        attemptCount: attemptCount,
                        retryOptions: retryOptions,
                        error: typedError,
                        retryAfter: retryAfter,
                        computedValue: (0, $b082cfcb422c7190$export$2e2bcd8739ae039)({
                            attemptCount: attemptCount,
                            retryOptions: retryOptions,
                            error: typedError,
                            retryAfter: retryAfter,
                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
                        })
                    });
                } catch (error_) {
                    this._error(new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)(error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    await new Promise((resolve)=>{
                        const timeout = setTimeout(resolve, backoff);
                        this._stopRetry = ()=>{
                            clearTimeout(timeout);
                            resolve();
                        };
                    });
                    // Something forced us to abort the retry
                    if (this.destroyed) return;
                    try {
                        for (const hook of this.options.hooks.beforeRetry)// eslint-disable-next-line no-await-in-loop
                        await hook(typedError, this.retryCount + 1);
                    } catch (error_) {
                        this._error(new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)(error_.message, error, this));
                        return;
                    }
                    // Something forced us to abort the retry
                    if (this.destroyed) return;
                    this.destroy();
                    this.emit("retry", this.retryCount + 1, error, (updatedOptions)=>{
                        const request = new $168cbfb6b9f51694$export$2e2bcd8739ae039(options.url, updatedOptions, options);
                        request.retryCount = this.retryCount + 1;
                        (0, ($parcel$interopDefault($dAk3n$nodeprocess))).nextTick(()=>{
                            request.flush();
                        });
                        return request;
                    });
                    return;
                }
            }
            this._error(typedError);
        })();
    }
    _read() {
        this._triggerRead = true;
        const { response: response } = this;
        if (response && !this._stopReading) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) this._triggerRead = false;
            let data;
            while((data = response.read()) !== null){
                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands
                const progress = this.downloadProgress;
                if (progress.percent < 1) this.emit("downloadProgress", progress);
                this.push(data);
            }
        }
    }
    _write(chunk, encoding, callback) {
        const write = ()=>{
            this._writeRequest(chunk, encoding, callback);
        };
        if (this._requestInitialized) write();
        else this._jobs.push(write);
    }
    _final(callback) {
        const endRequest = ()=>{
            // We need to check if `this._request` is present,
            // because it isn't when we use cache.
            if (!this._request || this._request.destroyed) {
                callback();
                return;
            }
            this._request.end((error)=>{
                // The request has been destroyed before `_final` finished.
                // See https://github.com/nodejs/node/issues/39356
                if (this._request._writableState?.errored) return;
                if (!error) {
                    this._bodySize = this._uploadedSize;
                    this.emit("uploadProgress", this.uploadProgress);
                    this._request.emit("upload-complete");
                }
                callback(error);
            });
        };
        if (this._requestInitialized) endRequest();
        else this._jobs.push(endRequest);
    }
    _destroy(error, callback) {
        this._stopReading = true;
        this.flush = async ()=>{};
        // Prevent further retries
        this._stopRetry();
        this._cancelTimeouts();
        this._removeListeners();
        if (this.options) {
            const { body: body } = this.options;
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body)) body.destroy();
        }
        if (this._request) this._request.destroy();
        if (error !== null && !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(error) && !(error instanceof (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743))) error = new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)(error.message, error, this);
        callback(error);
    }
    pipe(destination, options) {
        if (destination instanceof (0, $dAk3n$nodehttp.ServerResponse)) this._pipedServerResponses.add(destination);
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof (0, $dAk3n$nodehttp.ServerResponse)) this._pipedServerResponses.delete(destination);
        super.unpipe(destination);
        return this;
    }
    async _finalizeBody() {
        const { options: options } = this;
        const { headers: headers } = options;
        const isForm = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(options.form);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const isJSON = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(options.json);
        const isBody = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(options.body);
        const cannotHaveBody = $168cbfb6b9f51694$var$methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (isForm || isJSON || isBody) {
            if (cannotHaveBody) throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            // Serialize body
            const noContentType = !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).string(headers["content-type"]);
            if (isBody) {
                // Body is spec-compliant FormData
                if ((0, $3217e51b94272cab$export$67a42df2b7ab73bc)(options.body)) {
                    const encoder = new (0, $06ae1ff7b4cdf2fd$exports.FormDataEncoder)(options.body);
                    if (noContentType) headers["content-type"] = encoder.headers["Content-Type"];
                    if ("Content-Length" in encoder.headers) headers["content-length"] = encoder.headers["Content-Length"];
                    options.body = encoder.encode();
                }
                // Special case for https://github.com/form-data/form-data
                if ((0, $5c9b7d7cc0740e83$export$2e2bcd8739ae039)(options.body) && noContentType) headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
            } else if (isForm) {
                if (noContentType) headers["content-type"] = "application/x-www-form-urlencoded";
                const { form: form } = options;
                options.form = undefined;
                options.body = new URLSearchParams(form).toString();
            } else {
                if (noContentType) headers["content-type"] = "application/json";
                const { json: json } = options;
                options.json = undefined;
                options.body = options.stringifyJson(json);
            }
            const uploadBodySize = await (0, $01b960affdc7607c$export$2e2bcd8739ae039)(options.body, options.headers);
            // See https://tools.ietf.org/html/rfc7230#section-3.3.2
            // A user agent SHOULD send a Content-Length in a request message when
            // no Transfer-Encoding is sent and the request method defines a meaning
            // for an enclosed payload body.  For example, a Content-Length header
            // field is normally sent in a POST request even when the value is 0
            // (indicating an empty payload body).  A user agent SHOULD NOT send a
            // Content-Length header field when the request message does not contain
            // a payload body and the method semantics do not anticipate such a
            // body.
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers["content-length"]) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers["transfer-encoding"]) && !cannotHaveBody && !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(uploadBodySize)) headers["content-length"] = String(uploadBodySize);
        }
        if (options.responseType === "json" && !("accept" in options.headers)) options.headers.accept = "application/json";
        this._bodySize = Number(headers["content-length"]) || undefined;
    }
    async _onResponseBase(response) {
        // This will be called e.g. when using cache so we need to check if this request has been aborted.
        if (this.isAborted) return;
        const { options: options } = this;
        const { url: url } = options;
        this._nativeResponse = response;
        if (options.decompress) response = (0, (/*@__PURE__*/$parcel$interopDefault($4b1f68885d6f9646$exports)))(response);
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ?? (0, ($parcel$interopDefault($dAk3n$nodehttp))).STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirectUrls;
        typedResponse.request = this;
        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        typedResponse.ok = (0, $9c1806459bf2f1b4$export$746ebf9e39b71511)(typedResponse);
        this._isFromCache = typedResponse.isFromCache;
        this._responseSize = Number(response.headers["content-length"]) || undefined;
        this.response = typedResponse;
        response.once("end", ()=>{
            this._responseSize = this._downloadedSize;
            this.emit("downloadProgress", this.downloadProgress);
        });
        response.once("error", (error)=>{
            this._aborted = true;
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new (0, $eb7b72ed36f102cf$export$e5f2fbba71434b55)(error, this));
        });
        response.once("aborted", ()=>{
            this._aborted = true;
            this._beforeError(new (0, $eb7b72ed36f102cf$export$e5f2fbba71434b55)({
                name: "Error",
                message: "The server aborted pending request",
                code: "ECONNRESET"
            }, this));
        });
        this.emit("downloadProgress", this.downloadProgress);
        const rawCookies = response.headers["set-cookie"];
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie)=>options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) promises = promises.map(async (promise)=>{
                try {
                    await promise;
                } catch  {}
            });
            try {
                await Promise.all(promises);
            } catch (error) {
                this._beforeError(error);
                return;
            }
        }
        // The above is running a promise, therefore we need to check if this request has been aborted yet again.
        if (this.isAborted) return;
        if (options.followRedirect && response.headers.location && $168cbfb6b9f51694$var$redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be best to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            response.resume();
            this._cancelTimeouts();
            this._unproxyEvents();
            if (this.redirectUrls.length >= options.maxRedirects) {
                this._beforeError(new (0, $eb7b72ed36f102cf$export$a34d7acee3cbcf76)(this));
                return;
            }
            this._request = undefined;
            const updatedOptions = new (0, $87f98181f8a9fce4$export$2e2bcd8739ae039)(undefined, undefined, this.options);
            const serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
            const canRewrite = statusCode !== 307 && statusCode !== 308;
            const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
            if (serverRequestedGet || userRequestedGet) {
                updatedOptions.method = "GET";
                updatedOptions.body = undefined;
                updatedOptions.json = undefined;
                updatedOptions.form = undefined;
                delete updatedOptions.headers["content-length"];
            }
            try {
                // We need this in order to support UTF-8
                const redirectBuffer = (0, $dAk3n$nodebuffer.Buffer).from(response.headers.location, "binary").toString();
                const redirectUrl = new URL(redirectBuffer, url);
                if (!(0, $8713e3a87bd3f359$export$2e2bcd8739ae039)(url) && (0, $8713e3a87bd3f359$export$2e2bcd8739ae039)(redirectUrl)) {
                    this._beforeError(new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)("Cannot redirect to UNIX socket", {}, this));
                    return;
                }
                // Redirecting to a different site, clear sensitive data.
                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                    if ("host" in updatedOptions.headers) delete updatedOptions.headers.host;
                    if ("cookie" in updatedOptions.headers) delete updatedOptions.headers.cookie;
                    if ("authorization" in updatedOptions.headers) delete updatedOptions.headers.authorization;
                    if (updatedOptions.username || updatedOptions.password) {
                        updatedOptions.username = "";
                        updatedOptions.password = "";
                    }
                } else {
                    redirectUrl.username = updatedOptions.username;
                    redirectUrl.password = updatedOptions.password;
                }
                this.redirectUrls.push(redirectUrl);
                updatedOptions.prefixUrl = "";
                updatedOptions.url = redirectUrl;
                for (const hook of updatedOptions.hooks.beforeRedirect)// eslint-disable-next-line no-await-in-loop
                await hook(updatedOptions, typedResponse);
                this.emit("redirect", updatedOptions, typedResponse);
                this.options = updatedOptions;
                await this._makeRequest();
            } catch (error) {
                this._beforeError(error);
                return;
            }
            return;
        }
        // `HTTPError`s always have `error.response.body` defined.
        // Therefore we cannot retry if `options.throwHttpErrors` is false.
        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,
        // but that wouldn't be possible since the body would be already read in `error.response.body`.
        if (options.isStream && options.throwHttpErrors && !(0, $9c1806459bf2f1b4$export$746ebf9e39b71511)(typedResponse)) {
            this._beforeError(new (0, $eb7b72ed36f102cf$export$aa9d629c530f62a7)(typedResponse));
            return;
        }
        response.on("readable", ()=>{
            if (this._triggerRead) this._read();
        });
        this.on("resume", ()=>{
            response.resume();
        });
        this.on("pause", ()=>{
            response.pause();
        });
        response.once("end", ()=>{
            this.push(null);
        });
        if (this._noPipe) {
            const success = await this._setRawBody();
            if (success) this.emit("response", response);
            return;
        }
        this.emit("response", response);
        for (const destination of this._pipedServerResponses){
            if (destination.headersSent) continue;
            // eslint-disable-next-line guard-for-in
            for(const key in response.headers){
                const isAllowed = options.decompress ? key !== "content-encoding" : true;
                const value = response.headers[key];
                if (isAllowed) destination.setHeader(key, value);
            }
            destination.statusCode = statusCode;
        }
    }
    async _setRawBody(from = this) {
        if (from.readableEnded) return false;
        try {
            // Errors are emitted via the `error` event
            const rawBody = await $168cbfb6b9f51694$var$getStreamAsBuffer(from);
            // TODO: Switch to this:
            // let rawBody = await from.toArray();
            // rawBody = Buffer.concat(rawBody);
            // On retry Request is destroyed with no error, therefore the above will successfully resolve.
            // So in order to check if this was really successfull, we need to check if it has been properly ended.
            if (!this.isAborted) {
                this.response.rawBody = rawBody;
                return true;
            }
        } catch  {}
        return false;
    }
    async _onResponse(response) {
        try {
            await this._onResponseBase(response);
        } catch (error) {
            /* istanbul ignore next: better safe than sorry */ this._beforeError(error);
        }
    }
    _onRequest(request) {
        const { options: options } = this;
        const { timeout: timeout, url: url } = options;
        (0, $263dfae12a4c70a4$export$2e2bcd8739ae039)(request);
        if (this.options.http2) // Unset stream timeout, as the `timeout` option was used only for connection timeout.
        request.setTimeout(0);
        this._cancelTimeouts = (0, $0360f33952b6355d$export$2e2bcd8739ae039)(request, timeout, url);
        const responseEventName = options.cache ? "cacheableResponse" : "response";
        request.once(responseEventName, (response)=>{
            this._onResponse(response);
        });
        request.once("error", (error)=>{
            this._aborted = true;
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            error = error instanceof (0, $0360f33952b6355d$export$66d311bf29d5c89c) ? new (0, $eb7b72ed36f102cf$export$66d311bf29d5c89c)(error, this.timings, this) : new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)(error.message, error, this);
            this._beforeError(error);
        });
        this._unproxyEvents = (0, $5544ec9d50c16cf0$export$2e2bcd8739ae039)(request, this, $168cbfb6b9f51694$var$proxiedRequestEvents);
        this._request = request;
        this.emit("uploadProgress", this.uploadProgress);
        this._sendBody();
        this.emit("request", request);
    }
    async _asyncWrite(chunk) {
        return new Promise((resolve, reject)=>{
            super.write(chunk, (error)=>{
                if (error) {
                    reject(error);
                    return;
                }
                resolve();
            });
        });
    }
    _sendBody() {
        // Send body
        const { body: body } = this.options;
        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
        if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(body)) body.pipe(currentRequest);
        else if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).generator(body) || (0, $23048e7f833b5d93$export$2e2bcd8739ae039).asyncGenerator(body)) (async ()=>{
            try {
                for await (const chunk of body)await this._asyncWrite(chunk);
                super.end();
            } catch (error) {
                this._beforeError(error);
            }
        })();
        else if (!(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(body)) {
            this._writeRequest(body, undefined, ()=>{});
            currentRequest.end();
        } else if (this._cannotHaveBody || this._noPipe) currentRequest.end();
    }
    _prepareCache(cache) {
        if (!$168cbfb6b9f51694$var$cacheableStore.has(cache)) {
            const cacheableRequest = new (0, $a6de8cfd72a6dad5$export$2e2bcd8739ae039)((requestOptions, handler)=>{
                const result = requestOptions._request(requestOptions, handler);
                // TODO: remove this when `cacheable-request` supports async request functions.
                if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(result)) // We only need to implement the error handler in order to support HTTP2 caching.
                // The result will be a promise anyway.
                // @ts-expect-error ignore
                result.once = (event, handler)=>{
                    if (event === "error") (async ()=>{
                        try {
                            await result;
                        } catch (error) {
                            handler(error);
                        }
                    })();
                    else if (event === "abort") // The empty catch is needed here in case when
                    // it rejects before it's `await`ed in `_makeRequest`.
                    (async ()=>{
                        try {
                            const request = await result;
                            request.once("abort", handler);
                        } catch  {}
                    })();
                    else /* istanbul ignore next: safety check */ throw new Error(`Unknown HTTP2 promise event: ${event}`);
                    return result;
                };
                return result;
            }, cache);
            $168cbfb6b9f51694$var$cacheableStore.set(cache, cacheableRequest.request());
        }
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject)=>{
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, (0, $f8c7ea3bb4e89994$export$2e2bcd8739ae039)(url));
            let request;
            // TODO: Fix `cacheable-response`. This is ugly.
            const cacheRequest = $168cbfb6b9f51694$var$cacheableStore.get(options.cache)(options, async (response)=>{
                response._readableState.autoDestroy = false;
                if (request) {
                    const fix = ()=>{
                        if (response.req) response.complete = response.req.res.complete;
                    };
                    response.prependOnceListener("end", fix);
                    fix();
                    (await request).emit("cacheableResponse", response);
                }
                resolve(response);
            });
            cacheRequest.once("error", reject);
            cacheRequest.once("request", async (requestOrPromise)=>{
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        const { options: options } = this;
        const { headers: headers, username: username, password: password } = options;
        const cookieJar = options.cookieJar;
        for(const key in headers){
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers[key])) // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete headers[key];
            else if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).null_(headers[key])) throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
        }
        if (options.decompress && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(headers["accept-encoding"])) headers["accept-encoding"] = $168cbfb6b9f51694$var$supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
        if (username || password) {
            const credentials = (0, $dAk3n$nodebuffer.Buffer).from(`${username}:${password}`).toString("base64");
            headers.authorization = `Basic ${credentials}`;
        }
        // Set cookies
        if (cookieJar) {
            const cookieString = await cookieJar.getCookieString(options.url.toString());
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).nonEmptyString(cookieString)) headers.cookie = cookieString;
        }
        // Reset `prefixUrl`
        options.prefixUrl = "";
        let request;
        for (const hook of options.hooks.beforeRequest){
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options);
            if (!(0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(result)) {
                // @ts-expect-error Skip the type mismatch to support abstract responses
                request = ()=>result;
                break;
            }
        }
        if (!request) request = options.getRequestFunction();
        const url = options.url;
        this._requestOptions = options.createNativeRequestOptions();
        if (options.cache) {
            this._requestOptions._request = request;
            this._requestOptions.cache = options.cache;
            this._requestOptions.body = options.body;
            this._prepareCache(options.cache);
        }
        // Cache support
        const fn = options.cache ? this._createCacheableRequest : request;
        try {
            // We can't do `await fn(...)`,
            // because stream `error` event can be emitted before `Promise.resolve()`.
            let requestOrResponse = fn(url, this._requestOptions);
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(requestOrResponse)) requestOrResponse = await requestOrResponse;
            // Fallback
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(requestOrResponse)) {
                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
                if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(requestOrResponse)) requestOrResponse = await requestOrResponse;
            }
            if ((0, $42bcb359e6f4f240$export$2e2bcd8739ae039)(requestOrResponse)) this._onRequest(requestOrResponse);
            else if (this.writable) {
                this.once("finish", ()=>{
                    this._onResponse(requestOrResponse);
                });
                this._sendBody();
            } else this._onResponse(requestOrResponse);
        } catch (error) {
            if (error instanceof (0, $0cd45e613d0af170$export$78ff06e91c3de382)) throw new (0, $eb7b72ed36f102cf$export$78ff06e91c3de382)(error, this);
            throw error;
        }
    }
    async _error(error) {
        try {
            if (error instanceof (0, $eb7b72ed36f102cf$export$aa9d629c530f62a7) && !this.options.throwHttpErrors) ;
            else for (const hook of this.options.hooks.beforeError)// eslint-disable-next-line no-await-in-loop
            error = await hook(error);
        } catch (error_) {
            error = new (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743)(error_.message, error_, this);
        }
        this.destroy(error);
    }
    _writeRequest(chunk, encoding, callback) {
        if (!this._request || this._request.destroyed) // Probably the `ClientRequest` instance will throw
        return;
        this._request.write(chunk, encoding, (error)=>{
            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed
            if (!error && !this._request.destroyed) {
                this._uploadedSize += (0, $dAk3n$nodebuffer.Buffer).byteLength(chunk, encoding);
                const progress = this.uploadProgress;
                if (progress.percent < 1) this.emit("uploadProgress", progress);
            }
            callback(error);
        });
    }
    /**
    The remote IP address.
    */ get ip() {
        return this.socket?.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */ get isAborted() {
        return this._aborted;
    }
    get socket() {
        return this._request?.socket ?? undefined;
    }
    /**
    Progress event for downloading (receiving a response).
    */ get downloadProgress() {
        let percent;
        if (this._responseSize) percent = this._downloadedSize / this._responseSize;
        else if (this._responseSize === this._downloadedSize) percent = 1;
        else percent = 0;
        return {
            percent: percent,
            transferred: this._downloadedSize,
            total: this._responseSize
        };
    }
    /**
    Progress event for uploading (sending a request).
    */ get uploadProgress() {
        let percent;
        if (this._bodySize) percent = this._uploadedSize / this._bodySize;
        else if (this._bodySize === this._uploadedSize) percent = 1;
        else percent = 0;
        return {
            percent: percent,
            transferred: this._uploadedSize,
            total: this._bodySize
        };
    }
    /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */ get timings() {
        return this._request?.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */ get isFromCache() {
        return this._isFromCache;
    }
    get reusedSocket() {
        return this._request?.reusedSocket;
    }
}





class $a642047fc970e5d7$export$d7f5e52d091a66db extends (0, $eb7b72ed36f102cf$export$43ee7d0e4f429743) {
    constructor(request){
        super("Promise was canceled", {}, request);
        this.name = "CancelError";
        this.code = "ERR_CANCELED";
    }
    /**
    Whether the promise is canceled.
    */ get isCanceled() {
        return true;
    }
}


const $bc4290a9d6440a2f$var$proxiedRequestEvents = [
    "request",
    "response",
    "redirect",
    "uploadProgress",
    "downloadProgress"
];
function $bc4290a9d6440a2f$export$2e2bcd8739ae039(firstRequest) {
    let globalRequest;
    let globalResponse;
    let normalizedOptions;
    const emitter = new (0, $dAk3n$nodeevents.EventEmitter)();
    const promise = new (0, $9f256715eaead164$export$2e2bcd8739ae039)((resolve, reject, onCancel)=>{
        onCancel(()=>{
            globalRequest.destroy();
        });
        onCancel.shouldReject = false;
        onCancel(()=>{
            reject(new (0, $a642047fc970e5d7$export$d7f5e52d091a66db)(globalRequest));
        });
        const makeRequest = (retryCount)=>{
            // Errors when a new request is made after the promise settles.
            // Used to detect a race condition.
            // See https://github.com/sindresorhus/got/issues/1489
            onCancel(()=>{});
            const request = firstRequest ?? new (0, $168cbfb6b9f51694$export$2e2bcd8739ae039)(undefined, undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            globalRequest = request;
            request.once("response", async (response)=>{
                // Parse body
                const contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase();
                const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br";
                const { options: options } = request;
                if (isCompressed && !options.decompress) response.body = response.rawBody;
                else try {
                    response.body = (0, $9c1806459bf2f1b4$export$3b629cd0ff482602)(response, options.responseType, options.parseJson, options.encoding);
                } catch (error) {
                    // Fall back to `utf8`
                    response.body = response.rawBody.toString();
                    if ((0, $9c1806459bf2f1b4$export$746ebf9e39b71511)(response)) {
                        request._beforeError(error);
                        return;
                    }
                }
                try {
                    const hooks = options.hooks.afterResponse;
                    for (const [index, hook] of hooks.entries()){
                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions)=>{
                            options.merge(updatedOptions);
                            options.prefixUrl = "";
                            if (updatedOptions.url) options.url = updatedOptions.url;
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
                            throw new (0, $eb7b72ed36f102cf$export$aa6cf8a4f695f0ee)(request);
                        });
                        if (!((0, $23048e7f833b5d93$export$2e2bcd8739ae039).object(response) && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).number(response.statusCode) && !(0, $23048e7f833b5d93$export$2e2bcd8739ae039).nullOrUndefined(response.body))) throw new TypeError("The `afterResponse` hook returned an invalid value");
                    }
                } catch (error) {
                    request._beforeError(error);
                    return;
                }
                globalResponse = response;
                if (!(0, $9c1806459bf2f1b4$export$746ebf9e39b71511)(response)) {
                    request._beforeError(new (0, $eb7b72ed36f102cf$export$aa9d629c530f62a7)(response));
                    return;
                }
                request.destroy();
                resolve(request.options.resolveBodyOnly ? response.body : response);
            });
            const onError = (error)=>{
                if (promise.isCanceled) return;
                const { options: options } = request;
                if (error instanceof (0, $eb7b72ed36f102cf$export$aa9d629c530f62a7) && !options.throwHttpErrors) {
                    const { response: response } = error;
                    request.destroy();
                    resolve(request.options.resolveBodyOnly ? response.body : response);
                    return;
                }
                reject(error);
            };
            request.once("error", onError);
            const previousBody = request.options?.body;
            request.once("retry", (newRetryCount, error)=>{
                firstRequest = undefined;
                const newBody = request.options.body;
                if (previousBody === newBody && (0, $23048e7f833b5d93$export$2e2bcd8739ae039).nodeStream(newBody)) {
                    error.message = "Cannot retry with consumed body stream";
                    onError(error);
                    return;
                }
                // This is needed! We need to reuse `request.options` because they can get modified!
                // For example, by calling `promise.json()`.
                normalizedOptions = request.options;
                makeRequest(newRetryCount);
            });
            (0, $5544ec9d50c16cf0$export$2e2bcd8739ae039)(request, emitter, $bc4290a9d6440a2f$var$proxiedRequestEvents);
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined(firstRequest)) request.flush();
        };
        makeRequest(0);
    });
    promise.on = (event, fn)=>{
        emitter.on(event, fn);
        return promise;
    };
    promise.off = (event, fn)=>{
        emitter.off(event, fn);
        return promise;
    };
    const shortcut = (responseType)=>{
        const newPromise = (async ()=>{
            // Wait until downloading has ended
            await promise;
            const { options: options } = globalResponse.request;
            return (0, $9c1806459bf2f1b4$export$3b629cd0ff482602)(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
    };
    promise.json = ()=>{
        if (globalRequest.options) {
            const { headers: headers } = globalRequest.options;
            if (!globalRequest.writableFinished && !("accept" in headers)) headers.accept = "application/json";
        }
        return shortcut("json");
    };
    promise.buffer = ()=>shortcut("buffer");
    promise.text = ()=>shortcut("text");
    return promise;
}




// The `delay` package weighs 10KB (!)
const $90217968b86f73bd$var$delay = async (ms)=>new Promise((resolve)=>{
        setTimeout(resolve, ms);
    });
const $90217968b86f73bd$var$isGotInstance = (value)=>(0, $23048e7f833b5d93$export$2e2bcd8739ae039).function_(value);
const $90217968b86f73bd$var$aliases = [
    "get",
    "post",
    "put",
    "patch",
    "head",
    "delete"
];
const $90217968b86f73bd$var$create = (defaults)=>{
    defaults = {
        options: new (0, $87f98181f8a9fce4$export$2e2bcd8739ae039)(undefined, undefined, defaults.options),
        handlers: [
            ...defaults.handlers
        ],
        mutableDefaults: defaults.mutableDefaults
    };
    Object.defineProperty(defaults, "mutableDefaults", {
        enumerable: true,
        configurable: false,
        writable: false
    });
    // Got interface
    const got = (url, options, defaultOptions = defaults.options)=>{
        const request = new (0, $168cbfb6b9f51694$export$2e2bcd8739ae039)(url, options, defaultOptions);
        let promise;
        const lastHandler = (normalized)=>{
            // Note: `options` is `undefined` when `new Options(...)` fails
            request.options = normalized;
            request._noPipe = !normalized.isStream;
            request.flush();
            if (normalized.isStream) return request;
            if (!promise) promise = (0, $bc4290a9d6440a2f$export$2e2bcd8739ae039)(request);
            return promise;
        };
        let iteration = 0;
        const iterateHandlers = (newOptions)=>{
            const handler = defaults.handlers[iteration++] ?? lastHandler;
            const result = handler(newOptions, iterateHandlers);
            if ((0, $23048e7f833b5d93$export$2e2bcd8739ae039).promise(result) && !request.options.isStream) {
                if (!promise) promise = (0, $bc4290a9d6440a2f$export$2e2bcd8739ae039)(request);
                if (result !== promise) {
                    const descriptors = Object.getOwnPropertyDescriptors(promise);
                    for(const key in descriptors)if (key in result) // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete descriptors[key];
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Object.defineProperties(result, descriptors);
                    result.cancel = promise.cancel;
                }
            }
            return result;
        };
        return iterateHandlers(request.options);
    };
    got.extend = (...instancesOrOptions)=>{
        const options = new (0, $87f98181f8a9fce4$export$2e2bcd8739ae039)(undefined, undefined, defaults.options);
        const handlers = [
            ...defaults.handlers
        ];
        let mutableDefaults;
        for (const value of instancesOrOptions)if ($90217968b86f73bd$var$isGotInstance(value)) {
            options.merge(value.defaults.options);
            handlers.push(...value.defaults.handlers);
            mutableDefaults = value.defaults.mutableDefaults;
        } else {
            options.merge(value);
            if (value.handlers) handlers.push(...value.handlers);
            mutableDefaults = value.mutableDefaults;
        }
        return $90217968b86f73bd$var$create({
            options: options,
            handlers: handlers,
            mutableDefaults: Boolean(mutableDefaults)
        });
    };
    // Pagination
    const paginateEach = async function*(url, options) {
        let normalizedOptions = new (0, $87f98181f8a9fce4$export$2e2bcd8739ae039)(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const { pagination: pagination } = normalizedOptions;
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.transform);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.shouldContinue);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.filter);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).function_(pagination.paginate);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(pagination.countLimit);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(pagination.requestLimit);
        (0, $23048e7f833b5d93$export$a7a9523472993e97).number(pagination.backoff);
        const allItems = [];
        let { countLimit: countLimit } = pagination;
        let numberOfRequests = 0;
        while(numberOfRequests < pagination.requestLimit){
            if (numberOfRequests !== 0) // eslint-disable-next-line no-await-in-loop
            await $90217968b86f73bd$var$delay(pagination.backoff);
            // eslint-disable-next-line no-await-in-loop
            const response = await got(undefined, undefined, normalizedOptions);
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(response);
            const currentItems = [];
            (0, $23048e7f833b5d93$export$a7a9523472993e97).array(parsed);
            for (const item of parsed)if (pagination.filter({
                item: item,
                currentItems: currentItems,
                allItems: allItems
            })) {
                if (!pagination.shouldContinue({
                    item: item,
                    currentItems: currentItems,
                    allItems: allItems
                })) return;
                yield item;
                if (pagination.stackAllItems) allItems.push(item);
                currentItems.push(item);
                if (--countLimit <= 0) return;
            }
            const optionsToMerge = pagination.paginate({
                response: response,
                currentItems: currentItems,
                allItems: allItems
            });
            if (optionsToMerge === false) return;
            if (optionsToMerge === response.request.options) normalizedOptions = response.request.options;
            else {
                normalizedOptions.merge(optionsToMerge);
                (0, $23048e7f833b5d93$export$a7a9523472993e97).any([
                    (0, $23048e7f833b5d93$export$2e2bcd8739ae039).urlInstance,
                    (0, $23048e7f833b5d93$export$2e2bcd8739ae039).undefined
                ], optionsToMerge.url);
                if (optionsToMerge.url !== undefined) {
                    normalizedOptions.prefixUrl = "";
                    normalizedOptions.url = optionsToMerge.url;
                }
            }
            numberOfRequests++;
        }
    };
    got.paginate = paginateEach;
    got.paginate.all = async (url, options)=>{
        const results = [];
        for await (const item of paginateEach(url, options))results.push(item);
        return results;
    };
    // For those who like very descriptive names
    got.paginate.each = paginateEach;
    // Stream API
    got.stream = (url, options)=>got(url, {
            ...options,
            isStream: true
        });
    // Shortcuts
    for (const method of $90217968b86f73bd$var$aliases){
        got[method] = (url, options)=>got(url, {
                ...options,
                method: method
            });
        got.stream[method] = (url, options)=>got(url, {
                ...options,
                method: method,
                isStream: true
            });
    }
    if (!defaults.mutableDefaults) {
        Object.freeze(defaults.handlers);
        defaults.options.freeze();
    }
    Object.defineProperty(got, "defaults", {
        value: defaults,
        writable: false,
        configurable: false,
        enumerable: true
    });
    return got;
};
var $90217968b86f73bd$export$2e2bcd8739ae039 = $90217968b86f73bd$var$create;










const $bf9770f9fe4e4d36$var$defaults = {
    options: new (0, $87f98181f8a9fce4$export$2e2bcd8739ae039)(),
    handlers: [],
    mutableDefaults: false
};
const $bf9770f9fe4e4d36$export$9ce08dfff6f4564a = (0, $90217968b86f73bd$export$2e2bcd8739ae039)($bf9770f9fe4e4d36$var$defaults);
var $bf9770f9fe4e4d36$export$2e2bcd8739ae039 = $bf9770f9fe4e4d36$export$9ce08dfff6f4564a;


var $a29840a000f7ad37$export$2e2bcd8739ae039 = $a29840a000f7ad37$var$omit;
/*
  var obj = {a: 3, b: 5, c: 9};
  omit(obj, ['a', 'c']); // {b: 5}
  omit(obj, a, c); // {b: 5}
  omit(obj, ['a', 'b', 'd']); // {c: 9}
  omit(obj, ['a', 'a']); // {b: 5, c: 9}
*/ function $a29840a000f7ad37$var$omit(obj, remove) {
    var result = {};
    if (typeof remove === "string") remove = [].slice.call(arguments, 1);
    for(var prop in obj){
        if (!obj.hasOwnProperty || obj.hasOwnProperty(prop)) {
            if (remove.indexOf(prop) === -1) result[prop] = obj[prop];
        }
    }
    return result;
}


var $a7842bd46cb2b669$exports = {};
"use strict";



var $a7842bd46cb2b669$require$promisify = $dAk3n$util.promisify;

const $a7842bd46cb2b669$var$useNativeRecursiveOption = $40fb1ad98b49c054$exports(process.version, "10.12.0");
// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const $a7842bd46cb2b669$var$checkPath = (pth)=>{
    if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace($dAk3n$path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
            const error = new Error(`Path contains invalid characters: ${pth}`);
            error.code = "EINVAL";
            throw error;
        }
    }
};
const $a7842bd46cb2b669$var$processOptions = (options)=>{
    const defaults = {
        mode: 511,
        fs: $dAk3n$fs
    };
    return {
        ...defaults,
        ...options
    };
};
const $a7842bd46cb2b669$var$permissionError = (pth)=>{
    // This replicates the exception of `fs.mkdir` with native the
    // `recusive` option when run on an invalid drive under Windows.
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
};
const $a7842bd46cb2b669$var$makeDir = async (input, options)=>{
    $a7842bd46cb2b669$var$checkPath(input);
    options = $a7842bd46cb2b669$var$processOptions(options);
    const mkdir = $a7842bd46cb2b669$require$promisify(options.fs.mkdir);
    const stat = $a7842bd46cb2b669$require$promisify(options.fs.stat);
    if ($a7842bd46cb2b669$var$useNativeRecursiveOption && options.fs.mkdir === $dAk3n$fs.mkdir) {
        const pth = $dAk3n$path.resolve(input);
        await mkdir(pth, {
            mode: options.mode,
            recursive: true
        });
        return pth;
    }
    const make = async (pth)=>{
        try {
            await mkdir(pth, options.mode);
            return pth;
        } catch (error) {
            if (error.code === "EPERM") throw error;
            if (error.code === "ENOENT") {
                if ($dAk3n$path.dirname(pth) === pth) throw $a7842bd46cb2b669$var$permissionError(pth);
                if (error.message.includes("null bytes")) throw error;
                await make($dAk3n$path.dirname(pth));
                return make(pth);
            }
            try {
                const stats = await stat(pth);
                if (!stats.isDirectory()) throw new Error("The path is not a directory");
            } catch  {
                throw error;
            }
            return pth;
        }
    };
    return make($dAk3n$path.resolve(input));
};
$a7842bd46cb2b669$exports = $a7842bd46cb2b669$var$makeDir;
$a7842bd46cb2b669$exports.sync = (input, options)=>{
    $a7842bd46cb2b669$var$checkPath(input);
    options = $a7842bd46cb2b669$var$processOptions(options);
    if ($a7842bd46cb2b669$var$useNativeRecursiveOption && options.fs.mkdirSync === $dAk3n$fs.mkdirSync) {
        const pth = $dAk3n$path.resolve(input);
        $dAk3n$fs.mkdirSync(pth, {
            mode: options.mode,
            recursive: true
        });
        return pth;
    }
    const make = (pth)=>{
        try {
            options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
            if (error.code === "EPERM") throw error;
            if (error.code === "ENOENT") {
                if ($dAk3n$path.dirname(pth) === pth) throw $a7842bd46cb2b669$var$permissionError(pth);
                if (error.message.includes("null bytes")) throw error;
                make($dAk3n$path.dirname(pth));
                return make(pth);
            }
            try {
                if (!options.fs.statSync(pth).isDirectory()) throw new Error("The path is not a directory");
            } catch  {
                throw error;
            }
        }
        return pth;
    };
    return make($dAk3n$path.resolve(input));
};


class $55a690c69766617c$export$66d311bf29d5c89c extends Error {
    constructor(message){
        super(message);
        this.name = "TimeoutError";
    }
}
class $55a690c69766617c$export$18b052ffd8c84d7 extends Error {
    constructor(message){
        super();
        this.name = "AbortError";
        this.message = message;
    }
}
/**
TODO: Remove AbortError and just throw DOMException when targeting Node 18.
*/ const $55a690c69766617c$var$getDOMException = (errorMessage)=>globalThis.DOMException === undefined ? new $55a690c69766617c$export$18b052ffd8c84d7(errorMessage) : new DOMException(errorMessage);
/**
TODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.
*/ const $55a690c69766617c$var$getAbortedReason = (signal)=>{
    const reason = signal.reason === undefined ? $55a690c69766617c$var$getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : $55a690c69766617c$var$getDOMException(reason);
};
function $55a690c69766617c$export$2e2bcd8739ae039(promise, options) {
    const { milliseconds: milliseconds, fallback: fallback, message: message, customTimers: customTimers = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout
    } } = options;
    let timer;
    const wrappedPromise = new Promise((resolve, reject)=>{
        if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
        if (options.signal) {
            const { signal: signal } = options;
            if (signal.aborted) reject($55a690c69766617c$var$getAbortedReason(signal));
            signal.addEventListener("abort", ()=>{
                reject($55a690c69766617c$var$getAbortedReason(signal));
            });
        }
        if (milliseconds === Number.POSITIVE_INFINITY) {
            promise.then(resolve, reject);
            return;
        }
        // We create the error outside of `setTimeout` to preserve the stack trace.
        const timeoutError = new $55a690c69766617c$export$66d311bf29d5c89c();
        timer = customTimers.setTimeout.call(undefined, ()=>{
            if (fallback) {
                try {
                    resolve(fallback());
                } catch (error) {
                    reject(error);
                }
                return;
            }
            if (typeof promise.cancel === "function") promise.cancel();
            if (message === false) resolve();
            else if (message instanceof Error) reject(message);
            else {
                timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
                reject(timeoutError);
            }
        }, milliseconds);
        (async ()=>{
            try {
                resolve(await promise);
            } catch (error) {
                reject(error);
            }
        })();
    });
    const cancelablePromise = wrappedPromise.finally(()=>{
        cancelablePromise.clear();
    });
    cancelablePromise.clear = ()=>{
        customTimers.clearTimeout.call(undefined, timer);
        timer = undefined;
    };
    return cancelablePromise;
}


const $ed364ba513f2e1b3$var$normalizeEmitter = (emitter)=>{
    const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
    if (!addListener || !removeListener) throw new TypeError("Emitter is not compatible");
    return {
        addListener: addListener.bind(emitter),
        removeListener: removeListener.bind(emitter)
    };
};
function $ed364ba513f2e1b3$export$2c4a4c4b47fca7e3(emitter, event, options) {
    let cancel;
    const returnValue = new Promise((resolve, reject)=>{
        options = {
            rejectionEvents: [
                "error"
            ],
            multiArgs: false,
            resolveImmediately: false,
            ...options
        };
        if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) throw new TypeError("The `count` option should be at least 0 or more");
        options.signal?.throwIfAborted();
        // Allow multiple events
        const events = [
            event
        ].flat();
        const items = [];
        const { addListener: addListener, removeListener: removeListener } = $ed364ba513f2e1b3$var$normalizeEmitter(emitter);
        const onItem = (...arguments_)=>{
            const value = options.multiArgs ? arguments_ : arguments_[0];
            // eslint-disable-next-line unicorn/no-array-callback-reference
            if (options.filter && !options.filter(value)) return;
            items.push(value);
            if (options.count === items.length) {
                cancel();
                resolve(items);
            }
        };
        const rejectHandler = (error)=>{
            cancel();
            reject(error);
        };
        cancel = ()=>{
            for (const event of events)removeListener(event, onItem);
            for (const rejectionEvent of options.rejectionEvents)removeListener(rejectionEvent, rejectHandler);
        };
        for (const event of events)addListener(event, onItem);
        for (const rejectionEvent of options.rejectionEvents)addListener(rejectionEvent, rejectHandler);
        if (options.signal) options.signal.addEventListener("abort", ()=>{
            rejectHandler(options.signal.reason);
        }, {
            once: true
        });
        if (options.resolveImmediately) resolve(items);
    });
    returnValue.cancel = cancel;
    if (typeof options.timeout === "number") {
        const timeout = (0, $55a690c69766617c$export$2e2bcd8739ae039)(returnValue, {
            milliseconds: options.timeout
        });
        timeout.cancel = cancel;
        return timeout;
    }
    return returnValue;
}
function $ed364ba513f2e1b3$export$9f6cfc81102a9fd9(emitter, event, options) {
    if (typeof options === "function") options = {
        filter: options
    };
    options = {
        ...options,
        count: 1,
        resolveImmediately: false
    };
    const arrayPromise = $ed364ba513f2e1b3$export$2c4a4c4b47fca7e3(emitter, event, options);
    const promise = arrayPromise.then((array)=>array[0]);
    promise.cancel = arrayPromise.cancel;
    return promise;
}
function $ed364ba513f2e1b3$export$b7721d92058efe1b(emitter, event, options) {
    if (typeof options === "function") options = {
        filter: options
    };
    // Allow multiple events
    const events = [
        event
    ].flat();
    options = {
        rejectionEvents: [
            "error"
        ],
        resolutionEvents: [],
        limit: Number.POSITIVE_INFINITY,
        multiArgs: false,
        ...options
    };
    const { limit: limit } = options;
    const isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));
    if (!isValidLimit) throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
    options.signal?.throwIfAborted();
    if (limit === 0) // Return an empty async iterator to avoid any further cost
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        async next () {
            return {
                done: true,
                value: undefined
            };
        }
    };
    const { addListener: addListener, removeListener: removeListener } = $ed364ba513f2e1b3$var$normalizeEmitter(emitter);
    let isDone = false;
    let error;
    let hasPendingError = false;
    const nextQueue = [];
    const valueQueue = [];
    let eventCount = 0;
    let isLimitReached = false;
    const valueHandler = (...arguments_)=>{
        eventCount++;
        isLimitReached = eventCount === limit;
        const value = options.multiArgs ? arguments_ : arguments_[0];
        if (nextQueue.length > 0) {
            const { resolve: resolve } = nextQueue.shift();
            resolve({
                done: false,
                value: value
            });
            if (isLimitReached) cancel();
            return;
        }
        valueQueue.push(value);
        if (isLimitReached) cancel();
    };
    const cancel = ()=>{
        isDone = true;
        for (const event of events)removeListener(event, valueHandler);
        for (const rejectionEvent of options.rejectionEvents)removeListener(rejectionEvent, rejectHandler);
        for (const resolutionEvent of options.resolutionEvents)removeListener(resolutionEvent, resolveHandler);
        while(nextQueue.length > 0){
            const { resolve: resolve } = nextQueue.shift();
            resolve({
                done: true,
                value: undefined
            });
        }
    };
    const rejectHandler = (...arguments_)=>{
        error = options.multiArgs ? arguments_ : arguments_[0];
        if (nextQueue.length > 0) {
            const { reject: reject } = nextQueue.shift();
            reject(error);
        } else hasPendingError = true;
        cancel();
    };
    const resolveHandler = (...arguments_)=>{
        const value = options.multiArgs ? arguments_ : arguments_[0];
        // eslint-disable-next-line unicorn/no-array-callback-reference
        if (options.filter && !options.filter(value)) {
            cancel();
            return;
        }
        if (nextQueue.length > 0) {
            const { resolve: resolve } = nextQueue.shift();
            resolve({
                done: true,
                value: value
            });
        } else valueQueue.push(value);
        cancel();
    };
    for (const event of events)addListener(event, valueHandler);
    for (const rejectionEvent of options.rejectionEvents)addListener(rejectionEvent, rejectHandler);
    for (const resolutionEvent of options.resolutionEvents)addListener(resolutionEvent, resolveHandler);
    if (options.signal) options.signal.addEventListener("abort", ()=>{
        rejectHandler(options.signal.reason);
    }, {
        once: true
    });
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        async next () {
            if (valueQueue.length > 0) {
                const value = valueQueue.shift();
                return {
                    done: isDone && valueQueue.length === 0 && !isLimitReached,
                    value: value
                };
            }
            if (hasPendingError) {
                hasPendingError = false;
                throw error;
            }
            if (isDone) return {
                done: true,
                value: undefined
            };
            return new Promise((resolve, reject)=>{
                nextQueue.push({
                    resolve: resolve,
                    reject: reject
                });
            });
        },
        async return (value) {
            cancel();
            return {
                done: isDone,
                value: value
            };
        }
    };
}


const $ba32fe0881171a38$var$filenameFromPath = (res)=>(0, ($parcel$interopDefault($dAk3n$nodepath))).basename(new URL(res.requestUrl).pathname);
const $ba32fe0881171a38$var$getExtFromMime = (res)=>{
    const header = res.headers["content-type"];
    if (!header) return null;
    const exts = (0, (/*@__PURE__*/$parcel$interopDefault($40583aba8cfcb18f$exports))).mime(header);
    if (exts.length !== 1) return null;
    return exts[0].ext;
};
const $ba32fe0881171a38$var$getFilename = async (res, data)=>{
    const header = res.headers["content-disposition"];
    if (header) {
        const parsed = (0, (/*@__PURE__*/$parcel$interopDefault($a11285a33b616655$exports))).parse(header);
        return parsed.parameters.filename;
    }
    let filename = $ba32fe0881171a38$var$filenameFromPath(res);
    if (!(0, ($parcel$interopDefault($dAk3n$nodepath))).extname(filename)) {
        const fileType = await (0, $599ba2eea70127a0$export$79017d38a9b78817)((0, $dAk3n$nodebuffer.Buffer).from(data));
        const ext = fileType?.ext ?? $ba32fe0881171a38$var$getExtFromMime(res);
        if (ext) filename = `${filename}.${ext}`;
    }
    return filename;
};
function $ba32fe0881171a38$export$2e2bcd8739ae039(uri, destinationOrOptions, maybeOptions) {
    const destination = typeof destinationOrOptions === "string" ? destinationOrOptions : undefined;
    const optionsArg = typeof destinationOrOptions === "object" ? destinationOrOptions : maybeOptions;
    const options = {
        responseType: "buffer",
        ...optionsArg,
        isStream: true
    };
    const gotOptions = (0, $a29840a000f7ad37$export$2e2bcd8739ae039)(options, [
        "filename",
        "extract"
    ]);
    const stream = (0, $bf9770f9fe4e4d36$export$2e2bcd8739ae039).stream(uri, gotOptions);
    const promise = (0, $ed364ba513f2e1b3$export$9f6cfc81102a9fd9)(stream, "response").then(async (res)=>Promise.all([
            (0, $71a07105f89a05cf$export$7043a390e4973a6)(stream),
            res
        ])).then(async (result)=>{
        const [data, res] = result;
        if (!destination) return options.extract && (0, (/*@__PURE__*/$parcel$interopDefault($24ac6a41d0d29df9$exports)))(data) ? (0, (/*@__PURE__*/$parcel$interopDefault($f51ecae46f19a31a$exports)))(data, options.extract) : data;
        const filename = options.filename ?? (0, $07f9ea496e66e115$export$2e2bcd8739ae039)(await $ba32fe0881171a38$var$getFilename(res, data));
        const outputFilepath = (0, ($parcel$interopDefault($dAk3n$nodepath))).join(destination, filename);
        if (options.extract && (0, (/*@__PURE__*/$parcel$interopDefault($24ac6a41d0d29df9$exports)))(data)) return (0, (/*@__PURE__*/$parcel$interopDefault($f51ecae46f19a31a$exports)))(data, (0, ($parcel$interopDefault($dAk3n$nodepath))).dirname(outputFilepath), options.extract);
        return (0, (/*@__PURE__*/$parcel$interopDefault($a7842bd46cb2b669$exports)))((0, ($parcel$interopDefault($dAk3n$nodepath))).dirname(outputFilepath)).then(async ()=>(0, ($parcel$interopDefault($dAk3n$nodefs))).promises.writeFile(outputFilepath, data)).then(()=>data);
    });
    // @ts-expect-error: we want to make stream a promise
    // eslint-disable-next-line unicorn/no-thenable -- we want to make stream a promise
    stream.then = promise.then.bind(promise);
    // @ts-expect-error: we want to make stream a promise
    stream.catch = promise.catch.bind(promise);
    // @ts-expect-error: we want to make stream a promise
    stream.finally = promise.finally.bind(promise);
    return stream;
}








function $865d9c3319d37e5b$export$62ef9d444c3dc9b3({ supportedTargetString: supportedTargetString, version: version }) {
    return (0, $339004cb28bc6ac3$export$ffb5f4729a158638).join((0, ($parcel$interopDefault($dAk3n$nodeos))).homedir(), ".tunnel/cli-single-executable-application", supportedTargetString, version);
}



const $c428999a5d9443c2$var$ANSI_BACKGROUND_OFFSET = 10;
const $c428999a5d9443c2$var$wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
const $c428999a5d9443c2$var$wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
const $c428999a5d9443c2$var$wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
const $c428999a5d9443c2$var$styles = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
const $c428999a5d9443c2$export$3348c8f862b779ea = Object.keys($c428999a5d9443c2$var$styles.modifier);
const $c428999a5d9443c2$export$b42573f554ad2328 = Object.keys($c428999a5d9443c2$var$styles.color);
const $c428999a5d9443c2$export$e9149c7dc90ec5a1 = Object.keys($c428999a5d9443c2$var$styles.bgColor);
const $c428999a5d9443c2$export$88bbe6beac980300 = [
    ...$c428999a5d9443c2$export$b42573f554ad2328,
    ...$c428999a5d9443c2$export$e9149c7dc90ec5a1
];
function $c428999a5d9443c2$var$assembleStyles() {
    const codes = new Map();
    for (const [groupName, group] of Object.entries($c428999a5d9443c2$var$styles)){
        for (const [styleName, style] of Object.entries(group)){
            $c428999a5d9443c2$var$styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = $c428999a5d9443c2$var$styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty($c428999a5d9443c2$var$styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty($c428999a5d9443c2$var$styles, "codes", {
        value: codes,
        enumerable: false
    });
    $c428999a5d9443c2$var$styles.color.close = "\x1b[39m";
    $c428999a5d9443c2$var$styles.bgColor.close = "\x1b[49m";
    $c428999a5d9443c2$var$styles.color.ansi = $c428999a5d9443c2$var$wrapAnsi16();
    $c428999a5d9443c2$var$styles.color.ansi256 = $c428999a5d9443c2$var$wrapAnsi256();
    $c428999a5d9443c2$var$styles.color.ansi16m = $c428999a5d9443c2$var$wrapAnsi16m();
    $c428999a5d9443c2$var$styles.bgColor.ansi = $c428999a5d9443c2$var$wrapAnsi16($c428999a5d9443c2$var$ANSI_BACKGROUND_OFFSET);
    $c428999a5d9443c2$var$styles.bgColor.ansi256 = $c428999a5d9443c2$var$wrapAnsi256($c428999a5d9443c2$var$ANSI_BACKGROUND_OFFSET);
    $c428999a5d9443c2$var$styles.bgColor.ansi16m = $c428999a5d9443c2$var$wrapAnsi16m($c428999a5d9443c2$var$ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties($c428999a5d9443c2$var$styles, {
        rgbToAnsi256: {
            value (red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) return 16;
                    if (red > 248) return 231;
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value (hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) return [
                    0,
                    0,
                    0
                ];
                let [colorString] = matches;
                if (colorString.length === 3) colorString = [
                    ...colorString
                ].map((character)=>character + character).join("");
                const integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: (hex)=>$c428999a5d9443c2$var$styles.rgbToAnsi256(...$c428999a5d9443c2$var$styles.hexToRgb(hex)),
            enumerable: false
        },
        ansi256ToAnsi: {
            value (code) {
                if (code < 8) return 30 + code;
                if (code < 16) return 90 + (code - 8);
                let red;
                let green;
                let blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    const remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                const value = Math.max(red, green, blue) * 2;
                if (value === 0) return 30;
                // eslint-disable-next-line no-bitwise
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) result += 60;
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: (red, green, blue)=>$c428999a5d9443c2$var$styles.ansi256ToAnsi($c428999a5d9443c2$var$styles.rgbToAnsi256(red, green, blue)),
            enumerable: false
        },
        hexToAnsi: {
            value: (hex)=>$c428999a5d9443c2$var$styles.ansi256ToAnsi($c428999a5d9443c2$var$styles.hexToAnsi256(hex)),
            enumerable: false
        }
    });
    return $c428999a5d9443c2$var$styles;
}
const $c428999a5d9443c2$var$ansiStyles = $c428999a5d9443c2$var$assembleStyles();
var $c428999a5d9443c2$export$2e2bcd8739ae039 = $c428999a5d9443c2$var$ansiStyles;





// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function $4cb9659e61fd69bc$var$hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : (0, ($parcel$interopDefault($dAk3n$nodeprocess))).argv) {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env: $4cb9659e61fd69bc$var$env } = (0, ($parcel$interopDefault($dAk3n$nodeprocess)));
let $4cb9659e61fd69bc$var$flagForceColor;
if ($4cb9659e61fd69bc$var$hasFlag("no-color") || $4cb9659e61fd69bc$var$hasFlag("no-colors") || $4cb9659e61fd69bc$var$hasFlag("color=false") || $4cb9659e61fd69bc$var$hasFlag("color=never")) $4cb9659e61fd69bc$var$flagForceColor = 0;
else if ($4cb9659e61fd69bc$var$hasFlag("color") || $4cb9659e61fd69bc$var$hasFlag("colors") || $4cb9659e61fd69bc$var$hasFlag("color=true") || $4cb9659e61fd69bc$var$hasFlag("color=always")) $4cb9659e61fd69bc$var$flagForceColor = 1;
function $4cb9659e61fd69bc$var$envForceColor() {
    if ("FORCE_COLOR" in $4cb9659e61fd69bc$var$env) {
        if ($4cb9659e61fd69bc$var$env.FORCE_COLOR === "true") return 1;
        if ($4cb9659e61fd69bc$var$env.FORCE_COLOR === "false") return 0;
        return $4cb9659e61fd69bc$var$env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt($4cb9659e61fd69bc$var$env.FORCE_COLOR, 10), 3);
    }
}
function $4cb9659e61fd69bc$var$translateLevel(level) {
    if (level === 0) return false;
    return {
        level: level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function $4cb9659e61fd69bc$var$_supportsColor(haveStream, { streamIsTTY: streamIsTTY, sniffFlags: sniffFlags = true } = {}) {
    const noFlagForceColor = $4cb9659e61fd69bc$var$envForceColor();
    if (noFlagForceColor !== undefined) $4cb9659e61fd69bc$var$flagForceColor = noFlagForceColor;
    const forceColor = sniffFlags ? $4cb9659e61fd69bc$var$flagForceColor : noFlagForceColor;
    if (forceColor === 0) return 0;
    if (sniffFlags) {
        if ($4cb9659e61fd69bc$var$hasFlag("color=16m") || $4cb9659e61fd69bc$var$hasFlag("color=full") || $4cb9659e61fd69bc$var$hasFlag("color=truecolor")) return 3;
        if ($4cb9659e61fd69bc$var$hasFlag("color=256")) return 2;
    }
    // Check for Azure DevOps pipelines.
    // Has to be above the `!streamIsTTY` check.
    if ("TF_BUILD" in $4cb9659e61fd69bc$var$env && "AGENT_NAME" in $4cb9659e61fd69bc$var$env) return 1;
    if (haveStream && !streamIsTTY && forceColor === undefined) return 0;
    const min = forceColor || 0;
    if ($4cb9659e61fd69bc$var$env.TERM === "dumb") return min;
    if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).platform === "win32") {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = (0, ($parcel$interopDefault($dAk3n$nodeos))).release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
        return 1;
    }
    if ("CI" in $4cb9659e61fd69bc$var$env) {
        if ("GITHUB_ACTIONS" in $4cb9659e61fd69bc$var$env || "GITEA_ACTIONS" in $4cb9659e61fd69bc$var$env) return 3;
        if ([
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "BUILDKITE",
            "DRONE"
        ].some((sign)=>sign in $4cb9659e61fd69bc$var$env) || $4cb9659e61fd69bc$var$env.CI_NAME === "codeship") return 1;
        return min;
    }
    if ("TEAMCITY_VERSION" in $4cb9659e61fd69bc$var$env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test($4cb9659e61fd69bc$var$env.TEAMCITY_VERSION) ? 1 : 0;
    if ($4cb9659e61fd69bc$var$env.COLORTERM === "truecolor") return 3;
    if ($4cb9659e61fd69bc$var$env.TERM === "xterm-kitty") return 3;
    if ("TERM_PROGRAM" in $4cb9659e61fd69bc$var$env) {
        const version = Number.parseInt(($4cb9659e61fd69bc$var$env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch($4cb9659e61fd69bc$var$env.TERM_PROGRAM){
            case "iTerm.app":
                return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    if (/-256(color)?$/i.test($4cb9659e61fd69bc$var$env.TERM)) return 2;
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test($4cb9659e61fd69bc$var$env.TERM)) return 1;
    if ("COLORTERM" in $4cb9659e61fd69bc$var$env) return 1;
    return min;
}
function $4cb9659e61fd69bc$export$6f279ba00f1459de(stream, options = {}) {
    const level = $4cb9659e61fd69bc$var$_supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return $4cb9659e61fd69bc$var$translateLevel(level);
}
const $4cb9659e61fd69bc$var$supportsColor = {
    stdout: $4cb9659e61fd69bc$export$6f279ba00f1459de({
        isTTY: (0, ($parcel$interopDefault($dAk3n$nodetty))).isatty(1)
    }),
    stderr: $4cb9659e61fd69bc$export$6f279ba00f1459de({
        isTTY: (0, ($parcel$interopDefault($dAk3n$nodetty))).isatty(2)
    })
};
var $4cb9659e61fd69bc$export$2e2bcd8739ae039 = $4cb9659e61fd69bc$var$supportsColor;


// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function $0c5291d5bb647cdc$export$9300dfb554c6c407(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) return string;
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
        returnValue += string.slice(endIndex, index) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
}
function $0c5291d5bb647cdc$export$ecabf4aff2e9764(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = "";
    do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
    }while (index !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
}



const { stdout: $08c9c3830789cde8$export$fcbe44f5d6fcebd, stderr: $08c9c3830789cde8$export$8107055a758cd2bd } = (0, $4cb9659e61fd69bc$export$2e2bcd8739ae039);
const $08c9c3830789cde8$var$GENERATOR = Symbol("GENERATOR");
const $08c9c3830789cde8$var$STYLER = Symbol("STYLER");
const $08c9c3830789cde8$var$IS_EMPTY = Symbol("IS_EMPTY");
// `supportsColor.level` → `ansiStyles.color[name]` mapping
const $08c9c3830789cde8$var$levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
];
const $08c9c3830789cde8$var$styles = Object.create(null);
const $08c9c3830789cde8$var$applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
    // Detect level if not set manually
    const colorLevel = $08c9c3830789cde8$export$fcbe44f5d6fcebd ? $08c9c3830789cde8$export$fcbe44f5d6fcebd.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class $08c9c3830789cde8$export$79544b80b91c2197 {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return $08c9c3830789cde8$var$chalkFactory(options);
    }
}
const $08c9c3830789cde8$var$chalkFactory = (options)=>{
    const chalk = (...strings)=>strings.join(" ");
    $08c9c3830789cde8$var$applyOptions(chalk, options);
    Object.setPrototypeOf(chalk, $08c9c3830789cde8$var$createChalk.prototype);
    return chalk;
};
function $08c9c3830789cde8$var$createChalk(options) {
    return $08c9c3830789cde8$var$chalkFactory(options);
}
Object.setPrototypeOf($08c9c3830789cde8$var$createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries((0, $c428999a5d9443c2$export$2e2bcd8739ae039)))$08c9c3830789cde8$var$styles[styleName] = {
    get () {
        const builder = $08c9c3830789cde8$var$createBuilder(this, $08c9c3830789cde8$var$createStyler(style.open, style.close, this[$08c9c3830789cde8$var$STYLER]), this[$08c9c3830789cde8$var$IS_EMPTY]);
        Object.defineProperty(this, styleName, {
            value: builder
        });
        return builder;
    }
};
$08c9c3830789cde8$var$styles.visible = {
    get () {
        const builder = $08c9c3830789cde8$var$createBuilder(this, this[$08c9c3830789cde8$var$STYLER], true);
        Object.defineProperty(this, "visible", {
            value: builder
        });
        return builder;
    }
};
const $08c9c3830789cde8$var$getModelAnsi = (model, level, type, ...arguments_)=>{
    if (model === "rgb") {
        if (level === "ansi16m") return (0, $c428999a5d9443c2$export$2e2bcd8739ae039)[type].ansi16m(...arguments_);
        if (level === "ansi256") return (0, $c428999a5d9443c2$export$2e2bcd8739ae039)[type].ansi256((0, $c428999a5d9443c2$export$2e2bcd8739ae039).rgbToAnsi256(...arguments_));
        return (0, $c428999a5d9443c2$export$2e2bcd8739ae039)[type].ansi((0, $c428999a5d9443c2$export$2e2bcd8739ae039).rgbToAnsi(...arguments_));
    }
    if (model === "hex") return $08c9c3830789cde8$var$getModelAnsi("rgb", level, type, ...(0, $c428999a5d9443c2$export$2e2bcd8739ae039).hexToRgb(...arguments_));
    return (0, $c428999a5d9443c2$export$2e2bcd8739ae039)[type][model](...arguments_);
};
const $08c9c3830789cde8$var$usedModels = [
    "rgb",
    "hex",
    "ansi256"
];
for (const model of $08c9c3830789cde8$var$usedModels){
    $08c9c3830789cde8$var$styles[model] = {
        get () {
            const { level: level } = this;
            return function(...arguments_) {
                const styler = $08c9c3830789cde8$var$createStyler($08c9c3830789cde8$var$getModelAnsi(model, $08c9c3830789cde8$var$levelMapping[level], "color", ...arguments_), (0, $c428999a5d9443c2$export$2e2bcd8739ae039).color.close, this[$08c9c3830789cde8$var$STYLER]);
                return $08c9c3830789cde8$var$createBuilder(this, styler, this[$08c9c3830789cde8$var$IS_EMPTY]);
            };
        }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    $08c9c3830789cde8$var$styles[bgModel] = {
        get () {
            const { level: level } = this;
            return function(...arguments_) {
                const styler = $08c9c3830789cde8$var$createStyler($08c9c3830789cde8$var$getModelAnsi(model, $08c9c3830789cde8$var$levelMapping[level], "bgColor", ...arguments_), (0, $c428999a5d9443c2$export$2e2bcd8739ae039).bgColor.close, this[$08c9c3830789cde8$var$STYLER]);
                return $08c9c3830789cde8$var$createBuilder(this, styler, this[$08c9c3830789cde8$var$IS_EMPTY]);
            };
        }
    };
}
const $08c9c3830789cde8$var$proto = Object.defineProperties(()=>{}, {
    ...$08c9c3830789cde8$var$styles,
    level: {
        enumerable: true,
        get () {
            return this[$08c9c3830789cde8$var$GENERATOR].level;
        },
        set (level) {
            this[$08c9c3830789cde8$var$GENERATOR].level = level;
        }
    }
});
const $08c9c3830789cde8$var$createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open: open,
        close: close,
        openAll: openAll,
        closeAll: closeAll,
        parent: parent
    };
};
const $08c9c3830789cde8$var$createBuilder = (self, _styler, _isEmpty)=>{
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    const builder = (...arguments_)=>$08c9c3830789cde8$var$applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, $08c9c3830789cde8$var$proto);
    builder[$08c9c3830789cde8$var$GENERATOR] = self;
    builder[$08c9c3830789cde8$var$STYLER] = _styler;
    builder[$08c9c3830789cde8$var$IS_EMPTY] = _isEmpty;
    return builder;
};
const $08c9c3830789cde8$var$applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) return self[$08c9c3830789cde8$var$IS_EMPTY] ? "" : string;
    let styler = self[$08c9c3830789cde8$var$STYLER];
    if (styler === undefined) return string;
    const { openAll: openAll, closeAll: closeAll } = styler;
    if (string.includes("\x1b")) while(styler !== undefined){
        // Replace any instances already present with a re-opening code
        // otherwise only the part of the string until said closing code
        // will be colored, and the rest will simply be 'plain'.
        string = (0, $0c5291d5bb647cdc$export$9300dfb554c6c407)(string, styler.close, styler.open);
        styler = styler.parent;
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) string = (0, $0c5291d5bb647cdc$export$ecabf4aff2e9764)(string, closeAll, openAll, lfIndex);
    return openAll + string + closeAll;
};
Object.defineProperties($08c9c3830789cde8$var$createChalk.prototype, $08c9c3830789cde8$var$styles);
const $08c9c3830789cde8$var$chalk = $08c9c3830789cde8$var$createChalk();
const $08c9c3830789cde8$export$8cef8185e551afa5 = $08c9c3830789cde8$var$createChalk({
    level: $08c9c3830789cde8$export$8107055a758cd2bd ? $08c9c3830789cde8$export$8107055a758cd2bd.level : 0
});
var $08c9c3830789cde8$export$2e2bcd8739ae039 = $08c9c3830789cde8$var$chalk;




var $faf24c7da0c156d2$exports = {};
"use strict";
var $31458806b8dde0b5$exports = {};
"use strict";
const $31458806b8dde0b5$var$mimicFn = (to, from)=>{
    for (const prop of Reflect.ownKeys(from))Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    return to;
};
$31458806b8dde0b5$exports = $31458806b8dde0b5$var$mimicFn;
// TODO: Remove this for the next major release
$31458806b8dde0b5$exports.default = $31458806b8dde0b5$var$mimicFn;


const $faf24c7da0c156d2$var$calledFunctions = new WeakMap();
const $faf24c7da0c156d2$var$onetime = (function_, options = {})=>{
    if (typeof function_ !== "function") throw new TypeError("Expected a function");
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime = function(...arguments_) {
        $faf24c7da0c156d2$var$calledFunctions.set(onetime, ++callCount);
        if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
        } else if (options.throw === true) throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
    };
    $31458806b8dde0b5$exports(onetime, function_);
    $faf24c7da0c156d2$var$calledFunctions.set(onetime, callCount);
    return onetime;
};
$faf24c7da0c156d2$exports = $faf24c7da0c156d2$var$onetime;
// TODO: Remove this for the next major release
$faf24c7da0c156d2$exports.default = $faf24c7da0c156d2$var$onetime;
$faf24c7da0c156d2$exports.callCount = (function_)=>{
    if (!$faf24c7da0c156d2$var$calledFunctions.has(function_)) throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return $faf24c7da0c156d2$var$calledFunctions.get(function_);
};


var $d8ec971a393cb0ad$exports = {};
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var $d8ec971a393cb0ad$var$process = $parcel$global.process;
const $d8ec971a393cb0ad$var$processOk = function(process) {
    return process && typeof process === "object" && typeof process.removeListener === "function" && typeof process.emit === "function" && typeof process.reallyExit === "function" && typeof process.listeners === "function" && typeof process.kill === "function" && typeof process.pid === "number" && typeof process.on === "function";
};



// some kind of non-node environment, just no-op
/* istanbul ignore if */ if (!$d8ec971a393cb0ad$var$processOk($d8ec971a393cb0ad$var$process)) $d8ec971a393cb0ad$exports = function() {
    return function() {};
};
else {
    var $d8ec971a393cb0ad$var$assert = $dAk3n$assert;
    var $d8ec971a393cb0ad$var$signals = (parcelRequire("jB1CW"));
    var $d8ec971a393cb0ad$var$isWin = /^win/i.test($d8ec971a393cb0ad$var$process.platform);
    var $d8ec971a393cb0ad$var$EE = $dAk3n$events;
    /* istanbul ignore if */ if (typeof $d8ec971a393cb0ad$var$EE !== "function") $d8ec971a393cb0ad$var$EE = $d8ec971a393cb0ad$var$EE.EventEmitter;
    var $d8ec971a393cb0ad$var$emitter;
    if ($d8ec971a393cb0ad$var$process.__signal_exit_emitter__) $d8ec971a393cb0ad$var$emitter = $d8ec971a393cb0ad$var$process.__signal_exit_emitter__;
    else {
        $d8ec971a393cb0ad$var$emitter = $d8ec971a393cb0ad$var$process.__signal_exit_emitter__ = new $d8ec971a393cb0ad$var$EE();
        $d8ec971a393cb0ad$var$emitter.count = 0;
        $d8ec971a393cb0ad$var$emitter.emitted = {};
    }
    // Because this emitter is a global, we have to check to see if a
    // previous version of this library failed to enable infinite listeners.
    // I know what you're about to say.  But literally everything about
    // signal-exit is a compromise with evil.  Get used to it.
    if (!$d8ec971a393cb0ad$var$emitter.infinite) {
        $d8ec971a393cb0ad$var$emitter.setMaxListeners(Infinity);
        $d8ec971a393cb0ad$var$emitter.infinite = true;
    }
    $d8ec971a393cb0ad$exports = function(cb, opts) {
        /* istanbul ignore if */ if (!$d8ec971a393cb0ad$var$processOk($parcel$global.process)) return function() {};
        $d8ec971a393cb0ad$var$assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if ($d8ec971a393cb0ad$var$loaded === false) $d8ec971a393cb0ad$var$load();
        var ev = "exit";
        if (opts && opts.alwaysLast) ev = "afterexit";
        var remove = function() {
            $d8ec971a393cb0ad$var$emitter.removeListener(ev, cb);
            if ($d8ec971a393cb0ad$var$emitter.listeners("exit").length === 0 && $d8ec971a393cb0ad$var$emitter.listeners("afterexit").length === 0) $d8ec971a393cb0ad$var$unload();
        };
        $d8ec971a393cb0ad$var$emitter.on(ev, cb);
        return remove;
    };
    var $d8ec971a393cb0ad$var$unload = function unload() {
        if (!$d8ec971a393cb0ad$var$loaded || !$d8ec971a393cb0ad$var$processOk($parcel$global.process)) return;
        $d8ec971a393cb0ad$var$loaded = false;
        $d8ec971a393cb0ad$var$signals.forEach(function(sig) {
            try {
                $d8ec971a393cb0ad$var$process.removeListener(sig, $d8ec971a393cb0ad$var$sigListeners[sig]);
            } catch (er) {}
        });
        $d8ec971a393cb0ad$var$process.emit = $d8ec971a393cb0ad$var$originalProcessEmit;
        $d8ec971a393cb0ad$var$process.reallyExit = $d8ec971a393cb0ad$var$originalProcessReallyExit;
        $d8ec971a393cb0ad$var$emitter.count -= 1;
    };
    $d8ec971a393cb0ad$exports.unload = $d8ec971a393cb0ad$var$unload;
    var $d8ec971a393cb0ad$var$emit = function emit(event, code, signal) {
        /* istanbul ignore if */ if ($d8ec971a393cb0ad$var$emitter.emitted[event]) return;
        $d8ec971a393cb0ad$var$emitter.emitted[event] = true;
        $d8ec971a393cb0ad$var$emitter.emit(event, code, signal);
    };
    // { <signal>: <listener fn>, ... }
    var $d8ec971a393cb0ad$var$sigListeners = {};
    $d8ec971a393cb0ad$var$signals.forEach(function(sig) {
        $d8ec971a393cb0ad$var$sigListeners[sig] = function listener() {
            /* istanbul ignore if */ if (!$d8ec971a393cb0ad$var$processOk($parcel$global.process)) return;
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            var listeners = $d8ec971a393cb0ad$var$process.listeners(sig);
            if (listeners.length === $d8ec971a393cb0ad$var$emitter.count) {
                $d8ec971a393cb0ad$var$unload();
                $d8ec971a393cb0ad$var$emit("exit", null, sig);
                /* istanbul ignore next */ $d8ec971a393cb0ad$var$emit("afterexit", null, sig);
                /* istanbul ignore next */ if ($d8ec971a393cb0ad$var$isWin && sig === "SIGHUP") // "SIGHUP" throws an `ENOSYS` error on Windows,
                // so use a supported signal instead
                sig = "SIGINT";
                /* istanbul ignore next */ $d8ec971a393cb0ad$var$process.kill($d8ec971a393cb0ad$var$process.pid, sig);
            }
        };
    });
    $d8ec971a393cb0ad$exports.signals = function() {
        return $d8ec971a393cb0ad$var$signals;
    };
    var $d8ec971a393cb0ad$var$loaded = false;
    var $d8ec971a393cb0ad$var$load = function load() {
        if ($d8ec971a393cb0ad$var$loaded || !$d8ec971a393cb0ad$var$processOk($parcel$global.process)) return;
        $d8ec971a393cb0ad$var$loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        $d8ec971a393cb0ad$var$emitter.count += 1;
        $d8ec971a393cb0ad$var$signals = $d8ec971a393cb0ad$var$signals.filter(function(sig) {
            try {
                $d8ec971a393cb0ad$var$process.on(sig, $d8ec971a393cb0ad$var$sigListeners[sig]);
                return true;
            } catch (er) {
                return false;
            }
        });
        $d8ec971a393cb0ad$var$process.emit = $d8ec971a393cb0ad$var$processEmit;
        $d8ec971a393cb0ad$var$process.reallyExit = $d8ec971a393cb0ad$var$processReallyExit;
    };
    $d8ec971a393cb0ad$exports.load = $d8ec971a393cb0ad$var$load;
    var $d8ec971a393cb0ad$var$originalProcessReallyExit = $d8ec971a393cb0ad$var$process.reallyExit;
    var $d8ec971a393cb0ad$var$processReallyExit = function processReallyExit(code) {
        /* istanbul ignore if */ if (!$d8ec971a393cb0ad$var$processOk($parcel$global.process)) return;
        $d8ec971a393cb0ad$var$process.exitCode = code || /* istanbul ignore next */ 0;
        $d8ec971a393cb0ad$var$emit("exit", $d8ec971a393cb0ad$var$process.exitCode, null);
        /* istanbul ignore next */ $d8ec971a393cb0ad$var$emit("afterexit", $d8ec971a393cb0ad$var$process.exitCode, null);
        /* istanbul ignore next */ $d8ec971a393cb0ad$var$originalProcessReallyExit.call($d8ec971a393cb0ad$var$process, $d8ec971a393cb0ad$var$process.exitCode);
    };
    var $d8ec971a393cb0ad$var$originalProcessEmit = $d8ec971a393cb0ad$var$process.emit;
    var $d8ec971a393cb0ad$var$processEmit = function processEmit(ev, arg) {
        if (ev === "exit" && $d8ec971a393cb0ad$var$processOk($parcel$global.process)) {
            /* istanbul ignore else */ if (arg !== undefined) $d8ec971a393cb0ad$var$process.exitCode = arg;
            var ret = $d8ec971a393cb0ad$var$originalProcessEmit.apply(this, arguments);
            /* istanbul ignore next */ $d8ec971a393cb0ad$var$emit("exit", $d8ec971a393cb0ad$var$process.exitCode, null);
            /* istanbul ignore next */ $d8ec971a393cb0ad$var$emit("afterexit", $d8ec971a393cb0ad$var$process.exitCode, null);
            /* istanbul ignore next */ return ret;
        } else return $d8ec971a393cb0ad$var$originalProcessEmit.apply(this, arguments);
    };
}


const $948ec16eb309990e$var$restoreCursor = (0, (/*@__PURE__*/$parcel$interopDefault($faf24c7da0c156d2$exports)))(()=>{
    (0, (/*@__PURE__*/$parcel$interopDefault($d8ec971a393cb0ad$exports)))(()=>{
        (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stderr.write("\x1b[?25h");
    }, {
        alwaysLast: true
    });
});
var $948ec16eb309990e$export$2e2bcd8739ae039 = $948ec16eb309990e$var$restoreCursor;


let $00caa5736a546440$var$isHidden = false;
const $00caa5736a546440$var$cliCursor = {};
$00caa5736a546440$var$cliCursor.show = (writableStream = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stderr)=>{
    if (!writableStream.isTTY) return;
    $00caa5736a546440$var$isHidden = false;
    writableStream.write("\x1b[?25h");
};
$00caa5736a546440$var$cliCursor.hide = (writableStream = (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stderr)=>{
    if (!writableStream.isTTY) return;
    (0, $948ec16eb309990e$export$2e2bcd8739ae039)();
    $00caa5736a546440$var$isHidden = true;
    writableStream.write("\x1b[?25l");
};
$00caa5736a546440$var$cliCursor.toggle = (force, writableStream)=>{
    if (force !== undefined) $00caa5736a546440$var$isHidden = force;
    if ($00caa5736a546440$var$isHidden) $00caa5736a546440$var$cliCursor.show(writableStream);
    else $00caa5736a546440$var$cliCursor.hide(writableStream);
};
var $00caa5736a546440$export$2e2bcd8739ae039 = $00caa5736a546440$var$cliCursor;


var $c7ee00d8f6b7286b$exports = {};
"use strict";

const $c7ee00d8f6b7286b$var$spinners = Object.assign({}, (parcelRequire("6SGoC"))); // eslint-disable-line import/extensions
const $c7ee00d8f6b7286b$var$spinnersList = Object.keys($c7ee00d8f6b7286b$var$spinners);
Object.defineProperty($c7ee00d8f6b7286b$var$spinners, "random", {
    get () {
        const randomIndex = Math.floor(Math.random() * $c7ee00d8f6b7286b$var$spinnersList.length);
        const spinnerName = $c7ee00d8f6b7286b$var$spinnersList[randomIndex];
        return $c7ee00d8f6b7286b$var$spinners[spinnerName];
    }
});
$c7ee00d8f6b7286b$exports = $c7ee00d8f6b7286b$var$spinners;




function $cc92293829744d89$export$2e2bcd8739ae039() {
    if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).platform !== "win32") return (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERM !== "linux"; // Linux console (kernel)
    return Boolean((0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.CI) || Boolean((0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.WT_SESSION) // Windows Terminal
     || Boolean((0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERMINUS_SUBLIME) // Terminus (<0.2.27)
     || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.ConEmuTask === "{cmd::Cmder}" // ConEmu and cmder
     || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERM_PROGRAM === "Terminus-Sublime" || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERM_PROGRAM === "vscode" || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERM === "xterm-256color" || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERM === "alacritty" || (0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}


const $337332179f0ad580$var$main = {
    info: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).blue("ℹ"),
    success: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).green("✔"),
    warning: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).yellow("⚠"),
    error: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).red("✖")
};
const $337332179f0ad580$var$fallback = {
    info: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).blue("i"),
    success: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).green("√"),
    warning: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).yellow("‼"),
    error: (0, $08c9c3830789cde8$export$2e2bcd8739ae039).red("\xd7")
};
const $337332179f0ad580$var$logSymbols = (0, $cc92293829744d89$export$2e2bcd8739ae039)() ? $337332179f0ad580$var$main : $337332179f0ad580$var$fallback;
var $337332179f0ad580$export$2e2bcd8739ae039 = $337332179f0ad580$var$logSymbols;


function $450d789b0729a9fc$export$2e2bcd8739ae039({ onlyFirst: onlyFirst = false } = {}) {
    const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
}


const $1281305204dfe64a$var$regex = (0, $450d789b0729a9fc$export$2e2bcd8739ae039)();
function $1281305204dfe64a$export$2e2bcd8739ae039(string) {
    if (typeof string !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    // Even though the regex is global, we don't need to reset the `.lastIndex`
    // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
    // and doing it manually has a performance penalty.
    return string.replace($1281305204dfe64a$var$regex, "");
}



var $6ce6878769f9660b$exports = {};
var $6ce6878769f9660b$var$eaw = {};
$6ce6878769f9660b$exports = $6ce6878769f9660b$var$eaw;
$6ce6878769f9660b$var$eaw.eastAsianWidth = function(character) {
    var x = character.charCodeAt(0);
    var y = character.length == 2 ? character.charCodeAt(1) : 0;
    var codePoint = x;
    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
        x &= 0x3FF;
        y &= 0x3FF;
        codePoint = x << 10 | y;
        codePoint += 0x10000;
    }
    if (0x3000 == codePoint || 0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6) return "F";
    if (0x20A9 == codePoint || 0xFF61 <= codePoint && codePoint <= 0xFFBE || 0xFFC2 <= codePoint && codePoint <= 0xFFC7 || 0xFFCA <= codePoint && codePoint <= 0xFFCF || 0xFFD2 <= codePoint && codePoint <= 0xFFD7 || 0xFFDA <= codePoint && codePoint <= 0xFFDC || 0xFFE8 <= codePoint && codePoint <= 0xFFEE) return "H";
    if (0x1100 <= codePoint && codePoint <= 0x115F || 0x11A3 <= codePoint && codePoint <= 0x11A7 || 0x11FA <= codePoint && codePoint <= 0x11FF || 0x2329 <= codePoint && codePoint <= 0x232A || 0x2E80 <= codePoint && codePoint <= 0x2E99 || 0x2E9B <= codePoint && codePoint <= 0x2EF3 || 0x2F00 <= codePoint && codePoint <= 0x2FD5 || 0x2FF0 <= codePoint && codePoint <= 0x2FFB || 0x3001 <= codePoint && codePoint <= 0x303E || 0x3041 <= codePoint && codePoint <= 0x3096 || 0x3099 <= codePoint && codePoint <= 0x30FF || 0x3105 <= codePoint && codePoint <= 0x312D || 0x3131 <= codePoint && codePoint <= 0x318E || 0x3190 <= codePoint && codePoint <= 0x31BA || 0x31C0 <= codePoint && codePoint <= 0x31E3 || 0x31F0 <= codePoint && codePoint <= 0x321E || 0x3220 <= codePoint && codePoint <= 0x3247 || 0x3250 <= codePoint && codePoint <= 0x32FE || 0x3300 <= codePoint && codePoint <= 0x4DBF || 0x4E00 <= codePoint && codePoint <= 0xA48C || 0xA490 <= codePoint && codePoint <= 0xA4C6 || 0xA960 <= codePoint && codePoint <= 0xA97C || 0xAC00 <= codePoint && codePoint <= 0xD7A3 || 0xD7B0 <= codePoint && codePoint <= 0xD7C6 || 0xD7CB <= codePoint && codePoint <= 0xD7FB || 0xF900 <= codePoint && codePoint <= 0xFAFF || 0xFE10 <= codePoint && codePoint <= 0xFE19 || 0xFE30 <= codePoint && codePoint <= 0xFE52 || 0xFE54 <= codePoint && codePoint <= 0xFE66 || 0xFE68 <= codePoint && codePoint <= 0xFE6B || 0x1B000 <= codePoint && codePoint <= 0x1B001 || 0x1F200 <= codePoint && codePoint <= 0x1F202 || 0x1F210 <= codePoint && codePoint <= 0x1F23A || 0x1F240 <= codePoint && codePoint <= 0x1F248 || 0x1F250 <= codePoint && codePoint <= 0x1F251 || 0x20000 <= codePoint && codePoint <= 0x2F73F || 0x2B740 <= codePoint && codePoint <= 0x2FFFD || 0x30000 <= codePoint && codePoint <= 0x3FFFD) return "W";
    if (0x0020 <= codePoint && codePoint <= 0x007E || 0x00A2 <= codePoint && codePoint <= 0x00A3 || 0x00A5 <= codePoint && codePoint <= 0x00A6 || 0x00AC == codePoint || 0x00AF == codePoint || 0x27E6 <= codePoint && codePoint <= 0x27ED || 0x2985 <= codePoint && codePoint <= 0x2986) return "Na";
    if (0x00A1 == codePoint || 0x00A4 == codePoint || 0x00A7 <= codePoint && codePoint <= 0x00A8 || 0x00AA == codePoint || 0x00AD <= codePoint && codePoint <= 0x00AE || 0x00B0 <= codePoint && codePoint <= 0x00B4 || 0x00B6 <= codePoint && codePoint <= 0x00BA || 0x00BC <= codePoint && codePoint <= 0x00BF || 0x00C6 == codePoint || 0x00D0 == codePoint || 0x00D7 <= codePoint && codePoint <= 0x00D8 || 0x00DE <= codePoint && codePoint <= 0x00E1 || 0x00E6 == codePoint || 0x00E8 <= codePoint && codePoint <= 0x00EA || 0x00EC <= codePoint && codePoint <= 0x00ED || 0x00F0 == codePoint || 0x00F2 <= codePoint && codePoint <= 0x00F3 || 0x00F7 <= codePoint && codePoint <= 0x00FA || 0x00FC == codePoint || 0x00FE == codePoint || 0x0101 == codePoint || 0x0111 == codePoint || 0x0113 == codePoint || 0x011B == codePoint || 0x0126 <= codePoint && codePoint <= 0x0127 || 0x012B == codePoint || 0x0131 <= codePoint && codePoint <= 0x0133 || 0x0138 == codePoint || 0x013F <= codePoint && codePoint <= 0x0142 || 0x0144 == codePoint || 0x0148 <= codePoint && codePoint <= 0x014B || 0x014D == codePoint || 0x0152 <= codePoint && codePoint <= 0x0153 || 0x0166 <= codePoint && codePoint <= 0x0167 || 0x016B == codePoint || 0x01CE == codePoint || 0x01D0 == codePoint || 0x01D2 == codePoint || 0x01D4 == codePoint || 0x01D6 == codePoint || 0x01D8 == codePoint || 0x01DA == codePoint || 0x01DC == codePoint || 0x0251 == codePoint || 0x0261 == codePoint || 0x02C4 == codePoint || 0x02C7 == codePoint || 0x02C9 <= codePoint && codePoint <= 0x02CB || 0x02CD == codePoint || 0x02D0 == codePoint || 0x02D8 <= codePoint && codePoint <= 0x02DB || 0x02DD == codePoint || 0x02DF == codePoint || 0x0300 <= codePoint && codePoint <= 0x036F || 0x0391 <= codePoint && codePoint <= 0x03A1 || 0x03A3 <= codePoint && codePoint <= 0x03A9 || 0x03B1 <= codePoint && codePoint <= 0x03C1 || 0x03C3 <= codePoint && codePoint <= 0x03C9 || 0x0401 == codePoint || 0x0410 <= codePoint && codePoint <= 0x044F || 0x0451 == codePoint || 0x2010 == codePoint || 0x2013 <= codePoint && codePoint <= 0x2016 || 0x2018 <= codePoint && codePoint <= 0x2019 || 0x201C <= codePoint && codePoint <= 0x201D || 0x2020 <= codePoint && codePoint <= 0x2022 || 0x2024 <= codePoint && codePoint <= 0x2027 || 0x2030 == codePoint || 0x2032 <= codePoint && codePoint <= 0x2033 || 0x2035 == codePoint || 0x203B == codePoint || 0x203E == codePoint || 0x2074 == codePoint || 0x207F == codePoint || 0x2081 <= codePoint && codePoint <= 0x2084 || 0x20AC == codePoint || 0x2103 == codePoint || 0x2105 == codePoint || 0x2109 == codePoint || 0x2113 == codePoint || 0x2116 == codePoint || 0x2121 <= codePoint && codePoint <= 0x2122 || 0x2126 == codePoint || 0x212B == codePoint || 0x2153 <= codePoint && codePoint <= 0x2154 || 0x215B <= codePoint && codePoint <= 0x215E || 0x2160 <= codePoint && codePoint <= 0x216B || 0x2170 <= codePoint && codePoint <= 0x2179 || 0x2189 == codePoint || 0x2190 <= codePoint && codePoint <= 0x2199 || 0x21B8 <= codePoint && codePoint <= 0x21B9 || 0x21D2 == codePoint || 0x21D4 == codePoint || 0x21E7 == codePoint || 0x2200 == codePoint || 0x2202 <= codePoint && codePoint <= 0x2203 || 0x2207 <= codePoint && codePoint <= 0x2208 || 0x220B == codePoint || 0x220F == codePoint || 0x2211 == codePoint || 0x2215 == codePoint || 0x221A == codePoint || 0x221D <= codePoint && codePoint <= 0x2220 || 0x2223 == codePoint || 0x2225 == codePoint || 0x2227 <= codePoint && codePoint <= 0x222C || 0x222E == codePoint || 0x2234 <= codePoint && codePoint <= 0x2237 || 0x223C <= codePoint && codePoint <= 0x223D || 0x2248 == codePoint || 0x224C == codePoint || 0x2252 == codePoint || 0x2260 <= codePoint && codePoint <= 0x2261 || 0x2264 <= codePoint && codePoint <= 0x2267 || 0x226A <= codePoint && codePoint <= 0x226B || 0x226E <= codePoint && codePoint <= 0x226F || 0x2282 <= codePoint && codePoint <= 0x2283 || 0x2286 <= codePoint && codePoint <= 0x2287 || 0x2295 == codePoint || 0x2299 == codePoint || 0x22A5 == codePoint || 0x22BF == codePoint || 0x2312 == codePoint || 0x2460 <= codePoint && codePoint <= 0x24E9 || 0x24EB <= codePoint && codePoint <= 0x254B || 0x2550 <= codePoint && codePoint <= 0x2573 || 0x2580 <= codePoint && codePoint <= 0x258F || 0x2592 <= codePoint && codePoint <= 0x2595 || 0x25A0 <= codePoint && codePoint <= 0x25A1 || 0x25A3 <= codePoint && codePoint <= 0x25A9 || 0x25B2 <= codePoint && codePoint <= 0x25B3 || 0x25B6 <= codePoint && codePoint <= 0x25B7 || 0x25BC <= codePoint && codePoint <= 0x25BD || 0x25C0 <= codePoint && codePoint <= 0x25C1 || 0x25C6 <= codePoint && codePoint <= 0x25C8 || 0x25CB == codePoint || 0x25CE <= codePoint && codePoint <= 0x25D1 || 0x25E2 <= codePoint && codePoint <= 0x25E5 || 0x25EF == codePoint || 0x2605 <= codePoint && codePoint <= 0x2606 || 0x2609 == codePoint || 0x260E <= codePoint && codePoint <= 0x260F || 0x2614 <= codePoint && codePoint <= 0x2615 || 0x261C == codePoint || 0x261E == codePoint || 0x2640 == codePoint || 0x2642 == codePoint || 0x2660 <= codePoint && codePoint <= 0x2661 || 0x2663 <= codePoint && codePoint <= 0x2665 || 0x2667 <= codePoint && codePoint <= 0x266A || 0x266C <= codePoint && codePoint <= 0x266D || 0x266F == codePoint || 0x269E <= codePoint && codePoint <= 0x269F || 0x26BE <= codePoint && codePoint <= 0x26BF || 0x26C4 <= codePoint && codePoint <= 0x26CD || 0x26CF <= codePoint && codePoint <= 0x26E1 || 0x26E3 == codePoint || 0x26E8 <= codePoint && codePoint <= 0x26FF || 0x273D == codePoint || 0x2757 == codePoint || 0x2776 <= codePoint && codePoint <= 0x277F || 0x2B55 <= codePoint && codePoint <= 0x2B59 || 0x3248 <= codePoint && codePoint <= 0x324F || 0xE000 <= codePoint && codePoint <= 0xF8FF || 0xFE00 <= codePoint && codePoint <= 0xFE0F || 0xFFFD == codePoint || 0x1F100 <= codePoint && codePoint <= 0x1F10A || 0x1F110 <= codePoint && codePoint <= 0x1F12D || 0x1F130 <= codePoint && codePoint <= 0x1F169 || 0x1F170 <= codePoint && codePoint <= 0x1F19A || 0xE0100 <= codePoint && codePoint <= 0xE01EF || 0xF0000 <= codePoint && codePoint <= 0xFFFFD || 0x100000 <= codePoint && codePoint <= 0x10FFFD) return "A";
    return "N";
};
$6ce6878769f9660b$var$eaw.characterLength = function(character) {
    var code = this.eastAsianWidth(character);
    if (code == "F" || code == "W" || code == "A") return 2;
    else return 1;
};
// Split a string considering surrogate-pairs.
function $6ce6878769f9660b$var$stringToArray(string) {
    return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
}
$6ce6878769f9660b$var$eaw.length = function(string) {
    var characters = $6ce6878769f9660b$var$stringToArray(string);
    var len = 0;
    for(var i = 0; i < characters.length; i++)len = len + this.characterLength(characters[i]);
    return len;
};
$6ce6878769f9660b$var$eaw.slice = function(text, start, end) {
    textLen = $6ce6878769f9660b$var$eaw.length(text);
    start = start ? start : 0;
    end = end ? end : 1;
    if (start < 0) start = textLen + start;
    if (end < 0) end = textLen + end;
    var result = "";
    var eawLen = 0;
    var chars = $6ce6878769f9660b$var$stringToArray(text);
    for(var i = 0; i < chars.length; i++){
        var char = chars[i];
        var charLen = $6ce6878769f9660b$var$eaw.length(char);
        if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
            if (eawLen + charLen <= end) result += char;
            else break;
        }
        eawLen += charLen;
    }
    return result;
};


var $5bd67d5907208b2e$export$2e2bcd8739ae039 = ()=>{
    // https://mths.be/emoji
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};


function $c62706740a9380d1$export$2e2bcd8739ae039(string, options) {
    if (typeof string !== "string" || string.length === 0) return 0;
    options = {
        ambiguousIsNarrow: true,
        countAnsiEscapeCodes: false,
        ...options
    };
    if (!options.countAnsiEscapeCodes) string = (0, $1281305204dfe64a$export$2e2bcd8739ae039)(string);
    if (string.length === 0) return 0;
    const ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2;
    let width = 0;
    for (const { segment: character } of new Intl.Segmenter().segment(string)){
        const codePoint = character.codePointAt(0);
        // Ignore control characters
        if (codePoint <= 0x1F || codePoint >= 0x7F && codePoint <= 0x9F) continue;
        // Ignore combining characters
        if (codePoint >= 0x300 && codePoint <= 0x36F) continue;
        if ((0, $5bd67d5907208b2e$export$2e2bcd8739ae039)().test(character)) {
            width += 2;
            continue;
        }
        const code = (0, (/*@__PURE__*/$parcel$interopDefault($6ce6878769f9660b$exports))).eastAsianWidth(character);
        switch(code){
            case "F":
            case "W":
                width += 2;
                break;
            case "A":
                width += ambiguousCharacterWidth;
                break;
            default:
                width += 1;
        }
    }
    return width;
}


function $da24b4177333a3b7$export$2e2bcd8739ae039({ stream: stream = process.stdout } = {}) {
    return Boolean(stream && stream.isTTY && process.env.TERM !== "dumb" && true);
}





var $644381ae12f61147$exports = {};
"use strict";

var $9FpLB = parcelRequire("9FpLB");
var $644381ae12f61147$require$DuplexStream = $9FpLB.Duplex;

var $csJOe = parcelRequire("csJOe");
var $f2efacf03cdba266$exports = {};
"use strict";

var $f2efacf03cdba266$require$Buffer = $dAk3n$buffer.Buffer;
const $f2efacf03cdba266$var$symbol = Symbol.for("BufferList");
function $f2efacf03cdba266$var$BufferList(buf) {
    if (!(this instanceof $f2efacf03cdba266$var$BufferList)) return new $f2efacf03cdba266$var$BufferList(buf);
    $f2efacf03cdba266$var$BufferList._init.call(this, buf);
}
$f2efacf03cdba266$var$BufferList._init = function _init(buf) {
    Object.defineProperty(this, $f2efacf03cdba266$var$symbol, {
        value: true
    });
    this._bufs = [];
    this.length = 0;
    if (buf) this.append(buf);
};
$f2efacf03cdba266$var$BufferList.prototype._new = function _new(buf) {
    return new $f2efacf03cdba266$var$BufferList(buf);
};
$f2efacf03cdba266$var$BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) return [
        0,
        0
    ];
    let tot = 0;
    for(let i = 0; i < this._bufs.length; i++){
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) return [
            i,
            offset - tot
        ];
        tot = _t;
    }
};
$f2efacf03cdba266$var$BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for(let i = 0; i < bufferId; i++)offset += this._bufs[i].length;
    return offset;
};
$f2efacf03cdba266$var$BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) return undefined;
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
};
$f2efacf03cdba266$var$BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) start += this.length;
    if (typeof end === "number" && end < 0) end += this.length;
    return this.copy(null, 0, start, end);
};
$f2efacf03cdba266$var$BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) srcStart = 0;
    if (typeof srcEnd !== "number" || srcEnd > this.length) srcEnd = this.length;
    if (srcStart >= this.length) return dst || $f2efacf03cdba266$require$Buffer.alloc(0);
    if (srcEnd <= 0) return dst || $f2efacf03cdba266$require$Buffer.alloc(0);
    const copy = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy && dstStart || 0;
    let start = off[1];
    // copy/slice everything
    if (srcStart === 0 && srcEnd === this.length) {
        if (!copy) // slice, but full concat if multiple buffers
        return this._bufs.length === 1 ? this._bufs[0] : $f2efacf03cdba266$require$Buffer.concat(this._bufs, this.length);
        // copy, need to copy individual buffers
        for(let i = 0; i < this._bufs.length; i++){
            this._bufs[i].copy(dst, bufoff);
            bufoff += this._bufs[i].length;
        }
        return dst;
    }
    // easy, cheap case where it's a subset of one of the buffers
    if (bytes <= this._bufs[off[0]].length - start) return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    if (!copy) // a slice, we need something to copy in to
    dst = $f2efacf03cdba266$require$Buffer.allocUnsafe(len);
    for(let i = off[0]; i < this._bufs.length; i++){
        const l = this._bufs[i].length - start;
        if (bytes > l) {
            this._bufs[i].copy(dst, bufoff, start);
            bufoff += l;
        } else {
            this._bufs[i].copy(dst, bufoff, start, start + bytes);
            bufoff += l;
            break;
        }
        bytes -= l;
        if (start) start = 0;
    }
    // safeguard so that we don't return uninitialized memory
    if (dst.length > bufoff) return dst.slice(0, bufoff);
    return dst;
};
$f2efacf03cdba266$var$BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) start += this.length;
    if (end < 0) end += this.length;
    if (start === end) return this._new();
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) buffers.pop();
    else buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    if (startOffset[1] !== 0) buffers[0] = buffers[0].slice(startOffset[1]);
    return this._new(buffers);
};
$f2efacf03cdba266$var$BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
};
$f2efacf03cdba266$var$BufferList.prototype.consume = function consume(bytes) {
    // first, normalize the argument, in accordance with how Buffer does it
    bytes = Math.trunc(bytes);
    // do nothing if not a positive number
    if (Number.isNaN(bytes) || bytes <= 0) return this;
    while(this._bufs.length)if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
    } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
    }
    return this;
};
$f2efacf03cdba266$var$BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for(let i = 0; i < this._bufs.length; i++)copy.append(this._bufs[i]);
    return copy;
};
$f2efacf03cdba266$var$BufferList.prototype.append = function append(buf) {
    if (buf == null) return this;
    if (buf.buffer) // append a view of the underlying ArrayBuffer
    this._appendBuffer($f2efacf03cdba266$require$Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
    else if (Array.isArray(buf)) for(let i = 0; i < buf.length; i++)this.append(buf[i]);
    else if (this._isBufferList(buf)) // unwrap argument into individual BufferLists
    for(let i = 0; i < buf._bufs.length; i++)this.append(buf._bufs[i]);
    else {
        // coerce number arguments to strings, since Buffer(number) does
        // uninitialized memory allocation
        if (typeof buf === "number") buf = buf.toString();
        this._appendBuffer($f2efacf03cdba266$require$Buffer.from(buf));
    }
    return this;
};
$f2efacf03cdba266$var$BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
};
$f2efacf03cdba266$var$BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === undefined && typeof offset === "string") {
        encoding = offset;
        offset = undefined;
    }
    if (typeof search === "function" || Array.isArray(search)) throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    else if (typeof search === "number") search = $f2efacf03cdba266$require$Buffer.from([
        search
    ]);
    else if (typeof search === "string") search = $f2efacf03cdba266$require$Buffer.from(search, encoding);
    else if (this._isBufferList(search)) search = search.slice();
    else if (Array.isArray(search.buffer)) search = $f2efacf03cdba266$require$Buffer.from(search.buffer, search.byteOffset, search.byteLength);
    else if (!$f2efacf03cdba266$require$Buffer.isBuffer(search)) search = $f2efacf03cdba266$require$Buffer.from(search);
    offset = Number(offset || 0);
    if (isNaN(offset)) offset = 0;
    if (offset < 0) offset = this.length + offset;
    if (offset < 0) offset = 0;
    if (search.length === 0) return offset > this.length ? this.length : offset;
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0] // index of which internal buffer we're working on
    ;
    let buffOffset = blOffset[1] // offset of the internal buffer we're working on
    ;
    // scan over each buffer
    for(; blIndex < this._bufs.length; blIndex++){
        const buff = this._bufs[blIndex];
        while(buffOffset < buff.length){
            const availableWindow = buff.length - buffOffset;
            if (availableWindow >= search.length) {
                const nativeSearchResult = buff.indexOf(search, buffOffset);
                if (nativeSearchResult !== -1) return this._reverseOffset([
                    blIndex,
                    nativeSearchResult
                ]);
                buffOffset = buff.length - search.length + 1 // end of native search window
                ;
            } else {
                const revOffset = this._reverseOffset([
                    blIndex,
                    buffOffset
                ]);
                if (this._match(revOffset, search)) return revOffset;
                buffOffset++;
            }
        }
        buffOffset = 0;
    }
    return -1;
};
$f2efacf03cdba266$var$BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) return false;
    for(let searchOffset = 0; searchOffset < search.length; searchOffset++){
        if (this.get(offset + searchOffset) !== search[searchOffset]) return false;
    }
    return true;
};
(function() {
    const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
    };
    for(const m in methods)(function(m) {
        if (methods[m] === null) $f2efacf03cdba266$var$BufferList.prototype[m] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m](0, byteLength);
        };
        else $f2efacf03cdba266$var$BufferList.prototype[m] = function(offset = 0) {
            return this.slice(offset, offset + methods[m])[m](0);
        };
    })(m);
})();
// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
$f2efacf03cdba266$var$BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof $f2efacf03cdba266$var$BufferList || $f2efacf03cdba266$var$BufferList.isBufferList(b);
};
$f2efacf03cdba266$var$BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[$f2efacf03cdba266$var$symbol];
};
$f2efacf03cdba266$exports = $f2efacf03cdba266$var$BufferList;


function $644381ae12f61147$var$BufferListStream(callback) {
    if (!(this instanceof $644381ae12f61147$var$BufferListStream)) return new $644381ae12f61147$var$BufferListStream(callback);
    if (typeof callback === "function") {
        this._callback = callback;
        const piper = (function piper(err) {
            if (this._callback) {
                this._callback(err);
                this._callback = null;
            }
        }).bind(this);
        this.on("pipe", function onPipe(src) {
            src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
            src.removeListener("error", piper);
        });
        callback = null;
    }
    $f2efacf03cdba266$exports._init.call(this, callback);
    $644381ae12f61147$require$DuplexStream.call(this);
}
$csJOe($644381ae12f61147$var$BufferListStream, $644381ae12f61147$require$DuplexStream);
Object.assign($644381ae12f61147$var$BufferListStream.prototype, $f2efacf03cdba266$exports.prototype);
$644381ae12f61147$var$BufferListStream.prototype._new = function _new(callback) {
    return new $644381ae12f61147$var$BufferListStream(callback);
};
$644381ae12f61147$var$BufferListStream.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback === "function") callback();
};
$644381ae12f61147$var$BufferListStream.prototype._read = function _read(size) {
    if (!this.length) return this.push(null);
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
};
$644381ae12f61147$var$BufferListStream.prototype.end = function end(chunk) {
    $644381ae12f61147$require$DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
    }
};
$644381ae12f61147$var$BufferListStream.prototype._destroy = function _destroy(err, cb) {
    this._bufs.length = 0;
    this.length = 0;
    cb(err);
};
$644381ae12f61147$var$BufferListStream.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof $644381ae12f61147$var$BufferListStream || b instanceof $f2efacf03cdba266$exports || $644381ae12f61147$var$BufferListStream.isBufferList(b);
};
$644381ae12f61147$var$BufferListStream.isBufferList = $f2efacf03cdba266$exports.isBufferList;
$644381ae12f61147$exports = $644381ae12f61147$var$BufferListStream;
$644381ae12f61147$exports.BufferListStream = $644381ae12f61147$var$BufferListStream;
$644381ae12f61147$exports.BufferList = $f2efacf03cdba266$exports;


const $cb5afe9c7f1c709a$var$ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code
class $cb5afe9c7f1c709a$var$StdinDiscarder {
    #requests = 0;
    #mutedStream = new (0, $644381ae12f61147$exports.BufferListStream)();
    #ourEmit;
    #rl;
    constructor(){
        this.#mutedStream.pipe((0, ($parcel$interopDefault($dAk3n$nodeprocess))).stdout);
        const self = this; // eslint-disable-line unicorn/no-this-assignment
        this.#ourEmit = function(event, data, ...arguments_) {
            const { stdin: stdin } = (0, ($parcel$interopDefault($dAk3n$nodeprocess)));
            if (self.#requests > 0 || stdin.emit === self.#ourEmit) {
                if (event === "keypress") return;
                if (event === "data" && data.includes($cb5afe9c7f1c709a$var$ASCII_ETX_CODE)) (0, ($parcel$interopDefault($dAk3n$nodeprocess))).emit("SIGINT");
                Reflect.apply(self.#ourEmit, this, [
                    event,
                    data,
                    ...arguments_
                ]);
            } else Reflect.apply((0, ($parcel$interopDefault($dAk3n$nodeprocess))).stdin.emit, this, [
                event,
                data,
                ...arguments_
            ]);
        };
    }
    start() {
        this.#requests++;
        if (this.#requests === 1) this._realStart();
    }
    stop() {
        if (this.#requests <= 0) throw new Error("`stop` called more times than `start`");
        this.#requests--;
        if (this.#requests === 0) this._realStop();
    }
    // TODO: Use private methods when targeting Node.js 14.
    _realStart() {
        // No known way to make it work reliably on Windows
        if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).platform === "win32") return;
        this.#rl = (0, ($parcel$interopDefault($dAk3n$nodereadline))).createInterface({
            input: (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stdin,
            output: this.#mutedStream
        });
        this.#rl.on("SIGINT", ()=>{
            if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).listenerCount("SIGINT") === 0) (0, ($parcel$interopDefault($dAk3n$nodeprocess))).emit("SIGINT");
            else {
                this.#rl.close();
                (0, ($parcel$interopDefault($dAk3n$nodeprocess))).kill((0, ($parcel$interopDefault($dAk3n$nodeprocess))).pid, "SIGINT");
            }
        });
    }
    _realStop() {
        if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).platform === "win32") return;
        this.#rl.close();
        this.#rl = undefined;
    }
}
const $cb5afe9c7f1c709a$var$stdinDiscarder = new $cb5afe9c7f1c709a$var$StdinDiscarder();
var $cb5afe9c7f1c709a$export$2e2bcd8739ae039 = $cb5afe9c7f1c709a$var$stdinDiscarder;


class $cc3a8e664012cf12$var$Ora {
    #linesToClear = 0;
    #isDiscardingStdin = false;
    #lineCount = 0;
    #frameIndex = 0;
    #options;
    #spinner;
    #stream;
    #id;
    #initialInterval;
    #isEnabled;
    #isSilent;
    #indent;
    #text;
    #prefixText;
    #suffixText;
    color;
    constructor(options){
        if (typeof options === "string") options = {
            text: options
        };
        this.#options = {
            color: "cyan",
            stream: (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stderr,
            discardStdin: true,
            hideCursor: true,
            ...options
        };
        // Public
        this.color = this.#options.color;
        // It's important that these use the public setters.
        this.spinner = this.#options.spinner;
        this.#initialInterval = this.#options.interval;
        this.#stream = this.#options.stream;
        this.#isEnabled = typeof this.#options.isEnabled === "boolean" ? this.#options.isEnabled : (0, $da24b4177333a3b7$export$2e2bcd8739ae039)({
            stream: this.#stream
        });
        this.#isSilent = typeof this.#options.isSilent === "boolean" ? this.#options.isSilent : false;
        // Set *after* `this.#stream`.
        // It's important that these use the public setters.
        this.text = this.#options.text;
        this.prefixText = this.#options.prefixText;
        this.suffixText = this.#options.suffixText;
        this.indent = this.#options.indent;
        if ((0, ($parcel$interopDefault($dAk3n$nodeprocess))).env.NODE_ENV === "test") {
            this._stream = this.#stream;
            this._isEnabled = this.#isEnabled;
            Object.defineProperty(this, "_linesToClear", {
                get () {
                    return this.#linesToClear;
                },
                set (newValue) {
                    this.#linesToClear = newValue;
                }
            });
            Object.defineProperty(this, "_frameIndex", {
                get () {
                    return this.#frameIndex;
                }
            });
            Object.defineProperty(this, "_lineCount", {
                get () {
                    return this.#lineCount;
                }
            });
        }
    }
    get indent() {
        return this.#indent;
    }
    set indent(indent = 0) {
        if (!(indent >= 0 && Number.isInteger(indent))) throw new Error("The `indent` option must be an integer from 0 and up");
        this.#indent = indent;
        this.#updateLineCount();
    }
    get interval() {
        return this.#initialInterval ?? this.#spinner.interval ?? 100;
    }
    get spinner() {
        return this.#spinner;
    }
    set spinner(spinner) {
        this.#frameIndex = 0;
        this.#initialInterval = undefined;
        if (typeof spinner === "object") {
            if (spinner.frames === undefined) throw new Error("The given spinner must have a `frames` property");
            this.#spinner = spinner;
        } else if (!(0, $cc92293829744d89$export$2e2bcd8739ae039)()) this.#spinner = (0, (/*@__PURE__*/$parcel$interopDefault($c7ee00d8f6b7286b$exports))).line;
        else if (spinner === undefined) // Set default spinner
        this.#spinner = (0, (/*@__PURE__*/$parcel$interopDefault($c7ee00d8f6b7286b$exports))).dots;
        else if (spinner !== "default" && (0, (/*@__PURE__*/$parcel$interopDefault($c7ee00d8f6b7286b$exports)))[spinner]) this.#spinner = (0, (/*@__PURE__*/$parcel$interopDefault($c7ee00d8f6b7286b$exports)))[spinner];
        else throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    }
    get text() {
        return this.#text;
    }
    set text(value = "") {
        this.#text = value;
        this.#updateLineCount();
    }
    get prefixText() {
        return this.#prefixText;
    }
    set prefixText(value = "") {
        this.#prefixText = value;
        this.#updateLineCount();
    }
    get suffixText() {
        return this.#suffixText;
    }
    set suffixText(value = "") {
        this.#suffixText = value;
        this.#updateLineCount();
    }
    get isSpinning() {
        return this.#id !== undefined;
    }
    #getFullPrefixText(prefixText = this.#prefixText, postfix = " ") {
        if (typeof prefixText === "string" && prefixText !== "") return prefixText + postfix;
        if (typeof prefixText === "function") return prefixText() + postfix;
        return "";
    }
    #getFullSuffixText(suffixText = this.#suffixText, prefix = " ") {
        if (typeof suffixText === "string" && suffixText !== "") return prefix + suffixText;
        if (typeof suffixText === "function") return prefix + suffixText();
        return "";
    }
    #updateLineCount() {
        const columns = this.#stream.columns ?? 80;
        const fullPrefixText = this.#getFullPrefixText(this.#prefixText, "-");
        const fullSuffixText = this.#getFullSuffixText(this.#suffixText, "-");
        const fullText = " ".repeat(this.#indent) + fullPrefixText + "--" + this.#text + "--" + fullSuffixText;
        this.#lineCount = 0;
        for (const line of (0, $1281305204dfe64a$export$2e2bcd8739ae039)(fullText).split("\n"))this.#lineCount += Math.max(1, Math.ceil((0, $c62706740a9380d1$export$2e2bcd8739ae039)(line, {
            countAnsiEscapeCodes: true
        }) / columns));
    }
    get isEnabled() {
        return this.#isEnabled && !this.#isSilent;
    }
    set isEnabled(value) {
        if (typeof value !== "boolean") throw new TypeError("The `isEnabled` option must be a boolean");
        this.#isEnabled = value;
    }
    get isSilent() {
        return this.#isSilent;
    }
    set isSilent(value) {
        if (typeof value !== "boolean") throw new TypeError("The `isSilent` option must be a boolean");
        this.#isSilent = value;
    }
    frame() {
        const { frames: frames } = this.#spinner;
        let frame = frames[this.#frameIndex];
        if (this.color) frame = (0, $08c9c3830789cde8$export$2e2bcd8739ae039)[this.color](frame);
        this.#frameIndex = ++this.#frameIndex % frames.length;
        const fullPrefixText = typeof this.#prefixText === "string" && this.#prefixText !== "" ? this.#prefixText + " " : "";
        const fullText = typeof this.text === "string" ? " " + this.text : "";
        const fullSuffixText = typeof this.#suffixText === "string" && this.#suffixText !== "" ? " " + this.#suffixText : "";
        return fullPrefixText + frame + fullText + fullSuffixText;
    }
    clear() {
        if (!this.#isEnabled || !this.#stream.isTTY) return this;
        this.#stream.cursorTo(0);
        for(let index = 0; index < this.#linesToClear; index++){
            if (index > 0) this.#stream.moveCursor(0, -1);
            this.#stream.clearLine(1);
        }
        if (this.#indent || this.lastIndent !== this.#indent) this.#stream.cursorTo(this.#indent);
        this.lastIndent = this.#indent;
        this.#linesToClear = 0;
        return this;
    }
    render() {
        if (this.#isSilent) return this;
        this.clear();
        this.#stream.write(this.frame());
        this.#linesToClear = this.#lineCount;
        return this;
    }
    start(text) {
        if (text) this.text = text;
        if (this.#isSilent) return this;
        if (!this.#isEnabled) {
            if (this.text) this.#stream.write(`- ${this.text}\n`);
            return this;
        }
        if (this.isSpinning) return this;
        if (this.#options.hideCursor) (0, $00caa5736a546440$export$2e2bcd8739ae039).hide(this.#stream);
        if (this.#options.discardStdin && (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stdin.isTTY) {
            this.#isDiscardingStdin = true;
            (0, $cb5afe9c7f1c709a$export$2e2bcd8739ae039).start();
        }
        this.render();
        this.#id = setInterval(this.render.bind(this), this.interval);
        return this;
    }
    stop() {
        if (!this.#isEnabled) return this;
        clearInterval(this.#id);
        this.#id = undefined;
        this.#frameIndex = 0;
        this.clear();
        if (this.#options.hideCursor) (0, $00caa5736a546440$export$2e2bcd8739ae039).show(this.#stream);
        if (this.#options.discardStdin && (0, ($parcel$interopDefault($dAk3n$nodeprocess))).stdin.isTTY && this.#isDiscardingStdin) {
            (0, $cb5afe9c7f1c709a$export$2e2bcd8739ae039).stop();
            this.#isDiscardingStdin = false;
        }
        return this;
    }
    succeed(text) {
        return this.stopAndPersist({
            symbol: (0, $337332179f0ad580$export$2e2bcd8739ae039).success,
            text: text
        });
    }
    fail(text) {
        return this.stopAndPersist({
            symbol: (0, $337332179f0ad580$export$2e2bcd8739ae039).error,
            text: text
        });
    }
    warn(text) {
        return this.stopAndPersist({
            symbol: (0, $337332179f0ad580$export$2e2bcd8739ae039).warning,
            text: text
        });
    }
    info(text) {
        return this.stopAndPersist({
            symbol: (0, $337332179f0ad580$export$2e2bcd8739ae039).info,
            text: text
        });
    }
    stopAndPersist(options = {}) {
        if (this.#isSilent) return this;
        const prefixText = options.prefixText ?? this.#prefixText;
        const fullPrefixText = this.#getFullPrefixText(prefixText, " ");
        const symbolText = options.symbol ?? " ";
        const text = options.text ?? this.text;
        const fullText = typeof text === "string" ? " " + text : "";
        const suffixText = options.suffixText ?? this.#suffixText;
        const fullSuffixText = this.#getFullSuffixText(suffixText, " ");
        const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + "\n";
        this.stop();
        this.#stream.write(textToWrite);
        return this;
    }
}
function $cc3a8e664012cf12$export$2e2bcd8739ae039(options) {
    return new $cc3a8e664012cf12$var$Ora(options);
}
async function $cc3a8e664012cf12$export$9cecb697d3976284(action, options) {
    const actionIsFunction = typeof action === "function";
    const actionIsPromise = typeof action.then === "function";
    if (!actionIsFunction && !actionIsPromise) throw new TypeError("Parameter `action` must be a Function or a Promise");
    const { successText: successText, failText: failText } = typeof options === "object" ? options : {
        successText: undefined,
        failText: undefined
    };
    const spinner = $cc3a8e664012cf12$export$2e2bcd8739ae039(options).start();
    try {
        const promise = actionIsFunction ? action(spinner) : action;
        const result = await promise;
        spinner.succeed(successText === undefined ? undefined : typeof successText === "string" ? successText : successText(result));
        return result;
    } catch (error) {
        spinner.fail(failText === undefined ? undefined : typeof failText === "string" ? failText : failText(error));
        throw error;
    }
}


async function $ebc59e390eb9c754$export$3597ef52e40befe4({ supportedTargetString: supportedTargetString, version: version }) {
    const setupSpinner = (0, $cc3a8e664012cf12$export$2e2bcd8739ae039)("⚙️ Setting up the Tunnel CLI...").start();
    const tunnelCliSingleExecutableApplicationDirpath = (0, $865d9c3319d37e5b$export$62ef9d444c3dc9b3)({
        supportedTargetString: supportedTargetString,
        version: version
    });
    await (0, ($parcel$interopDefault($dAk3n$nodefs))).promises.mkdir((0, $339004cb28bc6ac3$export$ffb5f4729a158638).dirname(tunnelCliSingleExecutableApplicationDirpath), {
        recursive: true
    });
    const cliSingleExecutableApplicationPackageName = supportedTargetString === "untargeted" ? `@tunnel/cli-single-executable-application` : `@tunnel/cli-single-executable-application-${supportedTargetString}`;
    // Download `@t/cli-single-executable-application-${target}` into `~/.tunnel`
    const tarballUrl = `https://registry.npmjs.org/${cliSingleExecutableApplicationPackageName}/-/${cliSingleExecutableApplicationPackageName.replace("@tunnel/", "")}-${version}.tgz`;
    await (0, $ba32fe0881171a38$export$2e2bcd8739ae039)(tarballUrl, tunnelCliSingleExecutableApplicationDirpath, {
        extract: {
            strip: 1
        }
    });
    setupSpinner.succeed("⚙️ Finished setting up the Tunnel CLI!");
    // If we downloaded the untargeted version, we should install the `@tunnel/cli-source` dependencies in advance
    if (supportedTargetString === "untargeted") {
        const cliSingleExecutableApplicationBinFilepath = (0, $339004cb28bc6ac3$export$ffb5f4729a158638).join(tunnelCliSingleExecutableApplicationDirpath, supportedTargetString.startsWith("win32") ? "tunnel.exe" : "tunnel");
        await (0, $dd3803b97d87fa97$export$db6b1668e3758717)(cliSingleExecutableApplicationBinFilepath, {
            env: {
                RUN_CLI_SOURCE: "0"
            },
            cwd: tunnelCliSingleExecutableApplicationDirpath,
            stdio: "inherit"
        });
    }
}



var $7ec4882e819ac371$exports = {};
$7ec4882e819ac371$exports = JSON.parse('{"name":"@t/npm-package","type":"module","version":"0.3.0-staging.5","bin":{"tunnel":"./src/bin/tunnel.ts"},"dependencies":{"@t/target":"workspace:*","downl":"0.1.0","execa":"8.0.1","latest-version":"7.0.0","ora":"7.0.1","package-json":"8.1.1","pathe":"1.1.1"},"devDependencies":{"@t/logger":"workspace:*","@t/packages-config":"workspace:*","@t/parcel-cli":"workspace:*","@tunnel/loader":"1.0.16","@tunnel/parcel-config":"1.0.1","commander":"11.0.0","es-main":"1.2.0","parcel":"2.9.3","parcel-resolver-monorepo-packages":"1.0.2"},"targets":{"npm-package":{"context":"node","distDir":"dist/bin","outputFormat":"commonjs","isLibrary":true,"sourceMap":false,"includeNodeModules":{}},"postinstall":{"context":"node","distDir":"dist","outputFormat":"commonjs","isLibrary":true,"sourceMap":false,"includeNodeModules":{}}},"publishable":true,"tsconfig":"tsconfig.bundler.json"}');


(async ()=>{
    const latestVersion = await (0, $2d0e8569f207513b$export$2e2bcd8739ae039)("@tunnel/cli-single-executable-application", {
        version: (0, (/*@__PURE__*/$parcel$interopDefault($7ec4882e819ac371$exports))).version.includes("staging") ? "staging" : "latest"
    });
    const supportedTargetString = (0, $0b247b6288277a12$export$54acae3e6c7216cb)({
        platform: process.platform,
        arch: process.arch
    });
    const tunnelSingleExecutableApplicationInstallationPath = (0, $865d9c3319d37e5b$export$62ef9d444c3dc9b3)({
        supportedTargetString: supportedTargetString,
        version: latestVersion
    });
    if (!(0, ($parcel$interopDefault($dAk3n$nodefs))).existsSync(tunnelSingleExecutableApplicationInstallationPath)) await (0, $ebc59e390eb9c754$export$3597ef52e40befe4)({
        supportedTargetString: supportedTargetString,
        version: latestVersion
    });
    // Execute the `tunnel` binary inside from "@t/cli-single-executable-application"
    const { exitCode: exitCode } = await (0, $dd3803b97d87fa97$export$db6b1668e3758717)((0, $339004cb28bc6ac3$export$ffb5f4729a158638).join(tunnelSingleExecutableApplicationInstallationPath, process.platform === "win32" ? "tunnel.exe" : "tunnel"), process.argv.slice(2), {
        stdio: "inherit"
    });
    process.exit(exitCode);
})();


